"use strict";

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var IframeUrl = /*#__PURE__*/function (_Component) {
  _inheritsLoose(IframeUrl, _Component);

  function IframeUrl() {
    var _this;

    _this = _Component.call(this) || this;

    _defineProperty(_assertThisInitialized(_this), "componentDidUpdate", function (prevProps) {
      if (prevProps.postMessage !== _this.props.postMessage) {
        _this.sendMessage();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "onLoad", function () {
      if (_this.props.onLoad) {
        _this.props.onLoad();
      } // TODO: Look into doing a syn-ack TCP-like handshake
      //       to make sure iFrame is ready to REALLY accept messages, not just loaded.
      // send intial props when iframe loads


      _this.sendMessage();
    });

    _defineProperty(_assertThisInitialized(_this), "serializepostMessage", function (data) {
      // Rely on the browser's built-in structured clone algorithm for serialization of the
      // message as described in
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
      if (!_this.props.serializeMessage) {
        return data;
      } // To be on the safe side we can also ignore the browser's built-in serialization feature
      // and serialize the data manually.


      if (typeof data === "object") {
        return JSON.stringify(data);
      } else if (typeof data === "string") {
        return data;
      } else {
        return "" + data;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "sendMessage", function () {
      // Using postMessage data from props will result in a subtle but deadly bug,
      // where old data from props is being sent instead of new postMessage.
      // This is because data sent from componentWillReceiveProps is not yet in props but only in nextProps.
      var _this$props = _this.props,
          postMessage = _this$props.postMessage,
          targetOrigin = _this$props.targetOrigin;

      var serializedData = _this.serializepostMessage(postMessage);

      _this._frame.contentWindow.postMessage(serializedData, targetOrigin);
    });

    _this.onReceiveMessage = _this.onReceiveMessage.bind(_assertThisInitialized(_this));
    _this.onLoad = _this.onLoad.bind(_assertThisInitialized(_this));
    _this.sendMessage = _this.sendMessage.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = IframeUrl.prototype;

  _proto.componentDidMount = function componentDidMount() {
    window.addEventListener("message", this.onReceiveMessage);

    this._frame.addEventListener("load", this.onLoad);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    window.removeEventListener("message", this.onReceiveMessage, false);
  };

  _proto.onReceiveMessage = function onReceiveMessage(event) {
    if (this.props.onReceiveMessage) {
      this.props.onReceiveMessage(event);
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        className = _this$props2.className,
        url = _this$props2.url;
    return /*#__PURE__*/_react.default.createElement("iframe", {
      ref: function ref(el) {
        _this2._frame = el;
      },
      className: className,
      src: url
    });
  };

  return IframeUrl;
}(_react.Component);

_defineProperty(IframeUrl, "defaultProps", {
  serializeMessage: true,
  targetOrigin: "*",
  postMessage: ""
});

IframeUrl.propTypes = process.env.NODE_ENV !== "production" ? {
  className: _propTypes.default.string,
  url: _propTypes.default.string,
  // Callback function called when iFrame sends the parent window a message.
  onReceiveMessage: _propTypes.default.func,

  /*    
      Callback function called when iframe loads. 
      We're simply listening to the iframe's `window.onload`.
      To ensure communication code in your iframe is totally loaded,
      you can implement a syn-ack TCP-like handshake using `postMessage` and `onReceiveMessage`.
  */
  onLoad: _propTypes.default.func,

  /*
      You can pass it anything you want, we'll serialize to a string
      preferablly use a simple string message or an object.
      If you use an object, you need to follow the same naming convention
      in the iframe so you can parse it accordingly.
  */
  postMessage: _propTypes.default.any.isRequired,

  /*
      Enable use of the browser's built-in structured clone algorithm for serialization
      by settings this to `false`. 
      Default is `true`, using our built in logic for serializing everything to a string.
  */
  serializeMessage: _propTypes.default.bool,

  /*
      Always provide a specific targetOrigin, not *, if you know where the other window's document should be located. Failing to provide a specific target discloses the data you send to any interested malicious site.
  */
  targetOrigin: _propTypes.default.string
} : {};
var _default = IframeUrl;
exports.default = _default;
module.exports = exports.default;