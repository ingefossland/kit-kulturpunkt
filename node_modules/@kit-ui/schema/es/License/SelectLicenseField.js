function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useState, useEffect } from "react";
import PropTypes from "prop-types";
import TextField from '@material-ui/core/TextField';
import Autocomplete, { createFilterOptions } from '@material-ui/lab/Autocomplete';
import { makeStyles } from '@material-ui/core/styles';
import { useTranslation } from 'react-i18next';
import Typography from "@material-ui/core/Typography";
import data from "./License.data";
import LicenseIcon from "./LicenseIcon";
var useStyles = makeStyles(function (theme) {
  var _root;

  return {
    root: (_root = {
      "& .MuiFormLabel-root": {
        fontFamily: "Akkurat, sans-serif"
      },
      "& .MuiInputBase-root": {
        fontFamily: "Akkurat, sans-serif",
        borderTopLeftRadius: "0",
        borderTopRightRadius: "0",
        paddingTop: theme.spacing(3),
        paddingBottom: theme.spacing(1)
      }
    }, _root["& .MuiFormLabel-root"] = {
      fontFamily: "Akkurat, sans-serif"
    }, _root["& .MuiAutocomplete-inputRoot[class*=MuiFilledInput-root] .MuiAutocomplete-input"] = {
      padding: theme.spacing(.25, .5)
    }, _root["& .MuiAutocomplete-tag"] = {
      margin: theme.spacing(.25)
    }, _root),
    option: {
      display: "flex",
      alignItems: "center",
      "& > * + *": {
        marginLeft: theme.spacing(1)
      }
    },
    icon: {
      display: "flex",
      alignItems: "center",
      whiteSpace: "nowrap",
      "& > * + *": {
        marginLeft: theme.spacing(.5)
      }
    },
    text: {
      fontFamily: "Akkurat, sans-serif",
      lineHeight: 1,
      "& > * + *": {
        marginLeft: theme.spacing(.5)
      }
    },
    label: {
      color: theme.palette.text.primary
    },
    value: {
      fontFamily: "Akkurat, sans-serif",
      color: theme.palette.text.secondary
    }
  };
});

var SelectLicenseFieldOption = function SelectLicenseFieldOption(_ref) {
  var value = _ref.value,
      label = _ref.label,
      system = _ref.system;
  var classes = useStyles();
  return /*#__PURE__*/React.createElement("div", {
    className: classes.option
  }, /*#__PURE__*/React.createElement(LicenseIcon, {
    className: classes.icon,
    license: value
  }), /*#__PURE__*/React.createElement(Typography, {
    className: classes.text
  }, /*#__PURE__*/React.createElement("b", {
    className: classes.label
  }, label), /*#__PURE__*/React.createElement("i", {
    className: classes.value
  }, "(", value, ")")));
};

var SelectLicense = function SelectLicense(_ref2) {
  var _React$createElement;

  var id = _ref2.id,
      _ref2$label = _ref2.label,
      label = _ref2$label === void 0 ? "Select icon" : _ref2$label,
      helperText = _ref2.helperText,
      value = _ref2.value,
      required = _ref2.required,
      disabled = _ref2.disabled,
      readonly = _ref2.readonly,
      multiple = _ref2.multiple,
      autofocus = _ref2.autofocus,
      onChange = _ref2.onChange,
      placeholder = _ref2.placeholder;

  var _useTranslation = useTranslation(),
      t = _useTranslation.t,
      i18n = _useTranslation.i18n;

  var getOptions = function getOptions() {
    var options = data.map(function (option) {
      var group = option.group,
          value = option.value;
      return _extends({}, option, {
        group: group && t("licenseGroup:" + group)
      });
    });
    options.sort(function (a, b) {
      return a.groupId > b.groupId ? 1 : -1;
    });
    return options;
  };

  var emptyValue = multiple ? [] : "";
  var options = getOptions();

  var handleChange = function handleChange(event, option) {
    onChange && onChange(option && option.value || emptyValue, event);
  };

  var renderGroup = function renderGroup(option) {
    return /*#__PURE__*/React.createElement("p", null, JSON.stringify(option.group));
  };

  var renderOption = function renderOption(option, state) {
    return /*#__PURE__*/React.createElement(SelectLicenseFieldOption, option);
  };

  var selected = value && options.filter(function (option) {
    return option.value == value;
  });

  if (!multiple && selected.length) {
    selected = selected[0];
  }

  var classes = useStyles();
  return /*#__PURE__*/React.createElement(Autocomplete, (_React$createElement = {
    className: classes.root,
    id: id,
    placeholder: placeholder,
    multiple: multiple,
    options: options,
    groupBy: function groupBy(option) {
      return option.group;
    },
    label: label,
    helperText: helperText,
    value: selected,
    required: required,
    disabled: disabled || readonly,
    autoFocus: autofocus
  }, _React$createElement["groupBy"] = function groupBy(option) {
    return option.group;
  }, _React$createElement.getOptionLabel = function getOptionLabel(option) {
    return options && option.label || "";
  }, _React$createElement.renderOption = renderOption, _React$createElement.renderInput = function renderInput(params) {
    return /*#__PURE__*/React.createElement(TextField, _extends({}, params, {
      className: classes.input,
      variant: "filled",
      label: label,
      placeholder: placeholder,
      helperText: helperText
    }));
  }, _React$createElement.onChange = handleChange, _React$createElement));
};

SelectLicense.defaultProps = {
  autofocus: false
};
SelectLicense.propTypes = process.env.NODE_ENV !== "production" ? {
  id: PropTypes.string.isRequired,
  label: PropTypes.string,
  helperText: PropTypes.string,
  value: PropTypes.any,
  required: PropTypes.bool,
  disabled: PropTypes.bool,
  readonly: PropTypes.bool,
  multiple: PropTypes.bool,
  autofocus: PropTypes.bool,
  onChange: PropTypes.func,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func
} : {};
export default SelectLicense;