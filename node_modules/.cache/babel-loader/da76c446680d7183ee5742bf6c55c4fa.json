{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsdiffParser = void 0;\n\nconst assert = require(\"assert\");\n\nconst Token = require(\"token-types\");\n\nconst initDebug = require(\"debug\");\n\nconst FourCC_1 = require(\"../common/FourCC\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\n\nconst strtok3 = require(\"strtok3/lib/core\");\n\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n *  http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\n\nclass DsdiffParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n    assert.strictEqual(header.chunkID, 'FRM8');\n    const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n\n    switch (type) {\n      case 'DSD':\n        this.metadata.setFormat('container', `DSDIFF/${type}`);\n        this.metadata.setFormat('lossless', true);\n        return this.readFmt8Chunks(header.chunkSize - FourCC_1.FourCcToken.len);\n\n      default:\n        throw Error(`Unsupported DSDIFF type: ${type}`);\n    }\n  }\n\n  async readFmt8Chunks(remainingSize) {\n    while (remainingSize >= DsdiffToken_1.ChunkHeader.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader); //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n\n      debug(`Chunk id=${chunkHeader.chunkID}`);\n      await this.readData(chunkHeader);\n      remainingSize -= DsdiffToken_1.ChunkHeader.len + chunkHeader.chunkSize;\n    }\n  }\n\n  async readData(header) {\n    debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n    const p0 = this.tokenizer.position;\n\n    switch (header.chunkID.trim()) {\n      case 'FVER':\n        // 3.1 FORMAT VERSION CHUNK\n        const version = await this.tokenizer.readToken(Token.UINT32_LE);\n        debug(`DSDIFF version=${version}`);\n        break;\n\n      case 'PROP':\n        // 3.2 PROPERTY CHUNK\n        const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        assert.strictEqual(propType, 'SND ');\n        await this.handleSoundPropertyChunks(header.chunkSize - FourCC_1.FourCcToken.len);\n        break;\n\n      case 'ID3':\n        // Unofficial ID3 tag support\n        const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n        const rst = strtok3.fromBuffer(id3_data);\n        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n        break;\n\n      default:\n        debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        break;\n\n      case 'DSD':\n        this.metadata.setFormat('numberOfSamples', header.chunkSize * 8 / this.metadata.format.numberOfChannels);\n        this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        break;\n    }\n\n    const remaining = header.chunkSize - (this.tokenizer.position - p0);\n\n    if (remaining > 0) {\n      debug(`After Parsing chunk, remaining ${remaining} bytes`);\n      await this.tokenizer.ignore(remaining);\n    }\n  }\n\n  async handleSoundPropertyChunks(remainingSize) {\n    debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n\n    while (remainingSize > 0) {\n      const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n      debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n      const p0 = this.tokenizer.position;\n\n      switch (sndPropHeader.chunkID.trim()) {\n        case 'FS':\n          // 3.2.1 Sample Rate Chunk\n          const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n          this.metadata.setFormat('sampleRate', sampleRate);\n          break;\n\n        case 'CHNL':\n          // 3.2.2 Channels Chunk\n          const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n          this.metadata.setFormat('numberOfChannels', numChannels);\n          await this.handleChannelChunks(sndPropHeader.chunkSize - Token.UINT16_BE.len);\n          break;\n\n        case 'CMPR':\n          // 3.2.3 Compression Type Chunk\n          const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n          const count = await this.tokenizer.readToken(Token.UINT8);\n          const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n\n          if (compressionIdCode === 'DSD') {\n            this.metadata.setFormat('lossless', true);\n            this.metadata.setFormat('bitsPerSample', 1);\n          }\n\n          this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n          break;\n\n        case 'ABSS':\n          // 3.2.4 Absolute Start Time Chunk\n          const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n          const minutes = await this.tokenizer.readToken(Token.UINT8);\n          const seconds = await this.tokenizer.readToken(Token.UINT8);\n          const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n          debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n          break;\n\n        case 'LSCO':\n          // 3.2.5 Loudspeaker Configuration Chunk\n          const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n          debug(`LSCO lsConfig=${lsConfig}`);\n          break;\n\n        case 'COMT':\n        default:\n          debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n          await this.tokenizer.ignore(sndPropHeader.chunkSize);\n      }\n\n      const remaining = sndPropHeader.chunkSize - (this.tokenizer.position - p0);\n\n      if (remaining > 0) {\n        debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n        await this.tokenizer.ignore(remaining);\n      }\n\n      remainingSize -= DsdiffToken_1.ChunkHeader.len + sndPropHeader.chunkSize;\n      debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n    }\n\n    if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n      const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n      this.metadata.setFormat('bitrate', bitrate);\n    }\n  }\n\n  async handleChannelChunks(remainingSize) {\n    debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n    const channels = [];\n\n    while (remainingSize >= FourCC_1.FourCcToken.len) {\n      const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n      debug(`Channel[ID=${channelId}]`);\n      channels.push(channelId);\n      remainingSize -= FourCC_1.FourCcToken.len;\n    }\n\n    debug(`Channels: ${channels.join(', ')}`);\n    return channels;\n  }\n\n}\n\nexports.DsdiffParser = DsdiffParser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"],"names":["Object","defineProperty","exports","value","DsdiffParser","assert","require","Token","initDebug","FourCC_1","BasicParser_1","DsdiffToken_1","strtok3","ID3v2Parser_1","debug","BasicParser","parse","header","tokenizer","readToken","ChunkHeader","strictEqual","chunkID","type","FourCcToken","trim","metadata","setFormat","readFmt8Chunks","chunkSize","len","Error","remainingSize","chunkHeader","readData","p0","position","version","UINT32_LE","propType","handleSoundPropertyChunks","id3_data","BufferType","rst","fromBuffer","ID3v2Parser","options","format","numberOfChannels","numberOfSamples","sampleRate","remaining","ignore","sndPropHeader","UINT32_BE","numChannels","UINT16_BE","handleChannelChunks","compressionIdCode","count","UINT8","compressionName","StringType","hours","minutes","seconds","samples","lsConfig","lossless","bitsPerSample","bitrate","channels","channelId","push","join"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DsdiffParser = void 0;\nconst assert = require(\"assert\");\nconst Token = require(\"token-types\");\nconst initDebug = require(\"debug\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst DsdiffToken_1 = require(\"./DsdiffToken\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\n *\n * Ref:\n *  http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\n */\nclass DsdiffParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n        assert.strictEqual(header.chunkID, 'FRM8');\n        const type = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n        switch (type) {\n            case 'DSD':\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\n                this.metadata.setFormat('lossless', true);\n                return this.readFmt8Chunks(header.chunkSize - FourCC_1.FourCcToken.len);\n            default:\n                throw Error(`Unsupported DSDIFF type: ${type}`);\n        }\n    }\n    async readFmt8Chunks(remainingSize) {\n        while (remainingSize >= DsdiffToken_1.ChunkHeader.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n            debug(`Chunk id=${chunkHeader.chunkID}`);\n            await this.readData(chunkHeader);\n            remainingSize -= (DsdiffToken_1.ChunkHeader.len + chunkHeader.chunkSize);\n        }\n    }\n    async readData(header) {\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        const p0 = this.tokenizer.position;\n        switch (header.chunkID.trim()) {\n            case 'FVER': // 3.1 FORMAT VERSION CHUNK\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\n                debug(`DSDIFF version=${version}`);\n                break;\n            case 'PROP': // 3.2 PROPERTY CHUNK\n                const propType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n                assert.strictEqual(propType, 'SND ');\n                await this.handleSoundPropertyChunks(header.chunkSize - FourCC_1.FourCcToken.len);\n                break;\n            case 'ID3': // Unofficial ID3 tag support\n                const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                break;\n            default:\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n                break;\n            case 'DSD':\n                this.metadata.setFormat('numberOfSamples', header.chunkSize * 8 / this.metadata.format.numberOfChannels);\n                this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n                break;\n        }\n        const remaining = header.chunkSize - (this.tokenizer.position - p0);\n        if (remaining > 0) {\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\n            await this.tokenizer.ignore(remaining);\n        }\n    }\n    async handleSoundPropertyChunks(remainingSize) {\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        while (remainingSize > 0) {\n            const sndPropHeader = await this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n            const p0 = this.tokenizer.position;\n            switch (sndPropHeader.chunkID.trim()) {\n                case 'FS': // 3.2.1 Sample Rate Chunk\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n                    this.metadata.setFormat('sampleRate', sampleRate);\n                    break;\n                case 'CHNL': // 3.2.2 Channels Chunk\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n                    this.metadata.setFormat('numberOfChannels', numChannels);\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - Token.UINT16_BE.len);\n                    break;\n                case 'CMPR': // 3.2.3 Compression Type Chunk\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();\n                    const count = await this.tokenizer.readToken(Token.UINT8);\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n                    if (compressionIdCode === 'DSD') {\n                        this.metadata.setFormat('lossless', true);\n                        this.metadata.setFormat('bitsPerSample', 1);\n                    }\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n                    break;\n                case 'ABSS': // 3.2.4 Absolute Start Time Chunk\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n                    break;\n                case 'LSCO': // 3.2.5 Loudspeaker Configuration Chunk\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n                    debug(`LSCO lsConfig=${lsConfig}`);\n                    break;\n                case 'COMT':\n                default:\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n                    await this.tokenizer.ignore(sndPropHeader.chunkSize);\n            }\n            const remaining = sndPropHeader.chunkSize - (this.tokenizer.position - p0);\n            if (remaining > 0) {\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n                await this.tokenizer.ignore(remaining);\n            }\n            remainingSize -= DsdiffToken_1.ChunkHeader.len + sndPropHeader.chunkSize;\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n        }\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n            this.metadata.setFormat('bitrate', bitrate);\n        }\n    }\n    async handleChannelChunks(remainingSize) {\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n        const channels = [];\n        while (remainingSize >= FourCC_1.FourCcToken.len) {\n            const channelId = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n            debug(`Channel[ID=${channelId}]`);\n            channels.push(channelId);\n            remainingSize -= FourCC_1.FourCcToken.len;\n        }\n        debug(`Channels: ${channels.join(', ')}`);\n        return channels;\n    }\n}\nexports.DsdiffParser = DsdiffParser;\n//# sourceMappingURL=DsdiffParser.js.map"]},"metadata":{},"sourceType":"script"}