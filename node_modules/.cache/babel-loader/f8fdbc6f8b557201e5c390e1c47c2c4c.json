{"ast":null,"code":"import _Symbol$toPrimitive from \"@babel/runtime-corejs2/core-js/symbol/to-primitive\";\nimport _Set from \"@babel/runtime-corejs2/core-js/set\";\nimport _Array$from from \"@babel/runtime-corejs2/core-js/array/from\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _Number$isNaN from \"@babel/runtime-corejs2/core-js/number/is-nan\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _typeof from \"@babel/runtime-corejs2/helpers/esm/typeof\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[_Symbol$toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nimport React from \"react\";\nimport * as ReactIs from \"react-is\";\nimport mergeAllOf from \"json-schema-merge-allof\";\nimport fill from \"core-js/library/fn/array/fill\";\nimport validateFormData, { isValid } from \"./validate\";\nimport union from \"lodash/union\";\nimport jsonpointer from \"jsonpointer\";\nexport var ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nvar widgetMap = {\n  \"boolean\": {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\"\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\"\n  }\n};\nexport function canExpand(schema, uiSchema, formData) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n\n  var _getUiOptions = getUiOptions(uiSchema),\n      expandable = _getUiOptions.expandable;\n\n  if (expandable === false) {\n    return expandable;\n  } // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n\n\n  if (schema.maxProperties !== undefined) {\n    return _Object$keys(formData).length < schema.maxProperties;\n  }\n\n  return true;\n}\nexport function getDefaultRegistry() {\n  return {\n    fields: require(\"./components/fields\")[\"default\"],\n    widgets: require(\"./components/widgets\")[\"default\"],\n    definitions: {},\n    rootSchema: {},\n    formContext: {}\n  };\n}\n/* Gets the type of a given schema. */\n\nexport function getSchemaType(schema) {\n  var type = schema.type;\n\n  if (!type && schema[\"const\"]) {\n    return guessType(schema[\"const\"]);\n  }\n\n  if (!type && schema[\"enum\"]) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(function (type) {\n      return type !== \"null\";\n    });\n  }\n\n  return type;\n}\nexport function getWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};\n\n      Widget.MergedWidget = function (_ref) {\n        var _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            props = _objectWithoutProperties(_ref, [\"options\"]);\n\n        return React.createElement(Widget, _extends({\n          options: _objectSpread({}, defaultOptions, options)\n        }, props));\n      };\n    }\n\n    return Widget.MergedWidget;\n  }\n\n  if (typeof widget === \"function\" || ReactIs.isForwardRef(React.createElement(widget)) || ReactIs.isMemo(widget)) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(\"Unsupported widget definition: \".concat(_typeof(widget)));\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    var registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(\"No widget for type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, _registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(\"No widget \\\"\".concat(widget, \"\\\" for type \\\"\").concat(type, \"\\\"\"));\n}\nexport function hasWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (e.message && (e.message.startsWith(\"No widget\") || e.message.startsWith(\"Unsupported widget\"))) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n\nfunction computeDefaults(_schema, parentDefaults, rootSchema) {\n  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var schema = isObject(_schema) ? _schema : {};\n  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.\n\n  var defaults = parentDefaults;\n\n  if (isObject(defaults) && isObject(schema[\"default\"])) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema[\"default\"]);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema[\"default\"];\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (\"dependencies\" in schema) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map(function (itemSchema, idx) {\n      return computeDefaults(itemSchema, _Array$isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);\n    });\n  } else if (\"oneOf\" in schema) {\n    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in schema) {\n    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];\n  } // Not defaults defined for this node, fallback to generic typed ones.\n\n\n  if (typeof defaults === \"undefined\") {\n    defaults = schema[\"default\"];\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return _Object$keys(schema.properties || {}).reduce(function (acc, key) {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);\n\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n\n        return acc;\n      }, {});\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (_Array$isArray(defaults)) {\n        defaults = defaults.map(function (item, idx) {\n          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);\n        });\n      } // Deeply inject defaults into already existing form data\n\n\n      if (_Array$isArray(rawFormData)) {\n        defaults = rawFormData.map(function (item, idx) {\n          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);\n        });\n      }\n\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, rootSchema)) {\n          var defaultsLength = defaults ? defaults.length : 0;\n\n          if (schema.minItems > defaultsLength) {\n            var defaultEntries = defaults || []; // populate the array with the defaults\n\n            var fillerSchema = _Array$isArray(schema.items) ? schema.additionalItems : schema.items;\n            var fillerEntries = fill(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n\n  }\n\n  return defaults;\n}\n\nexport function getDefaultFormState(_schema, formData) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n\n  var schema = retrieveSchema(_schema, rootSchema, formData);\n  var defaults = computeDefaults(schema, _schema[\"default\"], rootSchema, formData, includeUndefinedValues);\n\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n\n  if (isObject(formData) || _Array$isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n\n  if (formData === 0 || formData === false || formData === \"\") {\n    return formData;\n  }\n\n  return formData || defaults;\n}\n/**\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n */\n\nexport function mergeDefaultsWithFormData(defaults, formData) {\n  if (_Array$isArray(formData)) {\n    if (!_Array$isArray(defaults)) {\n      defaults = [];\n    }\n\n    return formData.map(function (value, idx) {\n      if (defaults[idx]) {\n        return mergeDefaultsWithFormData(defaults[idx], value);\n      }\n\n      return value;\n    });\n  } else if (isObject(formData)) {\n    var acc = _extends({}, defaults); // Prevent mutation of source object.\n\n\n    return _Object$keys(formData).reduce(function (acc, key) {\n      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);\n      return acc;\n    }, acc);\n  } else {\n    return formData;\n  }\n}\nexport function getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return _Object$keys(uiSchema).filter(function (key) {\n    return key.indexOf(\"ui:\") === 0;\n  }).reduce(function (options, key) {\n    var value = uiSchema[key];\n\n    if (key === \"ui:widget\" && isObject(value)) {\n      console.warn(\"Setting options via ui:widget object is deprecated, use ui:options instead\");\n      return _objectSpread({}, options, value.options || {}, {\n        widget: value.component\n      });\n    }\n\n    if (key === \"ui:options\" && isObject(value)) {\n      return _objectSpread({}, options, value);\n    }\n\n    return _objectSpread({}, options, _defineProperty({}, key.substring(3), value));\n  }, {});\n}\nexport function getDisplayLabel(schema, uiSchema, rootSchema) {\n  var uiOptions = getUiOptions(uiSchema);\n  var _uiOptions$label = uiOptions.label,\n      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;\n\n  if (schema.type === \"array\") {\n    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema);\n  }\n\n  if (schema.type === \"object\") {\n    displayLabel = false;\n  }\n\n  if (schema.type === \"boolean\" && !uiSchema[\"ui:widget\"]) {\n    displayLabel = false;\n  }\n\n  if (uiSchema[\"ui:field\"]) {\n    displayLabel = false;\n  }\n\n  return displayLabel;\n}\nexport function isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n\n  return _typeof(thing) === \"object\" && thing !== null && !_Array$isArray(thing);\n}\nexport function mergeObjects(obj1, obj2) {\n  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // Recursively merge deeply nested objects.\n\n  var acc = _extends({}, obj1); // Prevent mutation of source object.\n\n\n  return _Object$keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && _Array$isArray(left) && _Array$isArray(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\nexport function asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  var n = Number(value);\n  var valid = typeof n === \"number\" && !_Number$isNaN(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\nexport function orderProperties(properties, order) {\n  if (!_Array$isArray(order)) {\n    return properties;\n  }\n\n  var arrayToHash = function arrayToHash(arr) {\n    return arr.reduce(function (prev, curr) {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  };\n\n  var errorPropList = function errorPropList(arr) {\n    return arr.length > 1 ? \"properties '\".concat(arr.join(\"', '\"), \"'\") : \"property '\".concat(arr[0], \"'\");\n  };\n\n  var propertyHash = arrayToHash(properties);\n  var orderFiltered = order.filter(function (prop) {\n    return prop === \"*\" || propertyHash[prop];\n  });\n  var orderHash = arrayToHash(orderFiltered);\n  var rest = properties.filter(function (prop) {\n    return !orderHash[prop];\n  });\n  var restIndex = orderFiltered.indexOf(\"*\");\n\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \".concat(errorPropList(rest)));\n    }\n\n    return orderFiltered;\n  }\n\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  var complete = _toConsumableArray(orderFiltered);\n\n  complete.splice.apply(complete, [restIndex, 1].concat(_toConsumableArray(rest)));\n  return complete;\n}\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\n\nexport function isConstant(schema) {\n  return _Array$isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1 || schema.hasOwnProperty(\"const\");\n}\nexport function toConstant(schema) {\n  if (_Array$isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1) {\n    return schema[\"enum\"][0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema[\"const\"];\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\nexport function isSelect(_schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var schema = retrieveSchema(_schema, rootSchema);\n  var altSchemas = schema.oneOf || schema.anyOf;\n\n  if (_Array$isArray(schema[\"enum\"])) {\n    return true;\n  } else if (_Array$isArray(altSchemas)) {\n    return altSchemas.every(function (altSchemas) {\n      return isConstant(altSchemas);\n    });\n  }\n\n  return false;\n}\nexport function isMultiSelect(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n\n  return isSelect(schema.items, rootSchema);\n}\nexport function isFilesArray(schema, uiSchema) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    var itemsSchema = retrieveSchema(schema.items, rootSchema);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n\n  return false;\n}\nexport function isFixedItems(schema) {\n  return _Array$isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {\n    return isObject(item);\n  });\n}\nexport function allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n\n  return isObject(schema.additionalItems);\n}\nexport function optionsList(schema) {\n  if (schema[\"enum\"]) {\n    return schema[\"enum\"].map(function (value, i) {\n      var label = schema.enumNames && schema.enumNames[i] || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  } else {\n    var altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map(function (schema, i) {\n      var value = toConstant(schema);\n      var label = schema.title || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  }\n}\nexport function findSchemaDefinition($ref) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var origRef = $ref;\n\n  if ($ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    $ref = decodeURIComponent($ref.substring(1));\n  } else {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  var current = jsonpointer.get(rootSchema, $ref);\n\n  if (current === undefined) {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  if (current.hasOwnProperty(\"$ref\")) {\n    return findSchemaDefinition(current.$ref, rootSchema);\n  }\n\n  return current;\n} // In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\n\nexport var guessType = function guessType(value) {\n  if (_Array$isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if (_typeof(value) === \"object\") {\n    return \"object\";\n  } // Default to string if we can't figure it out\n\n\n  return \"string\";\n}; // This function will create new \"properties\" items for each key in our formData\n\nexport function stubExistingAdditionalProperties(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Clone the schema so we don't ruin the consumer's original\n\n  schema = _objectSpread({}, schema, {\n    properties: _objectSpread({}, schema.properties)\n  });\n\n  _Object$keys(formData).forEach(function (key) {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    var additionalProperties;\n\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema({\n        $ref: schema.additionalProperties[\"$ref\"]\n      }, rootSchema, formData);\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = _objectSpread({}, schema.additionalProperties);\n    } else {\n      additionalProperties = {\n        type: guessType(formData[key])\n      };\n    } // The type of our new key should match the additionalProperties value;\n\n\n    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added\n\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n\n  return schema;\n}\nexport function resolveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return retrieveSchema(resolvedSchema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"allOf\")) {\n    return _objectSpread({}, schema, {\n      allOf: schema.allOf.map(function (allOfSubschema) {\n        return retrieveSchema(allOfSubschema, rootSchema, formData);\n      })\n    });\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, rootSchema, formData) {\n  // Retrieve the referenced schema definition.\n  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.\n\n  var $ref = schema.$ref,\n      localSchema = _objectWithoutProperties(schema, [\"$ref\"]); // Update referenced schema definition with local schema properties.\n\n\n  return retrieveSchema(_objectSpread({}, $refSchema, localSchema), rootSchema, formData);\n}\n\nexport function retrieveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isObject(schema)) {\n    return {};\n  }\n\n  var resolvedSchema = resolveSchema(schema, rootSchema, formData);\n\n  if (\"allOf\" in schema) {\n    try {\n      resolvedSchema = mergeAllOf(_objectSpread({}, resolvedSchema, {\n        allOf: resolvedSchema.allOf\n      }));\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n\n      var _resolvedSchema = resolvedSchema,\n          allOf = _resolvedSchema.allOf,\n          resolvedSchemaWithoutAllOf = _objectWithoutProperties(_resolvedSchema, [\"allOf\"]);\n\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n\n  var hasAdditionalProperties = resolvedSchema.hasOwnProperty(\"additionalProperties\") && resolvedSchema.additionalProperties !== false;\n\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, rootSchema, formData) {\n  // Drop the dependencies from the source schema.\n  var _schema$dependencies = schema.dependencies,\n      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,\n      resolvedSchema = _objectWithoutProperties(schema, [\"dependencies\"]);\n\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];\n  }\n\n  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);\n}\n\nfunction processDependencies(dependencies, resolvedSchema, rootSchema, formData) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (var dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n\n\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n\n    var dependencyValue = dependencies[dependencyKey],\n        remainingDependencies = _objectWithoutProperties(dependencies, [dependencyKey].map(_toPropertyKey));\n\n    if (_Array$isArray(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);\n    }\n\n    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n\n  var required = _Array$isArray(schema.required) ? _Array$from(new _Set([].concat(_toConsumableArray(schema.required), _toConsumableArray(additionallyRequired)))) : additionallyRequired;\n  return _objectSpread({}, schema, {\n    required: required\n  });\n}\n\nfunction withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {\n  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),\n      oneOf = _retrieveSchema.oneOf,\n      dependentSchema = _objectWithoutProperties(_retrieveSchema, [\"oneOf\"]);\n\n  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.\n\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!_Array$isArray(oneOf)) {\n    throw new Error(\"invalid: it is some \".concat(_typeof(oneOf), \" instead of an array\"));\n  } // Resolve $refs inside oneOf.\n\n\n  var resolvedOneOf = oneOf.map(function (subschema) {\n    return subschema.hasOwnProperty(\"$ref\") ? resolveReference(subschema, rootSchema, formData) : subschema;\n  });\n  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);\n}\n\nfunction withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {\n  var validSubschemas = oneOf.filter(function (subschema) {\n    if (!subschema.properties) {\n      return false;\n    }\n\n    var conditionPropertySchema = subschema.properties[dependencyKey];\n\n    if (conditionPropertySchema) {\n      var conditionSchema = {\n        type: \"object\",\n        properties: _defineProperty({}, dependencyKey, conditionPropertySchema)\n      };\n\n      var _validateFormData = validateFormData(formData, conditionSchema),\n          errors = _validateFormData.errors;\n\n      return errors.length === 0;\n    }\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n\n  var subschema = validSubschemas[0];\n\n  var _subschema$properties = subschema.properties,\n      conditionPropertySchema = _subschema$properties[dependencyKey],\n      dependentSubschema = _objectWithoutProperties(_subschema$properties, [dependencyKey].map(_toPropertyKey));\n\n  var dependentSchema = _objectSpread({}, subschema, {\n    properties: dependentSubschema\n  });\n\n  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));\n} // Recursively merge deeply nested schemas.\n// The difference between mergeSchemas and mergeObjects\n// is that mergeSchemas only concats arrays for\n// values under the \"required\" keyword, and when it does,\n// it doesn't include duplicate values.\n\n\nexport function mergeSchemas(obj1, obj2) {\n  var acc = _extends({}, obj1); // Prevent mutation of source object.\n\n\n  return _Object$keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (obj1 && obj2 && (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") && key === \"required\" && _Array$isArray(left) && _Array$isArray(right)) {\n      // Don't include duplicate values when merging\n      // \"required\" fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nexport function deepEquals(a, b) {\n  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n    return true;\n  } else if (_typeof(a) !== \"object\" || _typeof(b) !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n\n    var slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    var ka = _Object$keys(a);\n\n    var kb = _Object$keys(b); // don't bother with stack acrobatics if there's nothing there\n\n\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    var cal = ca.length;\n\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n\n    ca.push(a);\n    cb.push(b);\n    ka.sort();\n    kb.sort();\n\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    var key;\n\n    for (var k = ka.length - 1; k >= 0; k--) {\n      key = ka[k];\n\n      if (!deepEquals(a[key], b[key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n    return true;\n  }\n}\nexport function shouldRender(comp, nextProps, nextState) {\n  var props = comp.props,\n      state = comp.state;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\nexport function toIdSchema(schema, id, rootSchema) {\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"root\";\n  var idSchema = {\n    $id: id || idPrefix\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toIdSchema(_schema, id, rootSchema, formData, idPrefix);\n  }\n\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix);\n  }\n\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n\n  for (var name in schema.properties || {}) {\n    var field = schema.properties[name];\n    var fieldId = idSchema.$id + \"_\" + name;\n    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an\n    // array item has just been added, but not populated with data yet\n    (formData || {})[name], idPrefix);\n  }\n\n  return idSchema;\n}\nexport function toPathSchema(schema) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var rootSchema = arguments.length > 2 ? arguments[2] : undefined;\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var pathSchema = {\n    $name: name.replace(/^\\./, \"\")\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toPathSchema(_schema, name, rootSchema, formData);\n  }\n\n  if (schema.hasOwnProperty(\"additionalProperties\")) {\n    pathSchema.__rjsf_additionalProperties = true;\n  }\n\n  if (schema.hasOwnProperty(\"items\") && _Array$isArray(formData)) {\n    formData.forEach(function (element, i) {\n      pathSchema[i] = toPathSchema(schema.items, \"\".concat(name, \".\").concat(i), rootSchema, element);\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (var property in schema.properties) {\n      pathSchema[property] = toPathSchema(schema.properties[property], \"\".concat(name, \".\").concat(property), rootSchema, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[property]);\n    }\n  }\n\n  return pathSchema;\n}\nexport function parseDateString(dateString) {\n  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0\n    };\n  }\n\n  var date = new Date(dateString);\n\n  if (_Number$isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1,\n    // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0\n  };\n}\nexport function toDateString(_ref2) {\n  var year = _ref2.year,\n      month = _ref2.month,\n      day = _ref2.day,\n      _ref2$hour = _ref2.hour,\n      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,\n      _ref2$minute = _ref2.minute,\n      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,\n      _ref2$second = _ref2.second,\n      second = _ref2$second === void 0 ? 0 : _ref2$second;\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  var datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\nexport function utcToLocal(jsonDate) {\n  if (!jsonDate) {\n    return \"\";\n  } // required format of `\"yyyy-MM-ddThh:mm\" followed by optional \":ss\" or \":ss.SSS\"\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n\n\n  var date = new Date(jsonDate);\n  var yyyy = pad(date.getFullYear(), 4);\n  var MM = pad(date.getMonth() + 1, 2);\n  var dd = pad(date.getDate(), 2);\n  var hh = pad(date.getHours(), 2);\n  var mm = pad(date.getMinutes(), 2);\n  var ss = pad(date.getSeconds(), 2);\n  var SSS = pad(date.getMilliseconds(), 3);\n  return \"\".concat(yyyy, \"-\").concat(MM, \"-\").concat(dd, \"T\").concat(hh, \":\").concat(mm, \":\").concat(ss, \".\").concat(SSS);\n}\nexport function localToUTC(dateString) {\n  if (dateString) {\n    return new Date(dateString).toJSON();\n  }\n}\nexport function pad(num, size) {\n  var s = String(num);\n\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n\n  return s;\n}\nexport function dataURItoBlob(dataURI) {\n  // Split metadata from data\n  var splitted = dataURI.split(\",\"); // Split params\n\n  var params = splitted[0].split(\";\"); // Get mime-type from params\n\n  var type = params[0].replace(\"data:\", \"\"); // Filter the name property from params\n\n  var properties = params.filter(function (param) {\n    return param.split(\"=\")[0] === \"name\";\n  }); // Look for the name and use unknown if no name property.\n\n  var name;\n\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  } // Built the Uint8Array Blob parameter from the base64 string.\n\n\n  var binary = atob(splitted[1]);\n  var array = [];\n\n  for (var i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  } // Create the blob object\n\n\n  var blob = new window.Blob([new Uint8Array(array)], {\n    type: type\n  });\n  return {\n    blob: blob,\n    name: name\n  };\n}\nexport function rangeSpec(schema) {\n  var spec = {};\n\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n\n  return spec;\n}\nexport function getMatchingOption(formData, options, rootSchema) {\n  for (var i = 0; i < options.length; i++) {\n    var option = options[i]; // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      var requiresAnyOf = {\n        anyOf: _Object$keys(option.properties).map(function (key) {\n          return {\n            required: [key]\n          };\n        })\n      };\n      var augmentedSchema = void 0; // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        var shallowClone = _extends({}, option);\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = _extends({}, option, requiresAnyOf);\n      } // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n\n\n      delete augmentedSchema.required;\n\n      if (isValid(augmentedSchema, formData)) {\n        return i;\n      }\n    } else if (isValid(options[i], formData)) {\n      return i;\n    }\n  }\n\n  return 0;\n} // Check to see if a schema specifies that a value must be true\n\nexport function schemaRequiresTrueValue(schema) {\n  // Check if const is a truthy value\n  if (schema[\"const\"]) {\n    return true;\n  } // Check if an enum has a single value of true\n\n\n  if (schema[\"enum\"] && schema[\"enum\"].length === 1 && schema[\"enum\"][0] === true) {\n    return true;\n  } // If anyOf has a single value, evaluate the subschema\n\n\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0]);\n  } // If oneOf has a single value, evaluate the subschema\n\n\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0]);\n  } // Evaluate each subschema in allOf, to see if one of them requires a true\n  // value\n\n\n  if (schema.allOf) {\n    return schema.allOf.some(schemaRequiresTrueValue);\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/@rjsf/core/dist/es/utils.js"],"names":["_Symbol$toPrimitive","_Set","_Array$from","_toConsumableArray","_Number$isNaN","_defineProperty","_Array$isArray","_typeof","_extends","_objectSpread","_objectWithoutProperties","_Object$keys","_toPropertyKey","arg","key","_toPrimitive","String","input","hint","prim","undefined","res","call","TypeError","Number","React","ReactIs","mergeAllOf","fill","validateFormData","isValid","union","jsonpointer","ADDITIONAL_PROPERTY_FLAG","widgetMap","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","color","file","number","updown","range","integer","array","checkboxes","files","canExpand","schema","uiSchema","formData","additionalProperties","_getUiOptions","getUiOptions","expandable","maxProperties","length","getDefaultRegistry","fields","require","widgets","definitions","rootSchema","formContext","getSchemaType","type","guessType","properties","Array","includes","find","getWidget","widget","registeredWidgets","arguments","mergeOptions","Widget","MergedWidget","defaultOptions","defaultProps","options","_ref","_ref$options","props","createElement","isForwardRef","isMemo","Error","concat","hasOwnProperty","registeredWidget","_registeredWidget","hasWidget","e","message","startsWith","computeDefaults","_schema","parentDefaults","rawFormData","includeUndefinedValues","isObject","defaults","mergeObjects","refSchema","findSchemaDefinition","$ref","resolvedSchema","resolveDependencies","isFixedItems","items","map","itemSchema","idx","oneOf","getMatchingOption","anyOf","reduce","acc","computedDefault","item","additionalItems","minItems","isMultiSelect","defaultsLength","defaultEntries","fillerSchema","fillerEntries","getDefaultFormState","retrieveSchema","mergeDefaultsWithFormData","value","filter","indexOf","console","warn","component","substring","getDisplayLabel","uiOptions","_uiOptions$label","label","displayLabel","isFilesArray","thing","File","obj1","obj2","concatArrays","left","right","asNumber","test","n","valid","orderProperties","order","arrayToHash","arr","prev","curr","errorPropList","join","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","lastIndexOf","complete","splice","apply","isConstant","toConstant","isSelect","altSchemas","every","uniqueItems","itemsSchema","format","allowAdditionalItems","optionsList","i","enumNames","title","origRef","decodeURIComponent","current","get","isNaN","stubExistingAdditionalProperties","forEach","resolveSchema","resolveReference","allOf","allOfSubschema","$refSchema","localSchema","_resolvedSchema","resolvedSchemaWithoutAllOf","hasAdditionalProperties","_schema$dependencies","dependencies","processDependencies","dependencyKey","dependencyValue","remainingDependencies","withDependentProperties","withDependentSchema","additionallyRequired","required","_retrieveSchema","dependentSchema","mergeSchemas","resolvedOneOf","subschema","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","conditionSchema","_validateFormData","errors","_subschema$properties","dependentSubschema","isArguments","object","Object","prototype","toString","deepEquals","a","b","ca","cb","Date","getTime","RegExp","source","global","multiline","lastIndex","ignoreCase","slice","constructor","ka","kb","cal","push","sort","j","k","pop","shouldRender","comp","nextProps","nextState","state","toIdSchema","id","idPrefix","idSchema","$id","name","field","fieldId","toPathSchema","pathSchema","$name","replace","__rjsf_additionalProperties","element","property","parseDateString","dateString","includeTime","year","month","day","hour","minute","second","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","toDateString","_ref2","_ref2$hour","_ref2$minute","_ref2$second","time","utcTime","UTC","toJSON","utcToLocal","jsonDate","yyyy","pad","getFullYear","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds","localToUTC","num","size","s","dataURItoBlob","dataURI","splitted","split","params","param","binary","atob","charCodeAt","blob","window","Blob","Uint8Array","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","option","requiresAnyOf","augmentedSchema","shallowClone","schemaRequiresTrueValue","some"],"mappings":"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","sourcesContent":["import _Symbol$toPrimitive from \"@babel/runtime-corejs2/core-js/symbol/to-primitive\";\nimport _Set from \"@babel/runtime-corejs2/core-js/set\";\nimport _Array$from from \"@babel/runtime-corejs2/core-js/array/from\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _Number$isNaN from \"@babel/runtime-corejs2/core-js/number/is-nan\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _typeof from \"@babel/runtime-corejs2/helpers/esm/typeof\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[_Symbol$toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nimport React from \"react\";\nimport * as ReactIs from \"react-is\";\nimport mergeAllOf from \"json-schema-merge-allof\";\nimport fill from \"core-js/library/fn/array/fill\";\nimport validateFormData, { isValid } from \"./validate\";\nimport union from \"lodash/union\";\nimport jsonpointer from \"jsonpointer\";\nexport var ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nvar widgetMap = {\n  \"boolean\": {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\"\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\"\n  }\n};\nexport function canExpand(schema, uiSchema, formData) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n\n  var _getUiOptions = getUiOptions(uiSchema),\n      expandable = _getUiOptions.expandable;\n\n  if (expandable === false) {\n    return expandable;\n  } // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n\n\n  if (schema.maxProperties !== undefined) {\n    return _Object$keys(formData).length < schema.maxProperties;\n  }\n\n  return true;\n}\nexport function getDefaultRegistry() {\n  return {\n    fields: require(\"./components/fields\")[\"default\"],\n    widgets: require(\"./components/widgets\")[\"default\"],\n    definitions: {},\n    rootSchema: {},\n    formContext: {}\n  };\n}\n/* Gets the type of a given schema. */\n\nexport function getSchemaType(schema) {\n  var type = schema.type;\n\n  if (!type && schema[\"const\"]) {\n    return guessType(schema[\"const\"]);\n  }\n\n  if (!type && schema[\"enum\"]) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(function (type) {\n      return type !== \"null\";\n    });\n  }\n\n  return type;\n}\nexport function getWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};\n\n      Widget.MergedWidget = function (_ref) {\n        var _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            props = _objectWithoutProperties(_ref, [\"options\"]);\n\n        return React.createElement(Widget, _extends({\n          options: _objectSpread({}, defaultOptions, options)\n        }, props));\n      };\n    }\n\n    return Widget.MergedWidget;\n  }\n\n  if (typeof widget === \"function\" || ReactIs.isForwardRef(React.createElement(widget)) || ReactIs.isMemo(widget)) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(\"Unsupported widget definition: \".concat(_typeof(widget)));\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    var registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(\"No widget for type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, _registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(\"No widget \\\"\".concat(widget, \"\\\" for type \\\"\").concat(type, \"\\\"\"));\n}\nexport function hasWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (e.message && (e.message.startsWith(\"No widget\") || e.message.startsWith(\"Unsupported widget\"))) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n\nfunction computeDefaults(_schema, parentDefaults, rootSchema) {\n  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var schema = isObject(_schema) ? _schema : {};\n  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.\n\n  var defaults = parentDefaults;\n\n  if (isObject(defaults) && isObject(schema[\"default\"])) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema[\"default\"]);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema[\"default\"];\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (\"dependencies\" in schema) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map(function (itemSchema, idx) {\n      return computeDefaults(itemSchema, _Array$isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);\n    });\n  } else if (\"oneOf\" in schema) {\n    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in schema) {\n    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];\n  } // Not defaults defined for this node, fallback to generic typed ones.\n\n\n  if (typeof defaults === \"undefined\") {\n    defaults = schema[\"default\"];\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return _Object$keys(schema.properties || {}).reduce(function (acc, key) {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);\n\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n\n        return acc;\n      }, {});\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (_Array$isArray(defaults)) {\n        defaults = defaults.map(function (item, idx) {\n          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);\n        });\n      } // Deeply inject defaults into already existing form data\n\n\n      if (_Array$isArray(rawFormData)) {\n        defaults = rawFormData.map(function (item, idx) {\n          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);\n        });\n      }\n\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, rootSchema)) {\n          var defaultsLength = defaults ? defaults.length : 0;\n\n          if (schema.minItems > defaultsLength) {\n            var defaultEntries = defaults || []; // populate the array with the defaults\n\n            var fillerSchema = _Array$isArray(schema.items) ? schema.additionalItems : schema.items;\n            var fillerEntries = fill(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n\n  }\n\n  return defaults;\n}\n\nexport function getDefaultFormState(_schema, formData) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n\n  var schema = retrieveSchema(_schema, rootSchema, formData);\n  var defaults = computeDefaults(schema, _schema[\"default\"], rootSchema, formData, includeUndefinedValues);\n\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n\n  if (isObject(formData) || _Array$isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n\n  if (formData === 0 || formData === false || formData === \"\") {\n    return formData;\n  }\n\n  return formData || defaults;\n}\n/**\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n */\n\nexport function mergeDefaultsWithFormData(defaults, formData) {\n  if (_Array$isArray(formData)) {\n    if (!_Array$isArray(defaults)) {\n      defaults = [];\n    }\n\n    return formData.map(function (value, idx) {\n      if (defaults[idx]) {\n        return mergeDefaultsWithFormData(defaults[idx], value);\n      }\n\n      return value;\n    });\n  } else if (isObject(formData)) {\n    var acc = _extends({}, defaults); // Prevent mutation of source object.\n\n\n    return _Object$keys(formData).reduce(function (acc, key) {\n      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);\n      return acc;\n    }, acc);\n  } else {\n    return formData;\n  }\n}\nexport function getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return _Object$keys(uiSchema).filter(function (key) {\n    return key.indexOf(\"ui:\") === 0;\n  }).reduce(function (options, key) {\n    var value = uiSchema[key];\n\n    if (key === \"ui:widget\" && isObject(value)) {\n      console.warn(\"Setting options via ui:widget object is deprecated, use ui:options instead\");\n      return _objectSpread({}, options, value.options || {}, {\n        widget: value.component\n      });\n    }\n\n    if (key === \"ui:options\" && isObject(value)) {\n      return _objectSpread({}, options, value);\n    }\n\n    return _objectSpread({}, options, _defineProperty({}, key.substring(3), value));\n  }, {});\n}\nexport function getDisplayLabel(schema, uiSchema, rootSchema) {\n  var uiOptions = getUiOptions(uiSchema);\n  var _uiOptions$label = uiOptions.label,\n      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;\n\n  if (schema.type === \"array\") {\n    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema);\n  }\n\n  if (schema.type === \"object\") {\n    displayLabel = false;\n  }\n\n  if (schema.type === \"boolean\" && !uiSchema[\"ui:widget\"]) {\n    displayLabel = false;\n  }\n\n  if (uiSchema[\"ui:field\"]) {\n    displayLabel = false;\n  }\n\n  return displayLabel;\n}\nexport function isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n\n  return _typeof(thing) === \"object\" && thing !== null && !_Array$isArray(thing);\n}\nexport function mergeObjects(obj1, obj2) {\n  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  // Recursively merge deeply nested objects.\n  var acc = _extends({}, obj1); // Prevent mutation of source object.\n\n\n  return _Object$keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && _Array$isArray(left) && _Array$isArray(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\nexport function asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  var n = Number(value);\n  var valid = typeof n === \"number\" && !_Number$isNaN(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\nexport function orderProperties(properties, order) {\n  if (!_Array$isArray(order)) {\n    return properties;\n  }\n\n  var arrayToHash = function arrayToHash(arr) {\n    return arr.reduce(function (prev, curr) {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  };\n\n  var errorPropList = function errorPropList(arr) {\n    return arr.length > 1 ? \"properties '\".concat(arr.join(\"', '\"), \"'\") : \"property '\".concat(arr[0], \"'\");\n  };\n\n  var propertyHash = arrayToHash(properties);\n  var orderFiltered = order.filter(function (prop) {\n    return prop === \"*\" || propertyHash[prop];\n  });\n  var orderHash = arrayToHash(orderFiltered);\n  var rest = properties.filter(function (prop) {\n    return !orderHash[prop];\n  });\n  var restIndex = orderFiltered.indexOf(\"*\");\n\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \".concat(errorPropList(rest)));\n    }\n\n    return orderFiltered;\n  }\n\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  var complete = _toConsumableArray(orderFiltered);\n\n  complete.splice.apply(complete, [restIndex, 1].concat(_toConsumableArray(rest)));\n  return complete;\n}\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\n\nexport function isConstant(schema) {\n  return _Array$isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1 || schema.hasOwnProperty(\"const\");\n}\nexport function toConstant(schema) {\n  if (_Array$isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1) {\n    return schema[\"enum\"][0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema[\"const\"];\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\nexport function isSelect(_schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var schema = retrieveSchema(_schema, rootSchema);\n  var altSchemas = schema.oneOf || schema.anyOf;\n\n  if (_Array$isArray(schema[\"enum\"])) {\n    return true;\n  } else if (_Array$isArray(altSchemas)) {\n    return altSchemas.every(function (altSchemas) {\n      return isConstant(altSchemas);\n    });\n  }\n\n  return false;\n}\nexport function isMultiSelect(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n\n  return isSelect(schema.items, rootSchema);\n}\nexport function isFilesArray(schema, uiSchema) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    var itemsSchema = retrieveSchema(schema.items, rootSchema);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n\n  return false;\n}\nexport function isFixedItems(schema) {\n  return _Array$isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {\n    return isObject(item);\n  });\n}\nexport function allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n\n  return isObject(schema.additionalItems);\n}\nexport function optionsList(schema) {\n  if (schema[\"enum\"]) {\n    return schema[\"enum\"].map(function (value, i) {\n      var label = schema.enumNames && schema.enumNames[i] || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  } else {\n    var altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map(function (schema, i) {\n      var value = toConstant(schema);\n      var label = schema.title || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  }\n}\nexport function findSchemaDefinition($ref) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var origRef = $ref;\n\n  if ($ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    $ref = decodeURIComponent($ref.substring(1));\n  } else {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  var current = jsonpointer.get(rootSchema, $ref);\n\n  if (current === undefined) {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  if (current.hasOwnProperty(\"$ref\")) {\n    return findSchemaDefinition(current.$ref, rootSchema);\n  }\n\n  return current;\n} // In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\n\nexport var guessType = function guessType(value) {\n  if (_Array$isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if (_typeof(value) === \"object\") {\n    return \"object\";\n  } // Default to string if we can't figure it out\n\n\n  return \"string\";\n}; // This function will create new \"properties\" items for each key in our formData\n\nexport function stubExistingAdditionalProperties(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Clone the schema so we don't ruin the consumer's original\n  schema = _objectSpread({}, schema, {\n    properties: _objectSpread({}, schema.properties)\n  });\n\n  _Object$keys(formData).forEach(function (key) {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    var additionalProperties;\n\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema({\n        $ref: schema.additionalProperties[\"$ref\"]\n      }, rootSchema, formData);\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = _objectSpread({}, schema.additionalProperties);\n    } else {\n      additionalProperties = {\n        type: guessType(formData[key])\n      };\n    } // The type of our new key should match the additionalProperties value;\n\n\n    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added\n\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n\n  return schema;\n}\nexport function resolveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return retrieveSchema(resolvedSchema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"allOf\")) {\n    return _objectSpread({}, schema, {\n      allOf: schema.allOf.map(function (allOfSubschema) {\n        return retrieveSchema(allOfSubschema, rootSchema, formData);\n      })\n    });\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, rootSchema, formData) {\n  // Retrieve the referenced schema definition.\n  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.\n\n  var $ref = schema.$ref,\n      localSchema = _objectWithoutProperties(schema, [\"$ref\"]); // Update referenced schema definition with local schema properties.\n\n\n  return retrieveSchema(_objectSpread({}, $refSchema, localSchema), rootSchema, formData);\n}\n\nexport function retrieveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isObject(schema)) {\n    return {};\n  }\n\n  var resolvedSchema = resolveSchema(schema, rootSchema, formData);\n\n  if (\"allOf\" in schema) {\n    try {\n      resolvedSchema = mergeAllOf(_objectSpread({}, resolvedSchema, {\n        allOf: resolvedSchema.allOf\n      }));\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n\n      var _resolvedSchema = resolvedSchema,\n          allOf = _resolvedSchema.allOf,\n          resolvedSchemaWithoutAllOf = _objectWithoutProperties(_resolvedSchema, [\"allOf\"]);\n\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n\n  var hasAdditionalProperties = resolvedSchema.hasOwnProperty(\"additionalProperties\") && resolvedSchema.additionalProperties !== false;\n\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, rootSchema, formData) {\n  // Drop the dependencies from the source schema.\n  var _schema$dependencies = schema.dependencies,\n      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,\n      resolvedSchema = _objectWithoutProperties(schema, [\"dependencies\"]);\n\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];\n  }\n\n  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);\n}\n\nfunction processDependencies(dependencies, resolvedSchema, rootSchema, formData) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (var dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n\n\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n\n    var dependencyValue = dependencies[dependencyKey],\n        remainingDependencies = _objectWithoutProperties(dependencies, [dependencyKey].map(_toPropertyKey));\n\n    if (_Array$isArray(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);\n    }\n\n    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n\n  var required = _Array$isArray(schema.required) ? _Array$from(new _Set([].concat(_toConsumableArray(schema.required), _toConsumableArray(additionallyRequired)))) : additionallyRequired;\n  return _objectSpread({}, schema, {\n    required: required\n  });\n}\n\nfunction withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {\n  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),\n      oneOf = _retrieveSchema.oneOf,\n      dependentSchema = _objectWithoutProperties(_retrieveSchema, [\"oneOf\"]);\n\n  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.\n\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!_Array$isArray(oneOf)) {\n    throw new Error(\"invalid: it is some \".concat(_typeof(oneOf), \" instead of an array\"));\n  } // Resolve $refs inside oneOf.\n\n\n  var resolvedOneOf = oneOf.map(function (subschema) {\n    return subschema.hasOwnProperty(\"$ref\") ? resolveReference(subschema, rootSchema, formData) : subschema;\n  });\n  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);\n}\n\nfunction withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {\n  var validSubschemas = oneOf.filter(function (subschema) {\n    if (!subschema.properties) {\n      return false;\n    }\n\n    var conditionPropertySchema = subschema.properties[dependencyKey];\n\n    if (conditionPropertySchema) {\n      var conditionSchema = {\n        type: \"object\",\n        properties: _defineProperty({}, dependencyKey, conditionPropertySchema)\n      };\n\n      var _validateFormData = validateFormData(formData, conditionSchema),\n          errors = _validateFormData.errors;\n\n      return errors.length === 0;\n    }\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n\n  var subschema = validSubschemas[0];\n\n  var _subschema$properties = subschema.properties,\n      conditionPropertySchema = _subschema$properties[dependencyKey],\n      dependentSubschema = _objectWithoutProperties(_subschema$properties, [dependencyKey].map(_toPropertyKey));\n\n  var dependentSchema = _objectSpread({}, subschema, {\n    properties: dependentSubschema\n  });\n\n  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));\n} // Recursively merge deeply nested schemas.\n// The difference between mergeSchemas and mergeObjects\n// is that mergeSchemas only concats arrays for\n// values under the \"required\" keyword, and when it does,\n// it doesn't include duplicate values.\n\n\nexport function mergeSchemas(obj1, obj2) {\n  var acc = _extends({}, obj1); // Prevent mutation of source object.\n\n\n  return _Object$keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (obj1 && obj2 && (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") && key === \"required\" && _Array$isArray(left) && _Array$isArray(right)) {\n      // Don't include duplicate values when merging\n      // \"required\" fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nexport function deepEquals(a, b) {\n  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n    return true;\n  } else if (_typeof(a) !== \"object\" || _typeof(b) !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n\n    var slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    var ka = _Object$keys(a);\n\n    var kb = _Object$keys(b); // don't bother with stack acrobatics if there's nothing there\n\n\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    var cal = ca.length;\n\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n\n    ca.push(a);\n    cb.push(b);\n    ka.sort();\n    kb.sort();\n\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    var key;\n\n    for (var k = ka.length - 1; k >= 0; k--) {\n      key = ka[k];\n\n      if (!deepEquals(a[key], b[key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n    return true;\n  }\n}\nexport function shouldRender(comp, nextProps, nextState) {\n  var props = comp.props,\n      state = comp.state;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\nexport function toIdSchema(schema, id, rootSchema) {\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"root\";\n  var idSchema = {\n    $id: id || idPrefix\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toIdSchema(_schema, id, rootSchema, formData, idPrefix);\n  }\n\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix);\n  }\n\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n\n  for (var name in schema.properties || {}) {\n    var field = schema.properties[name];\n    var fieldId = idSchema.$id + \"_\" + name;\n    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an\n    // array item has just been added, but not populated with data yet\n    (formData || {})[name], idPrefix);\n  }\n\n  return idSchema;\n}\nexport function toPathSchema(schema) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var rootSchema = arguments.length > 2 ? arguments[2] : undefined;\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var pathSchema = {\n    $name: name.replace(/^\\./, \"\")\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toPathSchema(_schema, name, rootSchema, formData);\n  }\n\n  if (schema.hasOwnProperty(\"additionalProperties\")) {\n    pathSchema.__rjsf_additionalProperties = true;\n  }\n\n  if (schema.hasOwnProperty(\"items\") && _Array$isArray(formData)) {\n    formData.forEach(function (element, i) {\n      pathSchema[i] = toPathSchema(schema.items, \"\".concat(name, \".\").concat(i), rootSchema, element);\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (var property in schema.properties) {\n      pathSchema[property] = toPathSchema(schema.properties[property], \"\".concat(name, \".\").concat(property), rootSchema, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[property]);\n    }\n  }\n\n  return pathSchema;\n}\nexport function parseDateString(dateString) {\n  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0\n    };\n  }\n\n  var date = new Date(dateString);\n\n  if (_Number$isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1,\n    // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0\n  };\n}\nexport function toDateString(_ref2) {\n  var year = _ref2.year,\n      month = _ref2.month,\n      day = _ref2.day,\n      _ref2$hour = _ref2.hour,\n      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,\n      _ref2$minute = _ref2.minute,\n      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,\n      _ref2$second = _ref2.second,\n      second = _ref2$second === void 0 ? 0 : _ref2$second;\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  var datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\nexport function utcToLocal(jsonDate) {\n  if (!jsonDate) {\n    return \"\";\n  } // required format of `\"yyyy-MM-ddThh:mm\" followed by optional \":ss\" or \":ss.SSS\"\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n\n\n  var date = new Date(jsonDate);\n  var yyyy = pad(date.getFullYear(), 4);\n  var MM = pad(date.getMonth() + 1, 2);\n  var dd = pad(date.getDate(), 2);\n  var hh = pad(date.getHours(), 2);\n  var mm = pad(date.getMinutes(), 2);\n  var ss = pad(date.getSeconds(), 2);\n  var SSS = pad(date.getMilliseconds(), 3);\n  return \"\".concat(yyyy, \"-\").concat(MM, \"-\").concat(dd, \"T\").concat(hh, \":\").concat(mm, \":\").concat(ss, \".\").concat(SSS);\n}\nexport function localToUTC(dateString) {\n  if (dateString) {\n    return new Date(dateString).toJSON();\n  }\n}\nexport function pad(num, size) {\n  var s = String(num);\n\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n\n  return s;\n}\nexport function dataURItoBlob(dataURI) {\n  // Split metadata from data\n  var splitted = dataURI.split(\",\"); // Split params\n\n  var params = splitted[0].split(\";\"); // Get mime-type from params\n\n  var type = params[0].replace(\"data:\", \"\"); // Filter the name property from params\n\n  var properties = params.filter(function (param) {\n    return param.split(\"=\")[0] === \"name\";\n  }); // Look for the name and use unknown if no name property.\n\n  var name;\n\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  } // Built the Uint8Array Blob parameter from the base64 string.\n\n\n  var binary = atob(splitted[1]);\n  var array = [];\n\n  for (var i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  } // Create the blob object\n\n\n  var blob = new window.Blob([new Uint8Array(array)], {\n    type: type\n  });\n  return {\n    blob: blob,\n    name: name\n  };\n}\nexport function rangeSpec(schema) {\n  var spec = {};\n\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n\n  return spec;\n}\nexport function getMatchingOption(formData, options, rootSchema) {\n  for (var i = 0; i < options.length; i++) {\n    var option = options[i]; // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      var requiresAnyOf = {\n        anyOf: _Object$keys(option.properties).map(function (key) {\n          return {\n            required: [key]\n          };\n        })\n      };\n      var augmentedSchema = void 0; // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        var shallowClone = _extends({}, option);\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = _extends({}, option, requiresAnyOf);\n      } // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n\n\n      delete augmentedSchema.required;\n\n      if (isValid(augmentedSchema, formData)) {\n        return i;\n      }\n    } else if (isValid(options[i], formData)) {\n      return i;\n    }\n  }\n\n  return 0;\n} // Check to see if a schema specifies that a value must be true\n\nexport function schemaRequiresTrueValue(schema) {\n  // Check if const is a truthy value\n  if (schema[\"const\"]) {\n    return true;\n  } // Check if an enum has a single value of true\n\n\n  if (schema[\"enum\"] && schema[\"enum\"].length === 1 && schema[\"enum\"][0] === true) {\n    return true;\n  } // If anyOf has a single value, evaluate the subschema\n\n\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0]);\n  } // If oneOf has a single value, evaluate the subschema\n\n\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0]);\n  } // Evaluate each subschema in allOf, to see if one of them requires a true\n  // value\n\n\n  if (schema.allOf) {\n    return schema.allOf.some(schemaRequiresTrueValue);\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"module"}