{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinArtists = exports.MetadataCollector = void 0;\n\nconst type_1 = require(\"../type\");\n\nconst _debug = require(\"debug\");\n\nconst GenericTagTypes_1 = require(\"./GenericTagTypes\");\n\nconst CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\n\nconst GenericTagMapper_1 = require(\"./GenericTagMapper\");\n\nconst Util_1 = require(\"./Util\");\n\nconst FileType = require(\"file-type/core\");\n\nconst debug = _debug('music-metadata:collector');\n\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'ID3v1'];\n/**\n * Provided to the parser to uodate the metadata result.\n * Responsible for triggering async updates\n */\n\nclass MetadataCollector {\n  constructor(opts) {\n    this.opts = opts;\n    this.format = {\n      tagTypes: [],\n      trackInfo: []\n    };\n    this.native = {};\n    this.common = {\n      track: {\n        no: null,\n        of: null\n      },\n      disk: {\n        no: null,\n        of: null\n      },\n      movementIndex: {}\n    };\n    this.quality = {\n      warnings: []\n    };\n    /**\n     * Keeps track of origin priority for each mapped id\n     */\n\n    this.commonOrigin = {};\n    /**\n     * Maps a tag type to a priority\n     */\n\n    this.originPriority = {};\n    this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n    let priority = 1;\n\n    for (const tagType of TagPriority) {\n      this.originPriority[tagType] = priority++;\n    }\n\n    this.originPriority.artificial = 500; // Filled using alternative tags\n\n    this.originPriority.id3v1 = 600; // Consider worst due to field length limit\n  }\n  /**\n   * @returns {boolean} true if one or more tags have been found\n   */\n\n\n  hasAny() {\n    return Object.keys(this.native).length > 0;\n  }\n\n  addStreamInfo(streamInfo) {\n    debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\n    this.format.trackInfo.push(streamInfo);\n  }\n\n  setFormat(key, value) {\n    debug(`format: ${key} = ${value}`);\n    this.format[key] = value; // as any to override readonly\n\n    if (this.opts.observer) {\n      this.opts.observer({\n        metadata: this,\n        tag: {\n          type: 'format',\n          id: key,\n          value\n        }\n      });\n    }\n  }\n\n  addTag(tagType, tagId, value) {\n    debug(`tag ${tagType}.${tagId} = ${value}`);\n\n    if (!this.native[tagType]) {\n      this.format.tagTypes.push(tagType);\n      this.native[tagType] = [];\n    }\n\n    this.native[tagType].push({\n      id: tagId,\n      value\n    });\n    this.toCommon(tagType, tagId, value);\n  }\n\n  addWarning(warning) {\n    this.quality.warnings.push({\n      message: warning\n    });\n  }\n\n  postMap(tagType, tag) {\n    // Common tag (alias) found\n    // check if we need to do something special with common tag\n    // if the event has been aliased then we need to clean it before\n    // it is emitted to the user. e.g. genre (20) -> Electronic\n    switch (tag.id) {\n      case 'artist':\n        if (this.commonOrigin.artist === this.originPriority[tagType]) {\n          // Assume the artist field is used as artists\n          return this.postMap('artificial', {\n            id: 'artists',\n            value: tag.value\n          });\n        }\n\n        if (!this.common.artists) {\n          // Fill artists using artist source\n          this.setGenericTag('artificial', {\n            id: 'artists',\n            value: tag.value\n          });\n        }\n\n        break;\n\n      case 'artists':\n        if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n          if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n            // Fill artist using artists source\n            const artists = (this.common.artists || []).concat([tag.value]);\n            const value = joinArtists(artists);\n            const artistTag = {\n              id: 'artist',\n              value\n            };\n            this.setGenericTag('artificial', artistTag);\n          }\n        }\n\n        break;\n\n      case 'genre':\n        tag.value = GenericTagMapper_1.CommonTagMapper.parseGenre(tag.value);\n        break;\n\n      case 'picture':\n        this.postFixPicture(tag.value).then(picture => {\n          if (picture !== null) {\n            tag.value = picture;\n            this.setGenericTag(tagType, tag);\n          }\n        });\n        return;\n\n      case 'totaltracks':\n        this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n\n      case 'totaldiscs':\n        this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n\n      case 'movementTotal':\n        this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n        return;\n\n      case 'track':\n      case 'disk':\n      case 'movementIndex':\n        const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n\n        this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n        this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n        return;\n\n      case 'year':\n      case 'originalyear':\n        tag.value = parseInt(tag.value, 10);\n        break;\n\n      case 'date':\n        // ToDo: be more strict on 'YYYY...'\n        const year = parseInt(tag.value.substr(0, 4), 10);\n\n        if (!isNaN(year)) {\n          this.common.year = year;\n        }\n\n        break;\n\n      case 'discogs_label_id':\n      case 'discogs_release_id':\n      case 'discogs_master_release_id':\n      case 'discogs_artist_id':\n      case 'discogs_votes':\n        tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n        break;\n\n      case 'replaygain_track_gain':\n      case 'replaygain_track_peak':\n      case 'replaygain_album_gain':\n      case 'replaygain_album_peak':\n        tag.value = Util_1.toRatio(tag.value);\n        break;\n\n      case 'replaygain_track_minmax':\n        tag.value = tag.value.split(',').map(v => parseInt(v, 10));\n        break;\n\n      case 'replaygain_undo':\n        const minMix = tag.value.split(',').map(v => parseInt(v, 10));\n        tag.value = {\n          leftChannel: minMix[0],\n          rightChannel: minMix[1]\n        };\n        break;\n\n      case 'gapless': // iTunes gap-less flag\n\n      case 'compilation':\n      case 'podcast':\n      case 'showMovement':\n        tag.value = tag.value === '1' || tag.value === 1; // boolean\n\n        break;\n\n      case 'isrc':\n        // Only keep unique values\n        if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1) return;\n        break;\n\n      default: // nothing to do\n\n    }\n\n    if (tag.value !== null) {\n      this.setGenericTag(tagType, tag);\n    }\n  }\n  /**\n   * Convert native tags to common tags\n   * @returns {IAudioMetadata} Native + common tags\n   */\n\n\n  toCommonMetadata() {\n    return {\n      format: this.format,\n      native: this.native,\n      quality: this.quality,\n      common: this.common\n    };\n  }\n  /**\n   * Fix some common issues with picture object\n   * @param pictureType\n   */\n\n\n  async postFixPicture(picture) {\n    if (picture.data.length > 0) {\n      if (!picture.format) {\n        const fileType = await FileType.fromBuffer(picture.data);\n\n        if (fileType) {\n          picture.format = fileType.mime;\n        } else {\n          return null;\n        }\n      }\n\n      picture.format = picture.format.toLocaleLowerCase();\n\n      switch (picture.format) {\n        case 'image/jpg':\n          picture.format = 'image/jpeg';\n        // ToDo: register warning\n      }\n\n      return picture;\n    }\n\n    this.addWarning(`Empty picture tag found`);\n    return null;\n  }\n  /**\n   * Convert native tag to common tags\n   */\n\n\n  toCommon(tagType, tagId, value) {\n    const tag = {\n      id: tagId,\n      value\n    };\n    const genericTag = this.tagMapper.mapTag(tagType, tag, this);\n\n    if (genericTag) {\n      this.postMap(tagType, genericTag);\n    }\n  }\n  /**\n   * Set generic tag\n   */\n\n\n  setGenericTag(tagType, tag) {\n    debug(`common.${tag.id} = ${tag.value}`);\n    const prio0 = this.commonOrigin[tag.id] || 1000;\n    const prio1 = this.originPriority[tagType];\n\n    if (GenericTagTypes_1.isSingleton(tag.id)) {\n      if (prio1 <= prio0) {\n        this.common[tag.id] = tag.value;\n        this.commonOrigin[tag.id] = prio1;\n      } else {\n        return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\n      }\n    } else {\n      if (prio1 === prio0) {\n        if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n          this.common[tag.id].push(tag.value);\n        } else {\n          debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\n        } // no effect? this.commonOrigin[tag.id] = prio1;\n\n      } else if (prio1 < prio0) {\n        this.common[tag.id] = [tag.value];\n        this.commonOrigin[tag.id] = prio1;\n      } else {\n        return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\n      }\n    }\n\n    if (this.opts.observer) {\n      this.opts.observer({\n        metadata: this,\n        tag: {\n          type: 'common',\n          id: tag.id,\n          value: tag.value\n        }\n      });\n    } // ToDo: trigger metadata event\n\n  }\n\n}\n\nexports.MetadataCollector = MetadataCollector;\n\nfunction joinArtists(artists) {\n  if (artists.length > 2) {\n    return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n  }\n\n  return artists.join(' & ');\n}\n\nexports.joinArtists = joinArtists;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/common/MetadataCollector.js"],"names":["Object","defineProperty","exports","value","joinArtists","MetadataCollector","type_1","require","_debug","GenericTagTypes_1","CombinedTagMapper_1","GenericTagMapper_1","Util_1","FileType","debug","TagPriority","constructor","opts","format","tagTypes","trackInfo","native","common","track","no","of","disk","movementIndex","quality","warnings","commonOrigin","originPriority","tagMapper","CombinedTagMapper","priority","tagType","artificial","id3v1","hasAny","keys","length","addStreamInfo","streamInfo","TrackType","type","codecName","push","setFormat","key","observer","metadata","tag","id","addTag","tagId","toCommon","addWarning","warning","message","postMap","artist","artists","setGenericTag","indexOf","concat","artistTag","CommonTagMapper","parseGenre","postFixPicture","then","picture","toIntOrNull","normalizeTrack","parseInt","year","substr","isNaN","toRatio","split","map","v","minMix","leftChannel","rightChannel","toCommonMetadata","data","fileType","fromBuffer","mime","toLocaleLowerCase","genericTag","mapTag","prio0","prio1","isSingleton","isUnique","slice","join"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.joinArtists = exports.MetadataCollector = void 0;\nconst type_1 = require(\"../type\");\nconst _debug = require(\"debug\");\nconst GenericTagTypes_1 = require(\"./GenericTagTypes\");\nconst CombinedTagMapper_1 = require(\"./CombinedTagMapper\");\nconst GenericTagMapper_1 = require(\"./GenericTagMapper\");\nconst Util_1 = require(\"./Util\");\nconst FileType = require(\"file-type/core\");\nconst debug = _debug('music-metadata:collector');\nconst TagPriority = ['matroska', 'APEv2', 'vorbis', 'ID3v2.4', 'ID3v2.3', 'ID3v2.2', 'exif', 'asf', 'iTunes', 'ID3v1'];\n/**\n * Provided to the parser to uodate the metadata result.\n * Responsible for triggering async updates\n */\nclass MetadataCollector {\n    constructor(opts) {\n        this.opts = opts;\n        this.format = {\n            tagTypes: [],\n            trackInfo: []\n        };\n        this.native = {};\n        this.common = {\n            track: { no: null, of: null },\n            disk: { no: null, of: null },\n            movementIndex: {}\n        };\n        this.quality = {\n            warnings: []\n        };\n        /**\n         * Keeps track of origin priority for each mapped id\n         */\n        this.commonOrigin = {};\n        /**\n         * Maps a tag type to a priority\n         */\n        this.originPriority = {};\n        this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();\n        let priority = 1;\n        for (const tagType of TagPriority) {\n            this.originPriority[tagType] = priority++;\n        }\n        this.originPriority.artificial = 500; // Filled using alternative tags\n        this.originPriority.id3v1 = 600; // Consider worst due to field length limit\n    }\n    /**\n     * @returns {boolean} true if one or more tags have been found\n     */\n    hasAny() {\n        return Object.keys(this.native).length > 0;\n    }\n    addStreamInfo(streamInfo) {\n        debug(`streamInfo: type=${type_1.TrackType[streamInfo.type]}, codec=${streamInfo.codecName}`);\n        this.format.trackInfo.push(streamInfo);\n    }\n    setFormat(key, value) {\n        debug(`format: ${key} = ${value}`);\n        this.format[key] = value; // as any to override readonly\n        if (this.opts.observer) {\n            this.opts.observer({ metadata: this, tag: { type: 'format', id: key, value } });\n        }\n    }\n    addTag(tagType, tagId, value) {\n        debug(`tag ${tagType}.${tagId} = ${value}`);\n        if (!this.native[tagType]) {\n            this.format.tagTypes.push(tagType);\n            this.native[tagType] = [];\n        }\n        this.native[tagType].push({ id: tagId, value });\n        this.toCommon(tagType, tagId, value);\n    }\n    addWarning(warning) {\n        this.quality.warnings.push({ message: warning });\n    }\n    postMap(tagType, tag) {\n        // Common tag (alias) found\n        // check if we need to do something special with common tag\n        // if the event has been aliased then we need to clean it before\n        // it is emitted to the user. e.g. genre (20) -> Electronic\n        switch (tag.id) {\n            case 'artist':\n                if (this.commonOrigin.artist === this.originPriority[tagType]) {\n                    // Assume the artist field is used as artists\n                    return this.postMap('artificial', { id: 'artists', value: tag.value });\n                }\n                if (!this.common.artists) {\n                    // Fill artists using artist source\n                    this.setGenericTag('artificial', { id: 'artists', value: tag.value });\n                }\n                break;\n            case 'artists':\n                if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {\n                    if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {\n                        // Fill artist using artists source\n                        const artists = (this.common.artists || []).concat([tag.value]);\n                        const value = joinArtists(artists);\n                        const artistTag = { id: 'artist', value };\n                        this.setGenericTag('artificial', artistTag);\n                    }\n                }\n                break;\n            case 'genre':\n                tag.value = GenericTagMapper_1.CommonTagMapper.parseGenre(tag.value);\n                break;\n            case 'picture':\n                this.postFixPicture(tag.value).then(picture => {\n                    if (picture !== null) {\n                        tag.value = picture;\n                        this.setGenericTag(tagType, tag);\n                    }\n                });\n                return;\n            case 'totaltracks':\n                this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'totaldiscs':\n                this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'movementTotal':\n                this.common.movementIndex.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);\n                return;\n            case 'track':\n            case 'disk':\n            case 'movementIndex':\n                const of = this.common[tag.id].of; // store of value, maybe maybe overwritten\n                this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);\n                this.common[tag.id].of = of != null ? of : this.common[tag.id].of;\n                return;\n            case 'year':\n            case 'originalyear':\n                tag.value = parseInt(tag.value, 10);\n                break;\n            case 'date':\n                // ToDo: be more strict on 'YYYY...'\n                const year = parseInt(tag.value.substr(0, 4), 10);\n                if (!isNaN(year)) {\n                    this.common.year = year;\n                }\n                break;\n            case 'discogs_label_id':\n            case 'discogs_release_id':\n            case 'discogs_master_release_id':\n            case 'discogs_artist_id':\n            case 'discogs_votes':\n                tag.value = typeof tag.value === 'string' ? parseInt(tag.value, 10) : tag.value;\n                break;\n            case 'replaygain_track_gain':\n            case 'replaygain_track_peak':\n            case 'replaygain_album_gain':\n            case 'replaygain_album_peak':\n                tag.value = Util_1.toRatio(tag.value);\n                break;\n            case 'replaygain_track_minmax':\n                tag.value = tag.value.split(',').map(v => parseInt(v, 10));\n                break;\n            case 'replaygain_undo':\n                const minMix = tag.value.split(',').map(v => parseInt(v, 10));\n                tag.value = {\n                    leftChannel: minMix[0],\n                    rightChannel: minMix[1]\n                };\n                break;\n            case 'gapless': // iTunes gap-less flag\n            case 'compilation':\n            case 'podcast':\n            case 'showMovement':\n                tag.value = tag.value === '1' || tag.value === 1; // boolean\n                break;\n            case 'isrc': // Only keep unique values\n                if (this.common[tag.id] && this.common[tag.id].indexOf(tag.value) !== -1)\n                    return;\n                break;\n            default:\n            // nothing to do\n        }\n        if (tag.value !== null) {\n            this.setGenericTag(tagType, tag);\n        }\n    }\n    /**\n     * Convert native tags to common tags\n     * @returns {IAudioMetadata} Native + common tags\n     */\n    toCommonMetadata() {\n        return {\n            format: this.format,\n            native: this.native,\n            quality: this.quality,\n            common: this.common\n        };\n    }\n    /**\n     * Fix some common issues with picture object\n     * @param pictureType\n     */\n    async postFixPicture(picture) {\n        if (picture.data.length > 0) {\n            if (!picture.format) {\n                const fileType = await FileType.fromBuffer(picture.data);\n                if (fileType) {\n                    picture.format = fileType.mime;\n                }\n                else {\n                    return null;\n                }\n            }\n            picture.format = picture.format.toLocaleLowerCase();\n            switch (picture.format) {\n                case 'image/jpg':\n                    picture.format = 'image/jpeg'; // ToDo: register warning\n            }\n            return picture;\n        }\n        this.addWarning(`Empty picture tag found`);\n        return null;\n    }\n    /**\n     * Convert native tag to common tags\n     */\n    toCommon(tagType, tagId, value) {\n        const tag = { id: tagId, value };\n        const genericTag = this.tagMapper.mapTag(tagType, tag, this);\n        if (genericTag) {\n            this.postMap(tagType, genericTag);\n        }\n    }\n    /**\n     * Set generic tag\n     */\n    setGenericTag(tagType, tag) {\n        debug(`common.${tag.id} = ${tag.value}`);\n        const prio0 = this.commonOrigin[tag.id] || 1000;\n        const prio1 = this.originPriority[tagType];\n        if (GenericTagTypes_1.isSingleton(tag.id)) {\n            if (prio1 <= prio0) {\n                this.common[tag.id] = tag.value;\n                this.commonOrigin[tag.id] = prio1;\n            }\n            else {\n                return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);\n            }\n        }\n        else {\n            if (prio1 === prio0) {\n                if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {\n                    this.common[tag.id].push(tag.value);\n                }\n                else {\n                    debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);\n                }\n                // no effect? this.commonOrigin[tag.id] = prio1;\n            }\n            else if (prio1 < prio0) {\n                this.common[tag.id] = [tag.value];\n                this.commonOrigin[tag.id] = prio1;\n            }\n            else {\n                return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);\n            }\n        }\n        if (this.opts.observer) {\n            this.opts.observer({ metadata: this, tag: { type: 'common', id: tag.id, value: tag.value } });\n        }\n        // ToDo: trigger metadata event\n    }\n}\nexports.MetadataCollector = MetadataCollector;\nfunction joinArtists(artists) {\n    if (artists.length > 2) {\n        return artists.slice(0, artists.length - 1).join(', ') + ' & ' + artists[artists.length - 1];\n    }\n    return artists.join(' & ');\n}\nexports.joinArtists = joinArtists;\n//# sourceMappingURL=MetadataCollector.js.map"]},"metadata":{},"sourceType":"script"}