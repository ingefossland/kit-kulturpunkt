{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MatroskaParser = void 0;\n\nconst Token = require(\"token-types\");\n\nconst _debug = require(\"debug\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst types_1 = require(\"./types\");\n\nconst matroskaDtd = require(\"./MatroskaDtd\");\n\nconst debug = _debug('music-metadata:parser:matroska');\n/**\n * Extensible Binary Meta Language (EBML) parser\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\n *\n * WEBM VP8 AUDIO FILE\n */\n\n\nclass MatroskaParser extends BasicParser_1.BasicParser {\n  constructor() {\n    super();\n    this.padding = 0;\n    this.parserMap = new Map();\n    this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\n    this.parserMap.set(types_1.DataType.string, e => this.readString(e));\n    this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\n    this.parserMap.set(types_1.DataType.uid, async e => (await this.readUint(e)) === 1);\n    this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\n    this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\n  }\n  /**\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n   * @param {INativeMetadataCollector} metadata Output\n   * @param {ITokenizer} tokenizer Input\n   * @param {IOptions} options Parsing options\n   */\n\n\n  init(metadata, tokenizer, options) {\n    super.init(metadata, tokenizer, options);\n    return this;\n  }\n\n  async parse() {\n    const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n    this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\n\n    if (matroska.segment) {\n      const info = matroska.segment.info;\n\n      if (info) {\n        const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n        const duration = info.duration * timecodeScale / 1000000000;\n        this.addTag('segment:title', info.title);\n        this.metadata.setFormat('duration', duration);\n      }\n\n      const audioTracks = matroska.segment.tracks;\n\n      if (audioTracks && audioTracks.entries) {\n        audioTracks.entries.forEach(entry => {\n          const stream = {\n            codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n            codecSettings: entry.codecSettings,\n            flagDefault: entry.flagDefault,\n            flagLacing: entry.flagLacing,\n            flagEnabled: entry.flagEnabled,\n            language: entry.language,\n            name: entry.name,\n            type: entry.trackType,\n            audio: entry.audio,\n            video: entry.video\n          };\n          this.metadata.addStreamInfo(stream);\n        });\n        const audioTrack = audioTracks.entries.filter(entry => {\n          return entry.trackType === types_1.TrackType.audio.valueOf();\n        }).reduce((acc, cur) => {\n          if (!acc) {\n            return cur;\n          }\n\n          if (!acc.flagDefault && cur.flagDefault) {\n            return cur;\n          }\n\n          if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n            return cur;\n          }\n\n          return acc;\n        }, null);\n\n        if (audioTrack) {\n          this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n          this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n          this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n        }\n\n        if (matroska.segment.tags) {\n          matroska.segment.tags.tag.forEach(tag => {\n            const target = tag.target;\n            const targetType = target.targetTypeValue ? types_1.TargetType[target.targetTypeValue] : target.targetType ? target.targetType : types_1.TargetType.album;\n            tag.simpleTags.forEach(simpleTag => {\n              const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n              this.addTag(`${targetType}:${simpleTag.name}`, value);\n            });\n          });\n        }\n\n        if (matroska.segment.attachments) {\n          matroska.segment.attachments.attachedFiles.filter(file => file.mimeType.startsWith('image/')).map(file => {\n            return {\n              data: file.data,\n              format: file.mimeType,\n              description: file.description,\n              name: file.name\n            };\n          }).forEach(picture => {\n            this.addTag('picture', picture);\n          });\n        }\n      }\n    }\n  }\n\n  async parseContainer(container, posDone, path) {\n    const tree = {};\n\n    while (this.tokenizer.position < posDone) {\n      const element = await this.readElement();\n      const type = container[element.id];\n\n      if (type) {\n        if (type.container) {\n          const res = await this.parseContainer(type.container, this.tokenizer.position + element.len, path.concat([type.name]));\n\n          if (type.multiple) {\n            if (!tree[type.name]) {\n              tree[type.name] = [];\n            }\n\n            tree[type.name].push(res);\n          } else {\n            tree[type.name] = res;\n          }\n        } else {\n          tree[type.name] = await this.parserMap.get(type.value)(element);\n        }\n      } else {\n        switch (element.id) {\n          case 0xec:\n            // void\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n            break;\n\n          default:\n            debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n        }\n      }\n    }\n\n    return tree;\n  }\n\n  async readVintData() {\n    const msb = await this.tokenizer.peekNumber(Token.UINT8);\n    let mask = 0x80;\n    let ic = 1; // Calculate VINT_WIDTH\n\n    while ((msb & mask) === 0) {\n      ++ic;\n      mask >>= 1;\n    }\n\n    const id = Buffer.alloc(ic);\n    await this.tokenizer.readBuffer(id);\n    return id;\n  }\n\n  async readElement() {\n    const id = await this.readVintData();\n    const lenField = await this.readVintData();\n    lenField[0] ^= 0x80 >> lenField.length - 1;\n    const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n\n    return {\n      id: id.readUIntBE(0, id.length),\n      len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n    };\n  }\n\n  async readFloat(e) {\n    switch (e.len) {\n      case 0:\n        return 0.0;\n\n      case 4:\n        return this.tokenizer.readNumber(Token.Float32_BE);\n\n      case 8:\n        return this.tokenizer.readNumber(Token.Float64_BE);\n\n      case 10:\n        return this.tokenizer.readNumber(Token.Float64_BE);\n\n      default:\n        throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\n    }\n  }\n\n  async readFlag(e) {\n    return (await this.readUint(e)) === 1;\n  }\n\n  async readUint(e) {\n    const buf = await this.readBuffer(e);\n    const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n\n    return buf.readUIntBE(e.len - nrLen, nrLen);\n  }\n\n  async readString(e) {\n    return this.tokenizer.readToken(new Token.StringType(e.len, 'utf-8'));\n  }\n\n  async readBuffer(e) {\n    const buf = Buffer.alloc(e.len);\n    await this.tokenizer.readBuffer(buf);\n    return buf;\n  }\n\n  addTag(tagId, value) {\n    this.metadata.addTag('matroska', tagId, value);\n  }\n\n}\n\nexports.MatroskaParser = MatroskaParser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/matroska/MatroskaParser.js"],"names":["Object","defineProperty","exports","value","MatroskaParser","Token","require","_debug","BasicParser_1","types_1","matroskaDtd","debug","BasicParser","constructor","padding","parserMap","Map","set","DataType","uint","e","readUint","string","readString","binary","readBuffer","uid","bool","readFlag","float","readFloat","init","metadata","tokenizer","options","parse","matroska","parseContainer","elements","fileInfo","size","setFormat","ebml","docType","segment","info","timecodeScale","duration","addTag","title","audioTracks","tracks","entries","forEach","entry","stream","codecName","codecID","replace","codecSettings","flagDefault","flagLacing","flagEnabled","language","name","type","trackType","audio","video","addStreamInfo","audioTrack","filter","TrackType","valueOf","reduce","acc","cur","trackNumber","samplingFrequency","channels","tags","tag","target","targetType","targetTypeValue","TargetType","album","simpleTags","simpleTag","attachments","attachedFiles","file","mimeType","startsWith","map","data","format","description","picture","container","posDone","path","tree","position","element","readElement","id","res","len","concat","multiple","push","get","ignore","join","toString","readVintData","msb","peekNumber","UINT8","mask","ic","Buffer","alloc","lenField","length","nrLen","Math","min","readUIntBE","readNumber","Float32_BE","Float64_BE","Error","buf","readToken","StringType","tagId"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MatroskaParser = void 0;\nconst Token = require(\"token-types\");\nconst _debug = require(\"debug\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst types_1 = require(\"./types\");\nconst matroskaDtd = require(\"./MatroskaDtd\");\nconst debug = _debug('music-metadata:parser:matroska');\n/**\n * Extensible Binary Meta Language (EBML) parser\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\n *\n * WEBM VP8 AUDIO FILE\n */\nclass MatroskaParser extends BasicParser_1.BasicParser {\n    constructor() {\n        super();\n        this.padding = 0;\n        this.parserMap = new Map();\n        this.parserMap.set(types_1.DataType.uint, e => this.readUint(e));\n        this.parserMap.set(types_1.DataType.string, e => this.readString(e));\n        this.parserMap.set(types_1.DataType.binary, e => this.readBuffer(e));\n        this.parserMap.set(types_1.DataType.uid, async (e) => await this.readUint(e) === 1);\n        this.parserMap.set(types_1.DataType.bool, e => this.readFlag(e));\n        this.parserMap.set(types_1.DataType.float, e => this.readFloat(e));\n    }\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        super.init(metadata, tokenizer, options);\n        return this;\n    }\n    async parse() {\n        const matroska = await this.parseContainer(matroskaDtd.elements, this.tokenizer.fileInfo.size, []);\n        this.metadata.setFormat('container', `EBML/${matroska.ebml.docType}`);\n        if (matroska.segment) {\n            const info = matroska.segment.info;\n            if (info) {\n                const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n                const duration = info.duration * timecodeScale / 1000000000;\n                this.addTag('segment:title', info.title);\n                this.metadata.setFormat('duration', duration);\n            }\n            const audioTracks = matroska.segment.tracks;\n            if (audioTracks && audioTracks.entries) {\n                audioTracks.entries.forEach(entry => {\n                    const stream = {\n                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n                        codecSettings: entry.codecSettings,\n                        flagDefault: entry.flagDefault,\n                        flagLacing: entry.flagLacing,\n                        flagEnabled: entry.flagEnabled,\n                        language: entry.language,\n                        name: entry.name,\n                        type: entry.trackType,\n                        audio: entry.audio,\n                        video: entry.video\n                    };\n                    this.metadata.addStreamInfo(stream);\n                });\n                const audioTrack = audioTracks.entries\n                    .filter(entry => {\n                    return entry.trackType === types_1.TrackType.audio.valueOf();\n                })\n                    .reduce((acc, cur) => {\n                    if (!acc) {\n                        return cur;\n                    }\n                    if (!acc.flagDefault && cur.flagDefault) {\n                        return cur;\n                    }\n                    if (cur.trackNumber && cur.trackNumber < acc.trackNumber) {\n                        return cur;\n                    }\n                    return acc;\n                }, null);\n                if (audioTrack) {\n                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n                }\n                if (matroska.segment.tags) {\n                    matroska.segment.tags.tag.forEach(tag => {\n                        const target = tag.target;\n                        const targetType = target.targetTypeValue ? types_1.TargetType[target.targetTypeValue] : (target.targetType ? target.targetType : types_1.TargetType.album);\n                        tag.simpleTags.forEach(simpleTag => {\n                            const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n                            this.addTag(`${targetType}:${simpleTag.name}`, value);\n                        });\n                    });\n                }\n                if (matroska.segment.attachments) {\n                    matroska.segment.attachments.attachedFiles\n                        .filter(file => file.mimeType.startsWith('image/'))\n                        .map(file => {\n                        return {\n                            data: file.data,\n                            format: file.mimeType,\n                            description: file.description,\n                            name: file.name\n                        };\n                    }).forEach(picture => {\n                        this.addTag('picture', picture);\n                    });\n                }\n            }\n        }\n    }\n    async parseContainer(container, posDone, path) {\n        const tree = {};\n        while (this.tokenizer.position < posDone) {\n            const element = await this.readElement();\n            const type = container[element.id];\n            if (type) {\n                if (type.container) {\n                    const res = await this.parseContainer(type.container, this.tokenizer.position + element.len, path.concat([type.name]));\n                    if (type.multiple) {\n                        if (!tree[type.name]) {\n                            tree[type.name] = [];\n                        }\n                        tree[type.name].push(res);\n                    }\n                    else {\n                        tree[type.name] = res;\n                    }\n                }\n                else {\n                    tree[type.name] = await this.parserMap.get(type.value)(element);\n                }\n            }\n            else {\n                switch (element.id) {\n                    case 0xec: // void\n                        this.padding += element.len;\n                        await this.tokenizer.ignore(element.len);\n                        break;\n                    default:\n                        debug(`parseEbml: path=${path.join('/')}, unknown element: id=${element.id.toString(16)}`);\n                        this.padding += element.len;\n                        await this.tokenizer.ignore(element.len);\n                }\n            }\n        }\n        return tree;\n    }\n    async readVintData() {\n        const msb = await this.tokenizer.peekNumber(Token.UINT8);\n        let mask = 0x80;\n        let ic = 1;\n        // Calculate VINT_WIDTH\n        while ((msb & mask) === 0) {\n            ++ic;\n            mask >>= 1;\n        }\n        const id = Buffer.alloc(ic);\n        await this.tokenizer.readBuffer(id);\n        return id;\n    }\n    async readElement() {\n        const id = await this.readVintData();\n        const lenField = await this.readVintData();\n        lenField[0] ^= 0x80 >> (lenField.length - 1);\n        const nrLen = Math.min(6, lenField.length); // JavaScript can max read 6 bytes integer\n        return {\n            id: id.readUIntBE(0, id.length),\n            len: lenField.readUIntBE(lenField.length - nrLen, nrLen)\n        };\n    }\n    async readFloat(e) {\n        switch (e.len) {\n            case 0:\n                return 0.0;\n            case 4:\n                return this.tokenizer.readNumber(Token.Float32_BE);\n            case 8:\n                return this.tokenizer.readNumber(Token.Float64_BE);\n            case 10:\n                return this.tokenizer.readNumber(Token.Float64_BE);\n            default:\n                throw new Error(`Invalid IEEE-754 float length: ${e.len}`);\n        }\n    }\n    async readFlag(e) {\n        return (await this.readUint(e)) === 1;\n    }\n    async readUint(e) {\n        const buf = await this.readBuffer(e);\n        const nrLen = Math.min(6, e.len); // JavaScript can max read 6 bytes integer\n        return buf.readUIntBE(e.len - nrLen, nrLen);\n    }\n    async readString(e) {\n        return this.tokenizer.readToken(new Token.StringType(e.len, 'utf-8'));\n    }\n    async readBuffer(e) {\n        const buf = Buffer.alloc(e.len);\n        await this.tokenizer.readBuffer(buf);\n        return buf;\n    }\n    addTag(tagId, value) {\n        this.metadata.addTag('matroska', tagId, value);\n    }\n}\nexports.MatroskaParser = MatroskaParser;\n//# sourceMappingURL=MatroskaParser.js.map"]},"metadata":{},"sourceType":"script"}