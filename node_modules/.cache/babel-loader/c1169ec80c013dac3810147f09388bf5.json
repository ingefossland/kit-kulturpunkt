{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MpegParser = void 0;\n\nconst assert = require(\"assert\");\n\nconst Token = require(\"token-types\");\n\nconst core_1 = require(\"strtok3/lib/core\");\n\nconst initDebug = require(\"debug\");\n\nconst Util_1 = require(\"../common/Util\");\n\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\n\nconst XingTag_1 = require(\"./XingTag\");\n\nconst debug = initDebug('music-metadata:parser:mpeg');\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\n\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\n\nconst MPEG4 = {\n  /**\n   * Audio Object Types\n   */\n  AudioObjectTypes: ['AAC Main', 'AAC LC', 'AAC SSR', 'AAC LTP' // Long Term Prediction\n  ],\n\n  /**\n   * Sampling Frequencies\n   * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n   */\n  SamplingFrequencies: [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1]\n  /**\n   * Channel Configurations\n   */\n\n};\nconst MPEG4_ChannelConfigurations = [undefined, ['front-center'], ['front-left', 'front-right'], ['front-center', 'front-left', 'front-right'], ['front-center', 'front-left', 'front-right', 'back-center'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'], ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\n\nclass MpegFrameHeader {\n  constructor(buf, off) {\n    // B(20,19): MPEG Audio versionIndex ID\n    this.versionIndex = Util_1.default.getBitAllignedNumber(buf, off + 1, 3, 2); // C(18,17): Layer description\n\n    this.layer = MpegFrameHeader.LayerDescription[Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];\n\n    if (this.versionIndex > 1 && this.layer === 0) {\n      this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n    } else {\n      this.parseMpegHeader(buf, off); // Conventional MPEG header\n    } // D(16): Protection bit (if true 16-bit CRC follows header)\n\n\n    this.isProtectedByCRC = !Util_1.default.isBitSet(buf, off + 1, 7);\n  }\n\n  calcDuration(numFrames) {\n    return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n  }\n\n  calcSamplesPerFrame() {\n    return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n  }\n\n  calculateSideInfoLength() {\n    if (this.layer !== 3) return 2;\n\n    if (this.channelModeIndex === 3) {\n      // mono\n      if (this.version === 1) {\n        return 17;\n      } else if (this.version === 2 || this.version === 2.5) {\n        return 9;\n      }\n    } else {\n      if (this.version === 1) {\n        return 32;\n      } else if (this.version === 2 || this.version === 2.5) {\n        return 17;\n      }\n    }\n  }\n\n  calcSlotSize() {\n    return [null, 4, 1, 1][this.layer];\n  }\n\n  parseMpegHeader(buf, off) {\n    this.container = 'MPEG'; // E(15,12): Bitrate index\n\n    this.bitrateIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 4); // F(11,10): Sampling rate frequency index\n\n    this.sampRateFreqIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 4, 2); // G(9): Padding bit\n\n    this.padding = Util_1.default.isBitSet(buf, off + 2, 6); // H(8): Private bit\n\n    this.privateBit = Util_1.default.isBitSet(buf, off + 2, 7); // I(7,6): Channel Mode\n\n    this.channelModeIndex = Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 2); // J(5,4): Mode extension (Only used in Joint stereo)\n\n    this.modeExtension = Util_1.default.getBitAllignedNumber(buf, off + 3, 2, 2); // K(3): Copyright\n\n    this.isCopyrighted = Util_1.default.isBitSet(buf, off + 3, 4); // L(2): Original\n\n    this.isOriginalMedia = Util_1.default.isBitSet(buf, off + 3, 5); // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n\n    this.emphasis = Util_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);\n    this.version = MpegFrameHeader.VersionID[this.versionIndex];\n    this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n    this.codec = `MPEG ${this.version} Layer ${this.layer}`; // Calculate bitrate\n\n    const bitrateInKbps = this.calcBitrate();\n\n    if (!bitrateInKbps) {\n      throw new Error('Cannot determine bit-rate');\n    }\n\n    this.bitrate = bitrateInKbps * 1000; // Calculate sampling rate\n\n    this.samplingRate = this.calcSamplingRate();\n\n    if (this.samplingRate == null) {\n      throw new Error('Cannot determine sampling-rate');\n    }\n  }\n\n  parseAdtsHeader(buf, off) {\n    debug(`layer=0 => ADTS`);\n    this.version = this.versionIndex === 2 ? 4 : 2;\n    this.container = 'ADTS/MPEG-' + this.version;\n    const profileIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 2);\n    this.codec = 'AAC';\n    this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n    debug(`MPEG-4 audio-codec=${this.codec}`);\n    const samplingFrequencyIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 2, 4);\n    this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n    debug(`sampling-rate=${this.samplingRate}`);\n    const channelIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 7, 3);\n    this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n    debug(`channel-config=${this.mp4ChannelConfig.join('+')}`);\n    this.frameLength = Util_1.default.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n  }\n\n  calcBitrate() {\n    if (this.bitrateIndex === 0x00 || // free\n    this.bitrateIndex === 0x0F) {\n      // reserved\n      return;\n    }\n\n    const codecIndex = `${Math.floor(this.version)}${this.layer}`;\n    return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n  }\n\n  calcSamplingRate() {\n    if (this.sampRateFreqIndex === 0x03) return null; // 'reserved'\n\n    return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n  }\n\n}\n\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n  0x01: {\n    11: 32,\n    12: 32,\n    13: 32,\n    21: 32,\n    22: 8,\n    23: 8\n  },\n  0x02: {\n    11: 64,\n    12: 48,\n    13: 40,\n    21: 48,\n    22: 16,\n    23: 16\n  },\n  0x03: {\n    11: 96,\n    12: 56,\n    13: 48,\n    21: 56,\n    22: 24,\n    23: 24\n  },\n  0x04: {\n    11: 128,\n    12: 64,\n    13: 56,\n    21: 64,\n    22: 32,\n    23: 32\n  },\n  0x05: {\n    11: 160,\n    12: 80,\n    13: 64,\n    21: 80,\n    22: 40,\n    23: 40\n  },\n  0x06: {\n    11: 192,\n    12: 96,\n    13: 80,\n    21: 96,\n    22: 48,\n    23: 48\n  },\n  0x07: {\n    11: 224,\n    12: 112,\n    13: 96,\n    21: 112,\n    22: 56,\n    23: 56\n  },\n  0x08: {\n    11: 256,\n    12: 128,\n    13: 112,\n    21: 128,\n    22: 64,\n    23: 64\n  },\n  0x09: {\n    11: 288,\n    12: 160,\n    13: 128,\n    21: 144,\n    22: 80,\n    23: 80\n  },\n  0x0A: {\n    11: 320,\n    12: 192,\n    13: 160,\n    21: 160,\n    22: 96,\n    23: 96\n  },\n  0x0B: {\n    11: 352,\n    12: 224,\n    13: 192,\n    21: 176,\n    22: 112,\n    23: 112\n  },\n  0x0C: {\n    11: 384,\n    12: 256,\n    13: 224,\n    21: 192,\n    22: 128,\n    23: 128\n  },\n  0x0D: {\n    11: 416,\n    12: 320,\n    13: 256,\n    21: 224,\n    22: 144,\n    23: 144\n  },\n  0x0E: {\n    11: 448,\n    12: 384,\n    13: 320,\n    21: 256,\n    22: 160,\n    23: 160\n  }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n  1: {\n    0x00: 44100,\n    0x01: 48000,\n    0x02: 32000\n  },\n  2: {\n    0x00: 22050,\n    0x01: 24000,\n    0x02: 16000\n  },\n  2.5: {\n    0x00: 11025,\n    0x01: 12000,\n    0x02: 8000\n  }\n};\nMpegFrameHeader.samplesInFrameTable = [\n/* Layer   I    II   III */\n[0, 384, 1152, 1152], [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\n\nconst FrameHeader = {\n  len: 4,\n  get: (buf, off) => {\n    return new MpegFrameHeader(buf, off);\n  }\n};\n\nfunction getVbrCodecProfile(vbrScale) {\n  return 'V' + Math.floor((100 - vbrScale) / 10);\n}\n\nclass MpegParser extends AbstractID3Parser_1.AbstractID3Parser {\n  constructor() {\n    super(...arguments);\n    this.frameCount = 0;\n    this.syncFrameCount = -1;\n    this.countSkipFrameData = 0;\n    this.totalDataLength = 0;\n    this.bitrates = [];\n    this.calculateEofDuration = false;\n    this.buf_frame_header = Buffer.alloc(4);\n    this.syncPeek = {\n      buf: Buffer.alloc(maxPeekLen),\n      len: 0\n    };\n  }\n  /**\n   * Called after ID3 headers have been parsed\n   */\n\n\n  async _parse() {\n    this.metadata.setFormat('lossless', false);\n\n    try {\n      let quit = false;\n\n      while (!quit) {\n        await this.sync();\n        quit = await this.parseCommonMpegHeader();\n      }\n    } catch (err) {\n      if (err instanceof core_1.EndOfStreamError) {\n        debug(`End-of-stream`);\n\n        if (this.calculateEofDuration) {\n          const numberOfSamples = this.frameCount * this.samplesPerFrame;\n          this.metadata.setFormat('numberOfSamples', numberOfSamples);\n          const duration = numberOfSamples / this.metadata.format.sampleRate;\n          debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n          this.metadata.setFormat('duration', duration);\n        }\n      } else {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n   */\n\n\n  finalize() {\n    const format = this.metadata.format;\n    const hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\n\n    if (format.duration && this.tokenizer.fileInfo.size) {\n      const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n\n      if (format.codecProfile && format.codecProfile[0] === 'V') {\n        this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n      }\n    } else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n      const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n      const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n      this.metadata.setFormat('numberOfSamples', numberOfSamples);\n      const duration = numberOfSamples / format.sampleRate;\n      debug(\"Calculate CBR duration based on file size: %s\", duration);\n      this.metadata.setFormat('duration', duration);\n    }\n  }\n\n  async sync() {\n    let gotFirstSync = false;\n\n    while (true) {\n      let bo = 0;\n      this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, {\n        length: maxPeekLen,\n        mayBeLess: true\n      });\n\n      if (this.syncPeek.len <= 163) {\n        throw new core_1.EndOfStreamError();\n      }\n\n      while (true) {\n        if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n          this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n          this.buf_frame_header[1] = this.syncPeek.buf[bo];\n          await this.tokenizer.ignore(bo);\n          debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n\n          if (this.syncFrameCount === this.frameCount) {\n            debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n            this.frameCount = 0;\n            this.frame_size = 0;\n          }\n\n          this.syncFrameCount = this.frameCount;\n          return; // sync\n        } else {\n          gotFirstSync = false;\n          bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n\n          if (bo === -1) {\n            if (this.syncPeek.len < this.syncPeek.buf.length) {\n              throw new core_1.EndOfStreamError();\n            }\n\n            await this.tokenizer.ignore(this.syncPeek.len);\n            break; // continue with next buffer\n          } else {\n            ++bo;\n            gotFirstSync = true;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Combined ADTS & MPEG (MP2 & MP3) header handling\n   * @return {Promise<boolean>} true if parser should quit\n   */\n\n\n  async parseCommonMpegHeader() {\n    if (this.frameCount === 0) {\n      this.mpegOffset = this.tokenizer.position - 1;\n    }\n\n    await this.tokenizer.peekBuffer(this.buf_frame_header, {\n      offset: 1,\n      length: 3\n    });\n    let header;\n\n    try {\n      header = FrameHeader.get(this.buf_frame_header, 0);\n    } catch (err) {\n      await this.tokenizer.ignore(1);\n      this.metadata.addWarning('Parse error: ' + err.message);\n      return false; // sync\n    }\n\n    await this.tokenizer.ignore(3);\n    this.metadata.setFormat('container', header.container);\n    this.metadata.setFormat('codec', header.codec);\n    this.metadata.setFormat('lossless', false);\n    this.metadata.setFormat('sampleRate', header.samplingRate);\n    this.frameCount++;\n\n    if (header.version >= 2 && header.layer === 0) {\n      return this.parseAdts(header); // ADTS, usually AAC\n    } else {\n      return this.parseAudioFrameHeader(header); // MP3\n    }\n  }\n  /**\n   * @return {Promise<boolean>} true if parser should quit\n   */\n\n\n  async parseAudioFrameHeader(header) {\n    this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n    this.metadata.setFormat('bitrate', header.bitrate);\n\n    if (this.frameCount < 20 * 10000) {\n      debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n    }\n\n    const slot_size = header.calcSlotSize();\n\n    if (slot_size === null) {\n      throw new Error('invalid slot_size');\n    }\n\n    const samples_per_frame = header.calcSamplesPerFrame();\n    debug(`samples_per_frame=${samples_per_frame}`);\n    const bps = samples_per_frame / 8.0;\n    const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);\n    this.frame_size = Math.floor(fsize);\n    this.audioFrameHeader = header;\n    this.bitrates.push(header.bitrate); // xtra header only exists in first frame\n\n    if (this.frameCount === 1) {\n      this.offset = FrameHeader.len;\n      await this.skipSideInformation();\n      return false;\n    }\n\n    if (this.frameCount === 3) {\n      // the stream is CBR if the first 3 frame bitrates are the same\n      if (this.areAllSame(this.bitrates)) {\n        // Actual calculation will be done in finalize\n        this.samplesPerFrame = samples_per_frame;\n        this.metadata.setFormat('codecProfile', 'CBR');\n        if (this.tokenizer.fileInfo.size) return true; // Will calculate duration based on the file size\n      } else if (this.metadata.format.duration) {\n        return true; // We already got the duration, stop processing MPEG stream any further\n      }\n\n      if (!this.options.duration) {\n        return true; // Enforce duration not enabled, stop processing entire stream\n      }\n    } // once we know the file is VBR attach listener to end of\n    // stream so we can do the duration calculation when we\n    // have counted all the frames\n\n\n    if (this.options.duration && this.frameCount === 4) {\n      this.samplesPerFrame = samples_per_frame;\n      this.calculateEofDuration = true;\n    }\n\n    this.offset = 4;\n\n    if (header.isProtectedByCRC) {\n      await this.parseCrc();\n      return false;\n    } else {\n      await this.skipSideInformation();\n      return false;\n    }\n  }\n\n  async parseAdts(header) {\n    const buf = Buffer.alloc(3);\n    await this.tokenizer.readBuffer(buf);\n    header.frameLength += Util_1.default.getBitAllignedNumber(buf, 0, 0, 11);\n    this.totalDataLength += header.frameLength;\n    this.samplesPerFrame = 1024;\n    const framesPerSec = header.samplingRate / this.samplesPerFrame;\n    const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n    const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n    this.metadata.setFormat('bitrate', bitrate);\n    debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n    await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1); // Consume remaining header and frame data\n\n    if (this.frameCount === 3) {\n      this.metadata.setFormat('codecProfile', header.codecProfile);\n\n      if (header.mp4ChannelConfig) {\n        this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n      }\n\n      if (this.options.duration) {\n        this.calculateEofDuration = true;\n      } else {\n        return true; // Stop parsing after the third frame\n      }\n    }\n\n    return false;\n  }\n\n  async parseCrc() {\n    this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n    this.offset += 2;\n    return this.skipSideInformation();\n  }\n\n  async skipSideInformation() {\n    const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength(); // side information\n\n    await this.tokenizer.readToken(new Token.BufferType(sideinfo_length));\n    this.offset += sideinfo_length;\n    await this.readXtraInfoHeader();\n    return;\n  }\n\n  async readXtraInfoHeader() {\n    const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\n    this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\n\n    switch (headerTag) {\n      case 'Info':\n        this.metadata.setFormat('codecProfile', 'CBR');\n        return this.readXingInfoHeader();\n\n      case 'Xing':\n        const infoTag = await this.readXingInfoHeader();\n        const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n        this.metadata.setFormat('codecProfile', codecProfile);\n        return null;\n\n      case 'Xtra':\n        // ToDo: ???\n        break;\n\n      case 'LAME':\n        const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\n\n        if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {\n          this.offset += XingTag_1.LameEncoderVersion.len;\n          this.metadata.setFormat('tool', 'LAME ' + version);\n          await this.skipFrameData(this.frame_size - this.offset);\n          return null;\n        } else {\n          this.metadata.addWarning('Corrupt LAME header');\n          break;\n        }\n\n      // ToDo: ???\n    } // ToDo: promise duration???\n\n\n    const frameDataLeft = this.frame_size - this.offset;\n\n    if (frameDataLeft < 0) {\n      this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\n    } else {\n      await this.skipFrameData(frameDataLeft);\n    }\n\n    return null;\n  }\n  /**\n   * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n   * @returns {Promise<string>}\n   */\n\n\n  async readXingInfoHeader() {\n    const infoTag = await this.tokenizer.readToken(XingTag_1.XingInfoTag);\n    this.offset += XingTag_1.XingInfoTag.len; // 12\n\n    this.metadata.setFormat('tool', Util_1.default.stripNulls(infoTag.codec));\n\n    if ((infoTag.headerFlags[3] & 0x01) === 1) {\n      const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n      this.metadata.setFormat('duration', duration);\n      debug('Get duration from Xing header: %s', this.metadata.format.duration);\n      return infoTag;\n    } // frames field is not present\n\n\n    const frameDataLeft = this.frame_size - this.offset;\n    await this.skipFrameData(frameDataLeft);\n    return infoTag;\n  }\n\n  async skipFrameData(frameDataLeft) {\n    assert.ok(frameDataLeft >= 0, 'frame-data-left cannot be negative');\n    await this.tokenizer.ignore(frameDataLeft);\n    this.countSkipFrameData += frameDataLeft;\n  }\n\n  areAllSame(array) {\n    const first = array[0];\n    return array.every(element => {\n      return element === first;\n    });\n  }\n\n}\n\nexports.MpegParser = MpegParser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/mpeg/MpegParser.js"],"names":["Object","defineProperty","exports","value","MpegParser","assert","require","Token","core_1","initDebug","Util_1","AbstractID3Parser_1","XingTag_1","debug","maxPeekLen","MPEG4","AudioObjectTypes","SamplingFrequencies","undefined","MPEG4_ChannelConfigurations","MpegFrameHeader","constructor","buf","off","versionIndex","default","getBitAllignedNumber","layer","LayerDescription","parseAdtsHeader","parseMpegHeader","isProtectedByCRC","isBitSet","calcDuration","numFrames","calcSamplesPerFrame","samplingRate","samplesInFrameTable","version","calculateSideInfoLength","channelModeIndex","calcSlotSize","container","bitrateIndex","sampRateFreqIndex","padding","privateBit","modeExtension","isCopyrighted","isOriginalMedia","emphasis","VersionID","channelMode","ChannelMode","codec","bitrateInKbps","calcBitrate","Error","bitrate","calcSamplingRate","profileIndex","codecProfile","samplingFrequencyIndex","channelIndex","mp4ChannelConfig","join","frameLength","codecIndex","Math","floor","bitrate_index","sampling_rate_freq_index","SyncByte1","SyncByte2","FrameHeader","len","get","getVbrCodecProfile","vbrScale","AbstractID3Parser","arguments","frameCount","syncFrameCount","countSkipFrameData","totalDataLength","bitrates","calculateEofDuration","buf_frame_header","Buffer","alloc","syncPeek","_parse","metadata","setFormat","quit","sync","parseCommonMpegHeader","err","EndOfStreamError","numberOfSamples","samplesPerFrame","duration","format","sampleRate","finalize","hasID3v1","native","hasOwnProperty","tokenizer","fileInfo","size","mpegSize","mpegOffset","round","frame_size","gotFirstSync","bo","peekBuffer","length","mayBeLess","ignore","position","indexOf","offset","header","addWarning","message","parseAdts","parseAudioFrameHeader","slot_size","samples_per_frame","bps","fsize","audioFrameHeader","push","skipSideInformation","areAllSame","options","parseCrc","readBuffer","framesPerSec","bytesPerFrame","crc","readNumber","INT16_BE","sideinfo_length","readToken","BufferType","readXtraInfoHeader","headerTag","InfoTagHeaderTag","readXingInfoHeader","infoTag","LameEncoderVersion","skipFrameData","frameDataLeft","XingInfoTag","stripNulls","headerFlags","ok","array","first","every","element"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MpegParser = void 0;\nconst assert = require(\"assert\");\nconst Token = require(\"token-types\");\nconst core_1 = require(\"strtok3/lib/core\");\nconst initDebug = require(\"debug\");\nconst Util_1 = require(\"../common/Util\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst XingTag_1 = require(\"./XingTag\");\nconst debug = initDebug('music-metadata:parser:mpeg');\n/**\n * Cache buffer size used for searching synchronization preabmle\n */\nconst maxPeekLen = 1024;\n/**\n * MPEG-4 Audio definitions\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\n */\nconst MPEG4 = {\n    /**\n     * Audio Object Types\n     */\n    AudioObjectTypes: [\n        'AAC Main',\n        'AAC LC',\n        'AAC SSR',\n        'AAC LTP' // Long Term Prediction\n    ],\n    /**\n     * Sampling Frequencies\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\n     */\n    SamplingFrequencies: [\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, undefined, undefined, -1\n    ]\n    /**\n     * Channel Configurations\n     */\n};\nconst MPEG4_ChannelConfigurations = [\n    undefined,\n    ['front-center'],\n    ['front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right'],\n    ['front-center', 'front-left', 'front-right', 'back-center'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\n];\n/**\n * MPEG Audio Layer I/II/III frame header\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\n */\nclass MpegFrameHeader {\n    constructor(buf, off) {\n        // B(20,19): MPEG Audio versionIndex ID\n        this.versionIndex = Util_1.default.getBitAllignedNumber(buf, off + 1, 3, 2);\n        // C(18,17): Layer description\n        this.layer = MpegFrameHeader.LayerDescription[Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];\n        if (this.versionIndex > 1 && this.layer === 0) {\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n        }\n        else {\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\n        }\n        // D(16): Protection bit (if true 16-bit CRC follows header)\n        this.isProtectedByCRC = !Util_1.default.isBitSet(buf, off + 1, 7);\n    }\n    calcDuration(numFrames) {\n        return numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n    }\n    calcSamplesPerFrame() {\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n    }\n    calculateSideInfoLength() {\n        if (this.layer !== 3)\n            return 2;\n        if (this.channelModeIndex === 3) {\n            // mono\n            if (this.version === 1) {\n                return 17;\n            }\n            else if (this.version === 2 || this.version === 2.5) {\n                return 9;\n            }\n        }\n        else {\n            if (this.version === 1) {\n                return 32;\n            }\n            else if (this.version === 2 || this.version === 2.5) {\n                return 17;\n            }\n        }\n    }\n    calcSlotSize() {\n        return [null, 4, 1, 1][this.layer];\n    }\n    parseMpegHeader(buf, off) {\n        this.container = 'MPEG';\n        // E(15,12): Bitrate index\n        this.bitrateIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 4);\n        // F(11,10): Sampling rate frequency index\n        this.sampRateFreqIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 4, 2);\n        // G(9): Padding bit\n        this.padding = Util_1.default.isBitSet(buf, off + 2, 6);\n        // H(8): Private bit\n        this.privateBit = Util_1.default.isBitSet(buf, off + 2, 7);\n        // I(7,6): Channel Mode\n        this.channelModeIndex = Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 2);\n        // J(5,4): Mode extension (Only used in Joint stereo)\n        this.modeExtension = Util_1.default.getBitAllignedNumber(buf, off + 3, 2, 2);\n        // K(3): Copyright\n        this.isCopyrighted = Util_1.default.isBitSet(buf, off + 3, 4);\n        // L(2): Original\n        this.isOriginalMedia = Util_1.default.isBitSet(buf, off + 3, 5);\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n        this.emphasis = Util_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n        // Calculate bitrate\n        const bitrateInKbps = this.calcBitrate();\n        if (!bitrateInKbps) {\n            throw new Error('Cannot determine bit-rate');\n        }\n        this.bitrate = bitrateInKbps * 1000;\n        // Calculate sampling rate\n        this.samplingRate = this.calcSamplingRate();\n        if (this.samplingRate == null) {\n            throw new Error('Cannot determine sampling-rate');\n        }\n    }\n    parseAdtsHeader(buf, off) {\n        debug(`layer=0 => ADTS`);\n        this.version = this.versionIndex === 2 ? 4 : 2;\n        this.container = 'ADTS/MPEG-' + this.version;\n        const profileIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 2);\n        this.codec = 'AAC';\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n        debug(`MPEG-4 audio-codec=${this.codec}`);\n        const samplingFrequencyIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 2, 4);\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n        debug(`sampling-rate=${this.samplingRate}`);\n        const channelIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 7, 3);\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n        debug(`channel-config=${this.mp4ChannelConfig.join('+')}`);\n        this.frameLength = Util_1.default.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n    }\n    calcBitrate() {\n        if (this.bitrateIndex === 0x00 || // free\n            this.bitrateIndex === 0x0F) { // reserved\n            return;\n        }\n        const codecIndex = `${Math.floor(this.version)}${this.layer}`;\n        return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n    }\n    calcSamplingRate() {\n        if (this.sampRateFreqIndex === 0x03)\n            return null; // 'reserved'\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n    }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n    0x01: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\n    0x02: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\n    0x03: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\n    0x04: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\n    0x05: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\n    0x06: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\n    0x07: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\n    0x08: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\n    0x09: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\n    0x0A: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\n    0x0B: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\n    0x0C: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\n    0x0D: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\n    0x0E: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n    1: { 0x00: 44100, 0x01: 48000, 0x02: 32000 },\n    2: { 0x00: 22050, 0x01: 24000, 0x02: 16000 },\n    2.5: { 0x00: 11025, 0x01: 12000, 0x02: 8000 }\n};\nMpegFrameHeader.samplesInFrameTable = [\n    /* Layer   I    II   III */\n    [0, 384, 1152, 1152],\n    [0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\n * MPEG Audio Layer I/II/III\n */\nconst FrameHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return new MpegFrameHeader(buf, off);\n    }\n};\nfunction getVbrCodecProfile(vbrScale) {\n    return 'V' + Math.floor((100 - vbrScale) / 10);\n}\nclass MpegParser extends AbstractID3Parser_1.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.frameCount = 0;\n        this.syncFrameCount = -1;\n        this.countSkipFrameData = 0;\n        this.totalDataLength = 0;\n        this.bitrates = [];\n        this.calculateEofDuration = false;\n        this.buf_frame_header = Buffer.alloc(4);\n        this.syncPeek = {\n            buf: Buffer.alloc(maxPeekLen),\n            len: 0\n        };\n    }\n    /**\n     * Called after ID3 headers have been parsed\n     */\n    async _parse() {\n        this.metadata.setFormat('lossless', false);\n        try {\n            let quit = false;\n            while (!quit) {\n                await this.sync();\n                quit = await this.parseCommonMpegHeader();\n            }\n        }\n        catch (err) {\n            if (err instanceof core_1.EndOfStreamError) {\n                debug(`End-of-stream`);\n                if (this.calculateEofDuration) {\n                    const numberOfSamples = this.frameCount * this.samplesPerFrame;\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                    const duration = numberOfSamples / this.metadata.format.sampleRate;\n                    debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n                    this.metadata.setFormat('duration', duration);\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    /**\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\n     */\n    finalize() {\n        const format = this.metadata.format;\n        const hasID3v1 = this.metadata.native.hasOwnProperty('ID3v1');\n        if (format.duration && this.tokenizer.fileInfo.size) {\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n            if (format.codecProfile && format.codecProfile[0] === 'V') {\n                this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n            }\n        }\n        else if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n            const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n            const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\n            const duration = numberOfSamples / format.sampleRate;\n            debug(\"Calculate CBR duration based on file size: %s\", duration);\n            this.metadata.setFormat('duration', duration);\n        }\n    }\n    async sync() {\n        let gotFirstSync = false;\n        while (true) {\n            let bo = 0;\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\n            if (this.syncPeek.len <= 163) {\n                throw new core_1.EndOfStreamError();\n            }\n            while (true) {\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\n                    await this.tokenizer.ignore(bo);\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n                    if (this.syncFrameCount === this.frameCount) {\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n                        this.frameCount = 0;\n                        this.frame_size = 0;\n                    }\n                    this.syncFrameCount = this.frameCount;\n                    return; // sync\n                }\n                else {\n                    gotFirstSync = false;\n                    bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n                    if (bo === -1) {\n                        if (this.syncPeek.len < this.syncPeek.buf.length) {\n                            throw new core_1.EndOfStreamError();\n                        }\n                        await this.tokenizer.ignore(this.syncPeek.len);\n                        break; // continue with next buffer\n                    }\n                    else {\n                        ++bo;\n                        gotFirstSync = true;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseCommonMpegHeader() {\n        if (this.frameCount === 0) {\n            this.mpegOffset = this.tokenizer.position - 1;\n        }\n        await this.tokenizer.peekBuffer(this.buf_frame_header, { offset: 1, length: 3 });\n        let header;\n        try {\n            header = FrameHeader.get(this.buf_frame_header, 0);\n        }\n        catch (err) {\n            await this.tokenizer.ignore(1);\n            this.metadata.addWarning('Parse error: ' + err.message);\n            return false; // sync\n        }\n        await this.tokenizer.ignore(3);\n        this.metadata.setFormat('container', header.container);\n        this.metadata.setFormat('codec', header.codec);\n        this.metadata.setFormat('lossless', false);\n        this.metadata.setFormat('sampleRate', header.samplingRate);\n        this.frameCount++;\n        if (header.version >= 2 && header.layer === 0) {\n            return this.parseAdts(header); // ADTS, usually AAC\n        }\n        else {\n            return this.parseAudioFrameHeader(header); // MP3\n        }\n    }\n    /**\n     * @return {Promise<boolean>} true if parser should quit\n     */\n    async parseAudioFrameHeader(header) {\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n        this.metadata.setFormat('bitrate', header.bitrate);\n        if (this.frameCount < 20 * 10000) {\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n        }\n        const slot_size = header.calcSlotSize();\n        if (slot_size === null) {\n            throw new Error('invalid slot_size');\n        }\n        const samples_per_frame = header.calcSamplesPerFrame();\n        debug(`samples_per_frame=${samples_per_frame}`);\n        const bps = samples_per_frame / 8.0;\n        const fsize = (bps * header.bitrate / header.samplingRate) +\n            ((header.padding) ? slot_size : 0);\n        this.frame_size = Math.floor(fsize);\n        this.audioFrameHeader = header;\n        this.bitrates.push(header.bitrate);\n        // xtra header only exists in first frame\n        if (this.frameCount === 1) {\n            this.offset = FrameHeader.len;\n            await this.skipSideInformation();\n            return false;\n        }\n        if (this.frameCount === 3) {\n            // the stream is CBR if the first 3 frame bitrates are the same\n            if (this.areAllSame(this.bitrates)) {\n                // Actual calculation will be done in finalize\n                this.samplesPerFrame = samples_per_frame;\n                this.metadata.setFormat('codecProfile', 'CBR');\n                if (this.tokenizer.fileInfo.size)\n                    return true; // Will calculate duration based on the file size\n            }\n            else if (this.metadata.format.duration) {\n                return true; // We already got the duration, stop processing MPEG stream any further\n            }\n            if (!this.options.duration) {\n                return true; // Enforce duration not enabled, stop processing entire stream\n            }\n        }\n        // once we know the file is VBR attach listener to end of\n        // stream so we can do the duration calculation when we\n        // have counted all the frames\n        if (this.options.duration && this.frameCount === 4) {\n            this.samplesPerFrame = samples_per_frame;\n            this.calculateEofDuration = true;\n        }\n        this.offset = 4;\n        if (header.isProtectedByCRC) {\n            await this.parseCrc();\n            return false;\n        }\n        else {\n            await this.skipSideInformation();\n            return false;\n        }\n    }\n    async parseAdts(header) {\n        const buf = Buffer.alloc(3);\n        await this.tokenizer.readBuffer(buf);\n        header.frameLength += Util_1.default.getBitAllignedNumber(buf, 0, 0, 11);\n        this.totalDataLength += header.frameLength;\n        this.samplesPerFrame = 1024;\n        const framesPerSec = header.samplingRate / this.samplesPerFrame;\n        const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n        const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n        this.metadata.setFormat('bitrate', bitrate);\n        debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n        // Consume remaining header and frame data\n        if (this.frameCount === 3) {\n            this.metadata.setFormat('codecProfile', header.codecProfile);\n            if (header.mp4ChannelConfig) {\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n            }\n            if (this.options.duration) {\n                this.calculateEofDuration = true;\n            }\n            else {\n                return true; // Stop parsing after the third frame\n            }\n        }\n        return false;\n    }\n    async parseCrc() {\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n        this.offset += 2;\n        return this.skipSideInformation();\n    }\n    async skipSideInformation() {\n        const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n        // side information\n        await this.tokenizer.readToken(new Token.BufferType(sideinfo_length));\n        this.offset += sideinfo_length;\n        await this.readXtraInfoHeader();\n        return;\n    }\n    async readXtraInfoHeader() {\n        const headerTag = await this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);\n        this.offset += XingTag_1.InfoTagHeaderTag.len; // 12\n        switch (headerTag) {\n            case 'Info':\n                this.metadata.setFormat('codecProfile', 'CBR');\n                return this.readXingInfoHeader();\n            case 'Xing':\n                const infoTag = await this.readXingInfoHeader();\n                const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n                this.metadata.setFormat('codecProfile', codecProfile);\n                return null;\n            case 'Xtra':\n                // ToDo: ???\n                break;\n            case 'LAME':\n                const version = await this.tokenizer.readToken(XingTag_1.LameEncoderVersion);\n                if (this.frame_size >= this.offset + XingTag_1.LameEncoderVersion.len) {\n                    this.offset += XingTag_1.LameEncoderVersion.len;\n                    this.metadata.setFormat('tool', 'LAME ' + version);\n                    await this.skipFrameData(this.frame_size - this.offset);\n                    return null;\n                }\n                else {\n                    this.metadata.addWarning('Corrupt LAME header');\n                    break;\n                }\n            // ToDo: ???\n        }\n        // ToDo: promise duration???\n        const frameDataLeft = this.frame_size - this.offset;\n        if (frameDataLeft < 0) {\n            this.metadata.addWarning('Frame ' + this.frameCount + 'corrupt: negative frameDataLeft');\n        }\n        else {\n            await this.skipFrameData(frameDataLeft);\n        }\n        return null;\n    }\n    /**\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\n     * @returns {Promise<string>}\n     */\n    async readXingInfoHeader() {\n        const infoTag = await this.tokenizer.readToken(XingTag_1.XingInfoTag);\n        this.offset += XingTag_1.XingInfoTag.len; // 12\n        this.metadata.setFormat('tool', Util_1.default.stripNulls(infoTag.codec));\n        if ((infoTag.headerFlags[3] & 0x01) === 1) {\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n            this.metadata.setFormat('duration', duration);\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\n            return infoTag;\n        }\n        // frames field is not present\n        const frameDataLeft = this.frame_size - this.offset;\n        await this.skipFrameData(frameDataLeft);\n        return infoTag;\n    }\n    async skipFrameData(frameDataLeft) {\n        assert.ok(frameDataLeft >= 0, 'frame-data-left cannot be negative');\n        await this.tokenizer.ignore(frameDataLeft);\n        this.countSkipFrameData += frameDataLeft;\n    }\n    areAllSame(array) {\n        const first = array[0];\n        return array.every(element => {\n            return element === first;\n        });\n    }\n}\nexports.MpegParser = MpegParser;\n//# sourceMappingURL=MpegParser.js.map"]},"metadata":{},"sourceType":"script"}