{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _getIterator from \"@babel/runtime-corejs2/core-js/get-iterator\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport toPath from \"lodash/toPath\";\nimport Ajv from \"ajv\";\nvar ajv = createAjvInstance();\nimport { deepEquals, getDefaultFormState } from \"./utils\";\nvar formerCustomFormats = null;\nvar formerMetaSchema = null;\nimport { isObject, mergeObjects } from \"./utils\";\n\nfunction createAjvInstance() {\n  var ajv = new Ajv({\n    errorDataPath: \"property\",\n    allErrors: true,\n    multipleOfPrecision: 8,\n    schemaId: \"auto\",\n    unknownFormats: \"ignore\"\n  }); // add custom formats\n\n  ajv.addFormat(\"data-url\", /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/);\n  ajv.addFormat(\"color\", /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/);\n  return ajv;\n}\n\nfunction toErrorSchema(errors) {\n  // Transforms a ajv validation errors list:\n  // [\n  //   {property: \".level1.level2[2].level3\", message: \"err a\"},\n  //   {property: \".level1.level2[2].level3\", message: \"err b\"},\n  //   {property: \".level1.level2[4].level3\", message: \"err b\"},\n  // ]\n  // Into an error tree:\n  // {\n  //   level1: {\n  //     level2: {\n  //       2: {level3: {errors: [\"err a\", \"err b\"]}},\n  //       4: {level3: {errors: [\"err b\"]}},\n  //     }\n  //   }\n  // };\n  if (!errors.length) {\n    return {};\n  }\n\n  return errors.reduce(function (errorSchema, error) {\n    var property = error.property,\n        message = error.message;\n    var path = toPath(property);\n    var parent = errorSchema; // If the property is at the root (.level1) then toPath creates\n    // an empty array element at the first index. Remove it.\n\n    if (path.length > 0 && path[0] === \"\") {\n      path.splice(0, 1);\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(path.slice(0)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var segment = _step.value;\n\n        if (!(segment in parent)) {\n          parent[segment] = {};\n        }\n\n        parent = parent[segment];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (_Array$isArray(parent.__errors)) {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // \"errors\" (see `validate.createErrorHandler`).\n      parent.__errors = parent.__errors.concat(message);\n    } else {\n      if (message) {\n        parent.__errors = [message];\n      }\n    }\n\n    return errorSchema;\n  }, {});\n}\n\nexport function toErrorList(errorSchema) {\n  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"root\"; // XXX: We should transform fieldName as a full field path string.\n\n  var errorList = [];\n\n  if (\"__errors\" in errorSchema) {\n    errorList = errorList.concat(errorSchema.__errors.map(function (stack) {\n      return {\n        stack: \"\".concat(fieldName, \": \").concat(stack)\n      };\n    }));\n  }\n\n  return _Object$keys(errorSchema).reduce(function (acc, key) {\n    if (key !== \"__errors\") {\n      acc = acc.concat(toErrorList(errorSchema[key], key));\n    }\n\n    return acc;\n  }, errorList);\n}\n\nfunction createErrorHandler(formData) {\n  var handler = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // \"errors\" (see `utils.toErrorSchema`).\n    __errors: [],\n    addError: function addError(message) {\n      this.__errors.push(message);\n    }\n  };\n\n  if (isObject(formData)) {\n    return _Object$keys(formData).reduce(function (acc, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(formData[key])));\n    }, handler);\n  }\n\n  if (_Array$isArray(formData)) {\n    return formData.reduce(function (acc, value, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(value)));\n    }, handler);\n  }\n\n  return handler;\n}\n\nfunction unwrapErrorHandler(errorHandler) {\n  return _Object$keys(errorHandler).reduce(function (acc, key) {\n    if (key === \"addError\") {\n      return acc;\n    } else if (key === \"__errors\") {\n      return _objectSpread({}, acc, _defineProperty({}, key, errorHandler[key]));\n    }\n\n    return _objectSpread({}, acc, _defineProperty({}, key, unwrapErrorHandler(errorHandler[key])));\n  }, {});\n}\n/**\n * Transforming the error output from ajv to format used by jsonschema.\n * At some point, components should be updated to support ajv.\n */\n\n\nfunction transformAjvErrors() {\n  var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (errors === null) {\n    return [];\n  }\n\n  return errors.map(function (e) {\n    var dataPath = e.dataPath,\n        keyword = e.keyword,\n        message = e.message,\n        params = e.params,\n        schemaPath = e.schemaPath;\n    var property = \"\".concat(dataPath); // put data in expected format\n\n    return {\n      name: keyword,\n      property: property,\n      message: message,\n      params: params,\n      // specific to ajv\n      stack: \"\".concat(property, \" \").concat(message).trim(),\n      schemaPath: schemaPath\n    };\n  });\n}\n/**\n * This function processes the formData with a user `validate` contributed\n * function, which receives the form data and an `errorHandler` object that\n * will be used to add custom validation errors for each field.\n */\n\n\nexport default function validateFormData(formData, schema, customValidate, transformErrors) {\n  var additionalMetaSchemas = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var customFormats = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {}; // Include form data with undefined values, which is required for validation.\n\n  var rootSchema = schema;\n  formData = getDefaultFormState(schema, formData, rootSchema, true);\n  var newMetaSchemas = !deepEquals(formerMetaSchema, additionalMetaSchemas);\n  var newFormats = !deepEquals(formerCustomFormats, customFormats);\n\n  if (newMetaSchemas || newFormats) {\n    ajv = createAjvInstance();\n  } // add more schemas to validate against\n\n\n  if (additionalMetaSchemas && newMetaSchemas && _Array$isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n    formerMetaSchema = additionalMetaSchemas;\n  } // add more custom formats to validate against\n\n\n  if (customFormats && newFormats && isObject(customFormats)) {\n    _Object$keys(customFormats).forEach(function (formatName) {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n\n    formerCustomFormats = customFormats;\n  }\n\n  var validationError = null;\n\n  try {\n    ajv.validate(schema, formData);\n  } catch (err) {\n    validationError = err;\n  }\n\n  var errors = transformAjvErrors(ajv.errors); // Clear errors to prevent persistent errors, see #1104\n\n  ajv.errors = null;\n  var noProperMetaSchema = validationError && validationError.message && typeof validationError.message === \"string\" && validationError.message.includes(\"no schema with key or ref \");\n\n  if (noProperMetaSchema) {\n    errors = [].concat(_toConsumableArray(errors), [{\n      stack: validationError.message\n    }]);\n  }\n\n  if (typeof transformErrors === \"function\") {\n    errors = transformErrors(errors);\n  }\n\n  var errorSchema = toErrorSchema(errors);\n\n  if (noProperMetaSchema) {\n    errorSchema = _objectSpread({}, errorSchema, {\n      $schema: {\n        __errors: [validationError.message]\n      }\n    });\n  }\n\n  if (typeof customValidate !== \"function\") {\n    return {\n      errors: errors,\n      errorSchema: errorSchema\n    };\n  }\n\n  var errorHandler = customValidate(formData, createErrorHandler(formData));\n  var userErrorSchema = unwrapErrorHandler(errorHandler);\n  var newErrorSchema = mergeObjects(errorSchema, userErrorSchema, true); // XXX: The errors list produced is not fully compliant with the format\n  // exposed by the jsonschema lib, which contains full field paths and other\n  // properties.\n\n  var newErrors = toErrorList(newErrorSchema);\n  return {\n    errors: newErrors,\n    errorSchema: newErrorSchema\n  };\n}\n/**\n * Validates data against a schema, returning true if the data is valid, or\n * false otherwise. If the schema is invalid, then this function will return\n * false.\n */\n\nexport function isValid(schema, data) {\n  try {\n    return ajv.validate(schema, data);\n  } catch (e) {\n    return false;\n  }\n}","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/@rjsf/core/dist/es/validate.js"],"names":["_toConsumableArray","_defineProperty","_objectSpread","_Object$keys","_getIterator","_Array$isArray","toPath","Ajv","ajv","createAjvInstance","deepEquals","getDefaultFormState","formerCustomFormats","formerMetaSchema","isObject","mergeObjects","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","addFormat","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","parent","splice","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","slice","_step","next","done","segment","value","err","__errors","concat","toErrorList","fieldName","arguments","errorList","map","stack","acc","key","createErrorHandler","formData","handler","addError","push","unwrapErrorHandler","errorHandler","transformAjvErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","additionalMetaSchemas","customFormats","rootSchema","newMetaSchemas","newFormats","addMetaSchema","forEach","formatName","validationError","validate","noProperMetaSchema","includes","$schema","userErrorSchema","newErrorSchema","newErrors","isValid","data"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _getIterator from \"@babel/runtime-corejs2/core-js/get-iterator\";\nimport _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport toPath from \"lodash/toPath\";\nimport Ajv from \"ajv\";\nvar ajv = createAjvInstance();\nimport { deepEquals, getDefaultFormState } from \"./utils\";\nvar formerCustomFormats = null;\nvar formerMetaSchema = null;\nimport { isObject, mergeObjects } from \"./utils\";\n\nfunction createAjvInstance() {\n  var ajv = new Ajv({\n    errorDataPath: \"property\",\n    allErrors: true,\n    multipleOfPrecision: 8,\n    schemaId: \"auto\",\n    unknownFormats: \"ignore\"\n  }); // add custom formats\n\n  ajv.addFormat(\"data-url\", /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/);\n  ajv.addFormat(\"color\", /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/);\n  return ajv;\n}\n\nfunction toErrorSchema(errors) {\n  // Transforms a ajv validation errors list:\n  // [\n  //   {property: \".level1.level2[2].level3\", message: \"err a\"},\n  //   {property: \".level1.level2[2].level3\", message: \"err b\"},\n  //   {property: \".level1.level2[4].level3\", message: \"err b\"},\n  // ]\n  // Into an error tree:\n  // {\n  //   level1: {\n  //     level2: {\n  //       2: {level3: {errors: [\"err a\", \"err b\"]}},\n  //       4: {level3: {errors: [\"err b\"]}},\n  //     }\n  //   }\n  // };\n  if (!errors.length) {\n    return {};\n  }\n\n  return errors.reduce(function (errorSchema, error) {\n    var property = error.property,\n        message = error.message;\n    var path = toPath(property);\n    var parent = errorSchema; // If the property is at the root (.level1) then toPath creates\n    // an empty array element at the first index. Remove it.\n\n    if (path.length > 0 && path[0] === \"\") {\n      path.splice(0, 1);\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(path.slice(0)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var segment = _step.value;\n\n        if (!(segment in parent)) {\n          parent[segment] = {};\n        }\n\n        parent = parent[segment];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (_Array$isArray(parent.__errors)) {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // \"errors\" (see `validate.createErrorHandler`).\n      parent.__errors = parent.__errors.concat(message);\n    } else {\n      if (message) {\n        parent.__errors = [message];\n      }\n    }\n\n    return errorSchema;\n  }, {});\n}\n\nexport function toErrorList(errorSchema) {\n  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"root\";\n  // XXX: We should transform fieldName as a full field path string.\n  var errorList = [];\n\n  if (\"__errors\" in errorSchema) {\n    errorList = errorList.concat(errorSchema.__errors.map(function (stack) {\n      return {\n        stack: \"\".concat(fieldName, \": \").concat(stack)\n      };\n    }));\n  }\n\n  return _Object$keys(errorSchema).reduce(function (acc, key) {\n    if (key !== \"__errors\") {\n      acc = acc.concat(toErrorList(errorSchema[key], key));\n    }\n\n    return acc;\n  }, errorList);\n}\n\nfunction createErrorHandler(formData) {\n  var handler = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // \"errors\" (see `utils.toErrorSchema`).\n    __errors: [],\n    addError: function addError(message) {\n      this.__errors.push(message);\n    }\n  };\n\n  if (isObject(formData)) {\n    return _Object$keys(formData).reduce(function (acc, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(formData[key])));\n    }, handler);\n  }\n\n  if (_Array$isArray(formData)) {\n    return formData.reduce(function (acc, value, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(value)));\n    }, handler);\n  }\n\n  return handler;\n}\n\nfunction unwrapErrorHandler(errorHandler) {\n  return _Object$keys(errorHandler).reduce(function (acc, key) {\n    if (key === \"addError\") {\n      return acc;\n    } else if (key === \"__errors\") {\n      return _objectSpread({}, acc, _defineProperty({}, key, errorHandler[key]));\n    }\n\n    return _objectSpread({}, acc, _defineProperty({}, key, unwrapErrorHandler(errorHandler[key])));\n  }, {});\n}\n/**\n * Transforming the error output from ajv to format used by jsonschema.\n * At some point, components should be updated to support ajv.\n */\n\n\nfunction transformAjvErrors() {\n  var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (errors === null) {\n    return [];\n  }\n\n  return errors.map(function (e) {\n    var dataPath = e.dataPath,\n        keyword = e.keyword,\n        message = e.message,\n        params = e.params,\n        schemaPath = e.schemaPath;\n    var property = \"\".concat(dataPath); // put data in expected format\n\n    return {\n      name: keyword,\n      property: property,\n      message: message,\n      params: params,\n      // specific to ajv\n      stack: \"\".concat(property, \" \").concat(message).trim(),\n      schemaPath: schemaPath\n    };\n  });\n}\n/**\n * This function processes the formData with a user `validate` contributed\n * function, which receives the form data and an `errorHandler` object that\n * will be used to add custom validation errors for each field.\n */\n\n\nexport default function validateFormData(formData, schema, customValidate, transformErrors) {\n  var additionalMetaSchemas = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var customFormats = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  // Include form data with undefined values, which is required for validation.\n  var rootSchema = schema;\n  formData = getDefaultFormState(schema, formData, rootSchema, true);\n  var newMetaSchemas = !deepEquals(formerMetaSchema, additionalMetaSchemas);\n  var newFormats = !deepEquals(formerCustomFormats, customFormats);\n\n  if (newMetaSchemas || newFormats) {\n    ajv = createAjvInstance();\n  } // add more schemas to validate against\n\n\n  if (additionalMetaSchemas && newMetaSchemas && _Array$isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n    formerMetaSchema = additionalMetaSchemas;\n  } // add more custom formats to validate against\n\n\n  if (customFormats && newFormats && isObject(customFormats)) {\n    _Object$keys(customFormats).forEach(function (formatName) {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n\n    formerCustomFormats = customFormats;\n  }\n\n  var validationError = null;\n\n  try {\n    ajv.validate(schema, formData);\n  } catch (err) {\n    validationError = err;\n  }\n\n  var errors = transformAjvErrors(ajv.errors); // Clear errors to prevent persistent errors, see #1104\n\n  ajv.errors = null;\n  var noProperMetaSchema = validationError && validationError.message && typeof validationError.message === \"string\" && validationError.message.includes(\"no schema with key or ref \");\n\n  if (noProperMetaSchema) {\n    errors = [].concat(_toConsumableArray(errors), [{\n      stack: validationError.message\n    }]);\n  }\n\n  if (typeof transformErrors === \"function\") {\n    errors = transformErrors(errors);\n  }\n\n  var errorSchema = toErrorSchema(errors);\n\n  if (noProperMetaSchema) {\n    errorSchema = _objectSpread({}, errorSchema, {\n      $schema: {\n        __errors: [validationError.message]\n      }\n    });\n  }\n\n  if (typeof customValidate !== \"function\") {\n    return {\n      errors: errors,\n      errorSchema: errorSchema\n    };\n  }\n\n  var errorHandler = customValidate(formData, createErrorHandler(formData));\n  var userErrorSchema = unwrapErrorHandler(errorHandler);\n  var newErrorSchema = mergeObjects(errorSchema, userErrorSchema, true); // XXX: The errors list produced is not fully compliant with the format\n  // exposed by the jsonschema lib, which contains full field paths and other\n  // properties.\n\n  var newErrors = toErrorList(newErrorSchema);\n  return {\n    errors: newErrors,\n    errorSchema: newErrorSchema\n  };\n}\n/**\n * Validates data against a schema, returning true if the data is valid, or\n * false otherwise. If the schema is invalid, then this function will return\n * false.\n */\n\nexport function isValid(schema, data) {\n  try {\n    return ajv.validate(schema, data);\n  } catch (e) {\n    return false;\n  }\n}"]},"metadata":{},"sourceType":"module"}