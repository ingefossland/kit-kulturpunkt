{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nvar spacer = function (times, tabStop) {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nfunction isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n}\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nfunction isObjectObject(o) {\n  return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor, prot;\n  if (isObjectObject(o) === false) return false; // If has modified constructor\n\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false; // If has modified prototype\n\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false; // If constructor does not have an Object-specific method\n\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar dist = createCommonjsModule(function (module, exports) {\n  var __assign = commonjsGlobal && commonjsGlobal.__assign || function () {\n    __assign = Object.assign || function (t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n\n      return t;\n    };\n\n    return __assign.apply(this, arguments);\n  };\n\n  var __spreadArrays = commonjsGlobal && commonjsGlobal.__spreadArrays || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n    for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n    return r;\n  };\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  var seen = [];\n  /**\n   * Check if a value is an object or a function. Keep in mind that array, function, regexp, etc, are objects in JavaScript.\n   *\n   * @param value the value to check\n   * @return true if the value is an object or a function\n   */\n\n  function isObj(value) {\n    var type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n  }\n  /**\n   * Check if a value is a regular expression.\n   *\n   * @param value the value to check\n   * @return true if the value is a regular expression\n   */\n\n\n  function isRegexp(value) {\n    return Object.prototype.toString.call(value) === '[object RegExp]';\n  }\n  /**\n   * Get an array of all of the enumerable symbols for an object.\n   *\n   * @param object the object to get the enumerable symbols for\n   */\n\n\n  function getOwnEnumPropSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(function (keySymbol) {\n      return Object.prototype.propertyIsEnumerable.call(object, keySymbol);\n    });\n  }\n  /**\n   * pretty print an object\n   *\n   * @param input the object to pretty print\n   * @param options the formatting options, transforms, and filters\n   * @param pad the padding string\n   */\n\n\n  function prettyPrint(input, options, pad) {\n    if (pad === void 0) {\n      pad = '';\n    } // sensible option defaults\n\n\n    var defaultOptions = {\n      indent: '\\t',\n      singleQuotes: true\n    };\n\n    var combinedOptions = __assign(__assign({}, defaultOptions), options);\n\n    var tokens;\n\n    if (combinedOptions.inlineCharacterLimit === undefined) {\n      tokens = {\n        newLine: '\\n',\n        newLineOrSpace: '\\n',\n        pad: pad,\n        indent: pad + combinedOptions.indent\n      };\n    } else {\n      tokens = {\n        newLine: '@@__PRETTY_PRINT_NEW_LINE__@@',\n        newLineOrSpace: '@@__PRETTY_PRINT_NEW_LINE_OR_SPACE__@@',\n        pad: '@@__PRETTY_PRINT_PAD__@@',\n        indent: '@@__PRETTY_PRINT_INDENT__@@'\n      };\n    }\n\n    var expandWhiteSpace = function (string) {\n      if (combinedOptions.inlineCharacterLimit === undefined) {\n        return string;\n      }\n\n      var oneLined = string.replace(new RegExp(tokens.newLine, 'g'), '').replace(new RegExp(tokens.newLineOrSpace, 'g'), ' ').replace(new RegExp(tokens.pad + '|' + tokens.indent, 'g'), '');\n\n      if (oneLined.length <= combinedOptions.inlineCharacterLimit) {\n        return oneLined;\n      }\n\n      return string.replace(new RegExp(tokens.newLine + '|' + tokens.newLineOrSpace, 'g'), '\\n').replace(new RegExp(tokens.pad, 'g'), pad).replace(new RegExp(tokens.indent, 'g'), pad + combinedOptions.indent);\n    };\n\n    if (seen.indexOf(input) !== -1) {\n      return '\"[Circular]\"';\n    }\n\n    if (input === null || input === undefined || typeof input === 'number' || typeof input === 'boolean' || typeof input === 'function' || typeof input === 'symbol' || isRegexp(input)) {\n      return String(input);\n    }\n\n    if (input instanceof Date) {\n      return \"new Date('\" + input.toISOString() + \"')\";\n    }\n\n    if (Array.isArray(input)) {\n      if (input.length === 0) {\n        return '[]';\n      }\n\n      seen.push(input);\n      var ret = '[' + tokens.newLine + input.map(function (el, i) {\n        var eol = input.length - 1 === i ? tokens.newLine : ',' + tokens.newLineOrSpace;\n        var value = prettyPrint(el, combinedOptions, pad + combinedOptions.indent);\n\n        if (combinedOptions.transform) {\n          value = combinedOptions.transform(input, i, value);\n        }\n\n        return tokens.indent + value + eol;\n      }).join('') + tokens.pad + ']';\n      seen.pop();\n      return expandWhiteSpace(ret);\n    }\n\n    if (isObj(input)) {\n      var objKeys_1 = __spreadArrays(Object.keys(input), getOwnEnumPropSymbols(input));\n\n      if (combinedOptions.filter) {\n        objKeys_1 = objKeys_1.filter(function (el) {\n          return combinedOptions.filter && combinedOptions.filter(input, el);\n        });\n      }\n\n      if (objKeys_1.length === 0) {\n        return '{}';\n      }\n\n      seen.push(input);\n      var ret = '{' + tokens.newLine + objKeys_1.map(function (el, i) {\n        var eol = objKeys_1.length - 1 === i ? tokens.newLine : ',' + tokens.newLineOrSpace;\n        var isSymbol = typeof el === 'symbol';\n        var isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el.toString());\n        var key = isSymbol || isClassic ? el : prettyPrint(el, combinedOptions);\n        var value = prettyPrint(input[el], combinedOptions, pad + combinedOptions.indent);\n\n        if (combinedOptions.transform) {\n          value = combinedOptions.transform(input, el, value);\n        }\n\n        return tokens.indent + String(key) + ': ' + value + eol;\n      }).join('') + tokens.pad + '}';\n      seen.pop();\n      return expandWhiteSpace(ret);\n    }\n\n    input = String(input).replace(/[\\r\\n]/g, function (x) {\n      return x === '\\n' ? '\\\\n' : '\\\\r';\n    });\n\n    if (!combinedOptions.singleQuotes) {\n      input = input.replace(/\"/g, '\\\\\"');\n      return \"\\\"\" + input + \"\\\"\";\n    }\n\n    input = input.replace(/\\\\?'/g, '\\\\\\'');\n    return \"'\" + input + \"'\";\n  }\n\n  exports.prettyPrint = prettyPrint;\n});\nunwrapExports(dist);\nvar dist_1 = dist.prettyPrint;\n\nfunction sortObject(value) {\n  // return non-object value as is\n  if (value === null || _typeof(value) !== 'object') {\n    return value;\n  } // return date and regexp values as is\n\n\n  if (value instanceof Date || value instanceof RegExp) {\n    return value;\n  } // make a copy of array with each item passed through sortObject()\n\n\n  if (Array.isArray(value)) {\n    return value.map(sortObject);\n  } // make a copy of object with key sorted\n\n\n  return Object.keys(value).sort().reduce(function (result, key) {\n    if (key === '_owner') {\n      return result;\n    }\n\n    if (key === 'current') {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = '[Circular]';\n    } else {\n      // eslint-disable-next-line no-param-reassign\n      result[key] = sortObject(value[key]);\n    }\n\n    return result;\n  }, {});\n}\n/* eslint-disable no-use-before-define */\n\n\nvar createStringTreeNode = function createStringTreeNode(value) {\n  return {\n    type: 'string',\n    value: value\n  };\n};\n\nvar createNumberTreeNode = function createNumberTreeNode(value) {\n  return {\n    type: 'number',\n    value: value\n  };\n};\n\nvar createReactElementTreeNode = function createReactElementTreeNode(displayName, props, defaultProps, childrens) {\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: defaultProps,\n    childrens: childrens\n  };\n};\n\nvar createReactFragmentTreeNode = function createReactFragmentTreeNode(key, childrens) {\n  return {\n    type: 'ReactFragment',\n    key: key,\n    childrens: childrens\n  };\n};\n\nvar supportFragment = Boolean(React.Fragment);\n\nvar getReactElementDisplayName = function getReactElementDisplayName(element) {\n  return element.type.displayName || (element.type.name !== '_default' ? element.type.name : null) || ( // function name\n  typeof element.type === 'function' // function without a name, you should provide one\n  ? 'No Display Name' : element.type);\n};\n\nvar noChildren = function noChildren(propsValue, propName) {\n  return propName !== 'children';\n};\n\nvar onlyMeaningfulChildren = function onlyMeaningfulChildren(children) {\n  return children !== true && children !== false && children !== null && children !== '';\n};\n\nvar filterProps = function filterProps(originalProps, cb) {\n  var filteredProps = {};\n  Object.keys(originalProps).filter(function (key) {\n    return cb(originalProps[key], key);\n  }).forEach(function (key) {\n    return filteredProps[key] = originalProps[key];\n  });\n  return filteredProps;\n};\n\nvar parseReactElement = function parseReactElement(element, options) {\n  var _options$displayName = options.displayName,\n      displayNameFn = _options$displayName === void 0 ? getReactElementDisplayName : _options$displayName;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (! /*#__PURE__*/React__default.isValidElement(element)) {\n    throw new Error(\"react-element-to-jsx-string: Expected a React.Element, got `\".concat(_typeof(element), \"`\"));\n  }\n\n  var displayName = displayNameFn(element);\n  var props = filterProps(element.props, noChildren);\n\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  var key = element.key;\n\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  var childrens = React__default.Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function (child) {\n    return parseReactElement(child, options);\n  });\n\n  if (supportFragment && element.type === React.Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(displayName, props, defaultProps, childrens);\n};\n\nfunction noRefCheck() {}\n\nvar inlineFunction = function inlineFunction(fn) {\n  return fn.toString().split('\\n').map(function (line) {\n    return line.trim();\n  }).join('');\n};\n\nvar preserveFunctionLineBreak = function preserveFunctionLineBreak(fn) {\n  return fn.toString();\n};\n\nvar defaultFunctionValue = inlineFunction;\n\nvar formatFunction = function (fn, options) {\n  var _options$functionValu = options.functionValue,\n      functionValue = _options$functionValu === void 0 ? defaultFunctionValue : _options$functionValu,\n      showFunctions = options.showFunctions;\n\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n\nvar formatComplexDataStructure = function (value, inline, lvl, options) {\n  var normalizedValue = sortObject(value);\n  var stringifiedValue = dist_1(normalizedValue, {\n    transform: function transform(currentObj, prop, originalResult) {\n      var currentValue = currentObj[prop];\n\n      if (currentValue && /*#__PURE__*/React.isValidElement(currentValue)) {\n        return formatTreeNode(parseReactElement(currentValue, options), true, lvl, options);\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    }\n  });\n\n  if (inline) {\n    return stringifiedValue.replace(/\\s+/g, ' ').replace(/{ /g, '{').replace(/ }/g, '}').replace(/\\[ /g, '[').replace(/ ]/g, ']');\n  } // Replace tabs with spaces, and add necessary indentation in front of each new line\n\n\n  return stringifiedValue.replace(/\\t/g, spacer(1, options.tabStop)).replace(/\\n([^$])/g, \"\\n\".concat(spacer(lvl + 1, options.tabStop), \"$1\"));\n};\n\nvar escape = function escape(s) {\n  return s.replace(/\"/g, '&quot;');\n};\n\nvar formatPropValue = function formatPropValue(propValue, inline, lvl, options) {\n  if (typeof propValue === 'number') {\n    return \"{\".concat(String(propValue), \"}\");\n  }\n\n  if (typeof propValue === 'string') {\n    return \"\\\"\".concat(escape(propValue), \"\\\"\");\n  } // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n\n\n  if (_typeof(propValue) === 'symbol') {\n    var symbolDescription = propValue.valueOf().toString().replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return \"{Symbol()}\";\n    }\n\n    return \"{Symbol('\".concat(symbolDescription, \"')}\");\n  }\n\n  if (typeof propValue === 'function') {\n    return \"{\".concat(formatFunction(propValue, options), \"}\");\n  }\n\n  if ( /*#__PURE__*/React.isValidElement(propValue)) {\n    return \"{\".concat(formatTreeNode(parseReactElement(propValue, options), true, lvl, options), \"}\");\n  }\n\n  if (propValue instanceof Date) {\n    return \"{new Date(\\\"\".concat(propValue.toISOString(), \"\\\")}\");\n  }\n\n  if (isPlainObject(propValue) || Array.isArray(propValue)) {\n    return \"{\".concat(formatComplexDataStructure(propValue, inline, lvl, options), \"}\");\n  }\n\n  return \"{\".concat(String(propValue), \"}\");\n};\n\nvar formatProp = function (name, hasValue, value, hasDefaultValue, defaultValue, inline, lvl, options) {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\"The prop \\\"\".concat(name, \"\\\" has no value and no default: could not be formatted\"));\n  }\n\n  var usedValue = hasValue ? value : defaultValue;\n  var useBooleanShorthandSyntax = options.useBooleanShorthandSyntax,\n      tabStop = options.tabStop;\n  var formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n  var attributeFormattedInline = ' ';\n  var attributeFormattedMultiline = \"\\n\".concat(spacer(lvl + 1, tabStop));\n  var isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (useBooleanShorthandSyntax && formattedPropValue === '{false}' && !hasDefaultValue) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += \"\".concat(name);\n    attributeFormattedMultiline += \"\".concat(name);\n  } else {\n    attributeFormattedInline += \"\".concat(name, \"=\").concat(formattedPropValue);\n    attributeFormattedMultiline += \"\".concat(name, \"=\").concat(formattedPropValue);\n  }\n\n  return {\n    attributeFormattedInline: attributeFormattedInline,\n    attributeFormattedMultiline: attributeFormattedMultiline,\n    isMultilineAttribute: isMultilineAttribute\n  };\n};\n\nvar mergeSiblingPlainStringChildrenReducer = function (previousNodes, currentNode) {\n  var nodes = previousNodes.slice(0, previousNodes.length > 0 ? previousNodes.length - 1 : 0);\n  var previousNode = previousNodes[previousNodes.length - 1];\n\n  if (previousNode && (currentNode.type === 'string' || currentNode.type === 'number') && (previousNode.type === 'string' || previousNode.type === 'number')) {\n    nodes.push(createStringTreeNode(String(previousNode.value) + String(currentNode.value)));\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n\nvar isKeyOrRefProps = function isKeyOrRefProps(propName) {\n  return ['key', 'ref'].includes(propName);\n};\n\nvar sortPropsByNames = function (shouldSortUserProps) {\n  return function (props) {\n    var haveKeyProp = props.includes('key');\n    var haveRefProp = props.includes('ref');\n    var userPropsOnly = props.filter(function (oneProp) {\n      return !isKeyOrRefProps(oneProp);\n    });\n    var sortedProps = shouldSortUserProps ? _toConsumableArray(userPropsOnly.sort()) // We use basic lexical order\n    : _toConsumableArray(userPropsOnly);\n\n    if (haveRefProp) {\n      sortedProps.unshift('ref');\n    }\n\n    if (haveKeyProp) {\n      sortedProps.unshift('key');\n    }\n\n    return sortedProps;\n  };\n};\n\nfunction createPropFilter(props, filter) {\n  if (Array.isArray(filter)) {\n    return function (key) {\n      return filter.indexOf(key) === -1;\n    };\n  } else {\n    return function (key) {\n      return filter(props[key], key);\n    };\n  }\n}\n\nvar compensateMultilineStringElementIndentation = function compensateMultilineStringElementIndentation(element, formattedElement, inline, lvl, options) {\n  var tabStop = options.tabStop;\n\n  if (element.type === 'string') {\n    return formattedElement.split('\\n').map(function (line, offset) {\n      if (offset === 0) {\n        return line;\n      }\n\n      return \"\".concat(spacer(lvl, tabStop)).concat(line);\n    }).join('\\n');\n  }\n\n  return formattedElement;\n};\n\nvar formatOneChildren = function formatOneChildren(inline, lvl, options) {\n  return function (element) {\n    return compensateMultilineStringElementIndentation(element, formatTreeNode(element, inline, lvl, options), inline, lvl, options);\n  };\n};\n\nvar onlyPropsWithOriginalValue = function onlyPropsWithOriginalValue(defaultProps, props) {\n  return function (propName) {\n    var haveDefaultValue = Object.keys(defaultProps).includes(propName);\n    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];\n  };\n};\n\nvar isInlineAttributeTooLong = function isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return spacer(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength;\n};\n\nvar shouldRenderMultilineAttr = function shouldRenderMultilineAttr(attributes, inlineAttributeString, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength) {\n  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline;\n};\n\nvar formatReactElementNode = function (node, inline, lvl, options) {\n  var type = node.type,\n      _node$displayName = node.displayName,\n      displayName = _node$displayName === void 0 ? '' : _node$displayName,\n      childrens = node.childrens,\n      _node$props = node.props,\n      props = _node$props === void 0 ? {} : _node$props,\n      _node$defaultProps = node.defaultProps,\n      defaultProps = _node$defaultProps === void 0 ? {} : _node$defaultProps;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\"The \\\"formatReactElementNode\\\" function could only format node of type \\\"ReactElement\\\". Given:  \".concat(type));\n  }\n\n  var filterProps = options.filterProps,\n      maxInlineAttributesLineLength = options.maxInlineAttributesLineLength,\n      showDefaultProps = options.showDefaultProps,\n      sortProps = options.sortProps,\n      tabStop = options.tabStop;\n  var out = \"<\".concat(displayName);\n  var outInlineAttr = out;\n  var outMultilineAttr = out;\n  var containsMultilineAttr = false;\n  var visibleAttributeNames = [];\n  var propFilter = createPropFilter(props, filterProps);\n  Object.keys(props).filter(propFilter).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function (propName) {\n    return visibleAttributeNames.push(propName);\n  });\n  Object.keys(defaultProps).filter(propFilter).filter(function () {\n    return showDefaultProps;\n  }).filter(function (defaultPropName) {\n    return !visibleAttributeNames.includes(defaultPropName);\n  }).forEach(function (defaultPropName) {\n    return visibleAttributeNames.push(defaultPropName);\n  });\n  var attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n  attributes.forEach(function (attributeName) {\n    var _formatProp = formatProp(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline, lvl, options),\n        attributeFormattedInline = _formatProp.attributeFormattedInline,\n        attributeFormattedMultiline = _formatProp.attributeFormattedMultiline,\n        isMultilineAttribute = _formatProp.isMultilineAttribute;\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n  outMultilineAttr += \"\\n\".concat(spacer(lvl, tabStop));\n\n  if (shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength)) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    var newLvl = lvl + 1;\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens.reduce(mergeSiblingPlainStringChildrenReducer, []).map(formatOneChildren(inline, newLvl, options)).join(!inline ? \"\\n\".concat(spacer(newLvl, tabStop)) : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n\n    out += \"</\".concat(displayName, \">\");\n  } else {\n    if (!isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength)) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n\nvar REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nvar REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nvar toReactElementTreeNode = function toReactElementTreeNode(displayName, key, childrens) {\n  var props = {};\n\n  if (key) {\n    props = {\n      key: key\n    };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName: displayName,\n    props: props,\n    defaultProps: {},\n    childrens: childrens\n  };\n};\n\nvar isKeyedFragment = function isKeyedFragment(_ref) {\n  var key = _ref.key;\n  return Boolean(key);\n};\n\nvar hasNoChildren = function hasNoChildren(_ref2) {\n  var childrens = _ref2.childrens;\n  return childrens.length === 0;\n};\n\nvar formatReactFragmentNode = function (node, inline, lvl, options) {\n  var type = node.type,\n      key = node.key,\n      childrens = node.childrens;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\"The \\\"formatReactFragmentNode\\\" function could only format node of type \\\"ReactFragment\\\". Given: \".concat(type));\n  }\n\n  var useFragmentShortSyntax = options.useFragmentShortSyntax;\n  var displayName;\n\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(toReactElementTreeNode(displayName, key, childrens), inline, lvl, options);\n};\n\nvar jsxStopChars = ['<', '>', '{', '}'];\n\nvar shouldBeEscaped = function shouldBeEscaped(s) {\n  return jsxStopChars.some(function (jsxStopChar) {\n    return s.includes(jsxStopChar);\n  });\n};\n\nvar escape$1 = function escape(s) {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return \"{`\".concat(s, \"`}\");\n};\n\nvar preserveTrailingSpace = function preserveTrailingSpace(s) {\n  var result = s;\n\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nvar formatTreeNode = function (node, inline, lvl, options) {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value ? \"\".concat(preserveTrailingSpace(escape$1(String(node.value)))) : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(\"Unknow format type \\\"\".concat(node.type, \"\\\"\"));\n};\n\nvar formatTree = function (node, options) {\n  return formatTreeNode(node, false, 0, options);\n};\n\nvar reactElementToJsxString = function reactElementToJsxString(element) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$filterProps = _ref.filterProps,\n      filterProps = _ref$filterProps === void 0 ? [] : _ref$filterProps,\n      _ref$showDefaultProps = _ref.showDefaultProps,\n      showDefaultProps = _ref$showDefaultProps === void 0 ? true : _ref$showDefaultProps,\n      _ref$showFunctions = _ref.showFunctions,\n      showFunctions = _ref$showFunctions === void 0 ? false : _ref$showFunctions,\n      functionValue = _ref.functionValue,\n      _ref$tabStop = _ref.tabStop,\n      tabStop = _ref$tabStop === void 0 ? 2 : _ref$tabStop,\n      _ref$useBooleanShorth = _ref.useBooleanShorthandSyntax,\n      useBooleanShorthandSyntax = _ref$useBooleanShorth === void 0 ? true : _ref$useBooleanShorth,\n      _ref$useFragmentShort = _ref.useFragmentShortSyntax,\n      useFragmentShortSyntax = _ref$useFragmentShort === void 0 ? true : _ref$useFragmentShort,\n      _ref$sortProps = _ref.sortProps,\n      sortProps = _ref$sortProps === void 0 ? true : _ref$sortProps,\n      maxInlineAttributesLineLength = _ref.maxInlineAttributesLineLength,\n      displayName = _ref.displayName;\n\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  var options = {\n    filterProps: filterProps,\n    showDefaultProps: showDefaultProps,\n    showFunctions: showFunctions,\n    functionValue: functionValue,\n    tabStop: tabStop,\n    useBooleanShorthandSyntax: useBooleanShorthandSyntax,\n    useFragmentShortSyntax: useFragmentShortSyntax,\n    sortProps: sortProps,\n    maxInlineAttributesLineLength: maxInlineAttributesLineLength,\n    displayName: displayName\n  };\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexports.default = reactElementToJsxString;\nexports.inlineFunction = inlineFunction;\nexports.preserveFunctionLineBreak = preserveFunctionLineBreak;","map":{"version":3,"sources":["../../src/formatter/spacer.js","../../node_modules/is-plain-object/index.es.js","../../node_modules/@base2/pretty-print-object/dist/index.js","../../src/formatter/sortObject.js","../../src/tree.js","../../src/parser/parseReactElement.js","../../src/formatter/formatFunction.js","../../src/formatter/formatComplexDataStructure.js","../../src/formatter/formatPropValue.js","../../src/formatter/formatProp.js","../../src/formatter/mergeSiblingPlainStringChildrenReducer.js","../../src/formatter/sortPropsByNames.js","../../src/formatter/createPropFilter.js","../../src/formatter/formatReactElementNode.js","../../src/formatter/formatReactFragmentNode.js","../../src/formatter/formatTreeNode.js","../../src/formatter/formatTree.js","../../src/index.js"],"names":["times","this","value","Array","key","result","sortObject","createStringTreeNode","type","createNumberTreeNode","createReactElementTreeNode","displayName","props","defaultProps","childrens","createReactFragmentTreeNode","supportFragment","Boolean","Fragment","getReactElementDisplayName","element","noChildren","propName","onlyMeaningfulChildren","children","filterProps","filteredProps","Object","cb","originalProps","parseReactElement","displayNameFn","options","React","inlineFunction","line","preserveFunctionLineBreak","fn","defaultFunctionValue","functionValue","showFunctions","normalizedValue","stringifiedValue","prettyPrint","transform","currentValue","currentObj","isValidElement","formatTreeNode","formatFunction","spacer","lvl","escape","s","formatPropValue","String","symbolDescription","propValue","isPlainObject","formatComplexDataStructure","usedValue","hasValue","useBooleanShorthandSyntax","tabStop","formattedPropValue","attributeFormattedInline","attributeFormattedMultiline","isMultilineAttribute","nodes","previousNodes","previousNode","currentNode","isKeyOrRefProps","haveKeyProp","haveRefProp","userPropsOnly","sortedProps","shouldSortUserProps","filter","compensateMultilineStringElementIndentation","offset","formatOneChildren","onlyPropsWithOriginalValue","haveDefaultValue","isInlineAttributeTooLong","attributes","inlineAttributeString","shouldRenderMultilineAttr","node","maxInlineAttributesLineLength","showDefaultProps","sortProps","out","outInlineAttr","outMultilineAttr","containsMultilineAttr","visibleAttributeNames","propFilter","createPropFilter","sortPropsByNames","formatProp","newLvl","REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX","REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX","toReactElementTreeNode","isKeyedFragment","hasNoChildren","useFragmentShortSyntax","formatReactElementNode","jsxStopChars","shouldBeEscaped","preserveTrailingSpace","formatReactFragmentNode","reactElementToJsxString","formatTree"],"mappings":"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","sourcesContent":["/* @flow */\n\nexport default (times: number, tabStop: number): string => {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n}\n\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport default isPlainObject;\n","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar seen = [];\n/**\n * Check if a value is an object or a function. Keep in mind that array, function, regexp, etc, are objects in JavaScript.\n *\n * @param value the value to check\n * @return true if the value is an object or a function\n */\nfunction isObj(value) {\n    var type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\n/**\n * Check if a value is a regular expression.\n *\n * @param value the value to check\n * @return true if the value is a regular expression\n */\nfunction isRegexp(value) {\n    return Object.prototype.toString.call(value) === '[object RegExp]';\n}\n/**\n * Get an array of all of the enumerable symbols for an object.\n *\n * @param object the object to get the enumerable symbols for\n */\nfunction getOwnEnumPropSymbols(object) {\n    return Object.getOwnPropertySymbols(object).filter(function (keySymbol) { return Object.prototype.propertyIsEnumerable.call(object, keySymbol); });\n}\n/**\n * pretty print an object\n *\n * @param input the object to pretty print\n * @param options the formatting options, transforms, and filters\n * @param pad the padding string\n */\nfunction prettyPrint(input, options, pad) {\n    if (pad === void 0) { pad = ''; }\n    // sensible option defaults\n    var defaultOptions = {\n        indent: '\\t',\n        singleQuotes: true\n    };\n    var combinedOptions = __assign(__assign({}, defaultOptions), options);\n    var tokens;\n    if (combinedOptions.inlineCharacterLimit === undefined) {\n        tokens = {\n            newLine: '\\n',\n            newLineOrSpace: '\\n',\n            pad: pad,\n            indent: pad + combinedOptions.indent\n        };\n    }\n    else {\n        tokens = {\n            newLine: '@@__PRETTY_PRINT_NEW_LINE__@@',\n            newLineOrSpace: '@@__PRETTY_PRINT_NEW_LINE_OR_SPACE__@@',\n            pad: '@@__PRETTY_PRINT_PAD__@@',\n            indent: '@@__PRETTY_PRINT_INDENT__@@'\n        };\n    }\n    var expandWhiteSpace = function (string) {\n        if (combinedOptions.inlineCharacterLimit === undefined) {\n            return string;\n        }\n        var oneLined = string\n            .replace(new RegExp(tokens.newLine, 'g'), '')\n            .replace(new RegExp(tokens.newLineOrSpace, 'g'), ' ')\n            .replace(new RegExp(tokens.pad + '|' + tokens.indent, 'g'), '');\n        if (oneLined.length <= combinedOptions.inlineCharacterLimit) {\n            return oneLined;\n        }\n        return string\n            .replace(new RegExp(tokens.newLine + '|' + tokens.newLineOrSpace, 'g'), '\\n')\n            .replace(new RegExp(tokens.pad, 'g'), pad)\n            .replace(new RegExp(tokens.indent, 'g'), pad + combinedOptions.indent);\n    };\n    if (seen.indexOf(input) !== -1) {\n        return '\"[Circular]\"';\n    }\n    if (input === null ||\n        input === undefined ||\n        typeof input === 'number' ||\n        typeof input === 'boolean' ||\n        typeof input === 'function' ||\n        typeof input === 'symbol' ||\n        isRegexp(input)) {\n        return String(input);\n    }\n    if (input instanceof Date) {\n        return \"new Date('\" + input.toISOString() + \"')\";\n    }\n    if (Array.isArray(input)) {\n        if (input.length === 0) {\n            return '[]';\n        }\n        seen.push(input);\n        var ret = '[' + tokens.newLine + input.map(function (el, i) {\n            var eol = input.length - 1 === i ? tokens.newLine : ',' + tokens.newLineOrSpace;\n            var value = prettyPrint(el, combinedOptions, pad + combinedOptions.indent);\n            if (combinedOptions.transform) {\n                value = combinedOptions.transform(input, i, value);\n            }\n            return tokens.indent + value + eol;\n        }).join('') + tokens.pad + ']';\n        seen.pop();\n        return expandWhiteSpace(ret);\n    }\n    if (isObj(input)) {\n        var objKeys_1 = __spreadArrays(Object.keys(input), (getOwnEnumPropSymbols(input)));\n        if (combinedOptions.filter) {\n            objKeys_1 = objKeys_1.filter(function (el) { return combinedOptions.filter && combinedOptions.filter(input, el); });\n        }\n        if (objKeys_1.length === 0) {\n            return '{}';\n        }\n        seen.push(input);\n        var ret = '{' + tokens.newLine + objKeys_1.map(function (el, i) {\n            var eol = objKeys_1.length - 1 === i ? tokens.newLine : ',' + tokens.newLineOrSpace;\n            var isSymbol = typeof el === 'symbol';\n            var isClassic = !isSymbol && /^[a-z$_][a-z$_0-9]*$/i.test(el.toString());\n            var key = isSymbol || isClassic ? el : prettyPrint(el, combinedOptions);\n            var value = prettyPrint(input[el], combinedOptions, pad + combinedOptions.indent);\n            if (combinedOptions.transform) {\n                value = combinedOptions.transform(input, el, value);\n            }\n            return tokens.indent + String(key) + ': ' + value + eol;\n        }).join('') + tokens.pad + '}';\n        seen.pop();\n        return expandWhiteSpace(ret);\n    }\n    input = String(input).replace(/[\\r\\n]/g, function (x) { return x === '\\n' ? '\\\\n' : '\\\\r'; });\n    if (!combinedOptions.singleQuotes) {\n        input = input.replace(/\"/g, '\\\\\"');\n        return \"\\\"\" + input + \"\\\"\";\n    }\n    input = input.replace(/\\\\?'/g, '\\\\\\'');\n    return \"'\" + input + \"'\";\n}\nexports.prettyPrint = prettyPrint;\n//# sourceMappingURL=index.js.map","/* @flow */\n\nexport default function sortObject(value: any): any {\n  // return non-object value as is\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // return date and regexp values as is\n  if (value instanceof Date || value instanceof RegExp) {\n    return value;\n  }\n\n  // make a copy of array with each item passed through sortObject()\n  if (Array.isArray(value)) {\n    return value.map(sortObject);\n  }\n\n  // make a copy of object with key sorted\n  return Object.keys(value)\n    .sort()\n    .reduce((result, key) => {\n      if (key === '_owner') {\n        return result;\n      }\n      if (key === 'current') {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = '[Circular]';\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = sortObject(value[key]);\n      }\n      return result;\n    }, {});\n}\n","/* @flow */\n/* eslint-disable no-use-before-define */\n\nimport type { Key } from 'react';\n\ntype PropsType = { [key: string]: any };\ntype DefaultPropsType = { [key: string]: any };\n\nexport type StringTreeNode = {|\n  type: 'string',\n  value: string,\n|};\n\nexport type NumberTreeNode = {|\n  type: 'number',\n  value: number,\n|};\n\nexport type ReactElementTreeNode = {|\n  type: 'ReactElement',\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[],\n|};\n\nexport type ReactFragmentTreeNode = {|\n  type: 'ReactFragment',\n  key: ?Key,\n  childrens: TreeNode[],\n|};\n\nexport type TreeNode =\n  | StringTreeNode\n  | NumberTreeNode\n  | ReactElementTreeNode\n  | ReactFragmentTreeNode;\n\nexport const createStringTreeNode = (value: string): StringTreeNode => ({\n  type: 'string',\n  value,\n});\n\nexport const createNumberTreeNode = (value: number): NumberTreeNode => ({\n  type: 'number',\n  value,\n});\n\nexport const createReactElementTreeNode = (\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[]\n): ReactElementTreeNode => ({\n  type: 'ReactElement',\n  displayName,\n  props,\n  defaultProps,\n  childrens,\n});\n\nexport const createReactFragmentTreeNode = (\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactFragmentTreeNode => ({\n  type: 'ReactFragment',\n  key,\n  childrens,\n});\n","/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getReactElementDisplayName = (element: ReactElement<*>): string =>\n  element.type.displayName ||\n  (element.type.name !== '_default' ? element.type.name : null) || // function name\n  (typeof element.type === 'function' // function without a name, you should provide one\n    ? 'No Display Name'\n    : element.type);\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n","import type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nexport const inlineFunction = (fn: any): string =>\n  fn\n    .toString()\n    .split('\\n')\n    .map(line => line.trim())\n    .join('');\n\nexport const preserveFunctionLineBreak = (fn: any): string => fn.toString();\n\nconst defaultFunctionValue = inlineFunction;\n\nexport default (fn: Function, options: Options): string => {\n  const { functionValue = defaultFunctionValue, showFunctions } = options;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n","/* @flow */\n\nimport { isValidElement } from 'react';\nimport { prettyPrint } from '@base2/pretty-print-object';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport formatFunction from './formatFunction';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = prettyPrint(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n","/* @flow */\n\nimport isPlainObject from 'is-plain-object';\nimport { isValidElement } from 'react';\nimport formatComplexDataStructure from './formatComplexDataStructure';\nimport formatFunction from './formatFunction';\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport parseReactElement from './../parser/parseReactElement';\n\nconst escape = (s: string): string => s.replace(/\"/g, '&quot;');\n\nconst formatPropValue = (\n  propValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (typeof propValue === 'number') {\n    return `{${String(propValue)}}`;\n  }\n\n  if (typeof propValue === 'string') {\n    return `\"${escape(propValue)}\"`;\n  }\n\n  // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n  if (typeof propValue === 'symbol') {\n    const symbolDescription = propValue\n      .valueOf()\n      .toString()\n      .replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return `{Symbol()}`;\n    }\n\n    return `{Symbol('${symbolDescription}')}`;\n  }\n\n  if (typeof propValue === 'function') {\n    return `{${formatFunction(propValue, options)}}`;\n  }\n\n  if (isValidElement(propValue)) {\n    return `{${formatTreeNode(\n      parseReactElement(propValue, options),\n      true,\n      lvl,\n      options\n    )}}`;\n  }\n\n  if (propValue instanceof Date) {\n    return `{new Date(\"${propValue.toISOString()}\")}`;\n  }\n\n  if (isPlainObject(propValue) || Array.isArray(propValue)) {\n    return `{${formatComplexDataStructure(propValue, inline, lvl, options)}}`;\n  }\n\n  return `{${String(propValue)}}`;\n};\n\nexport default formatPropValue;\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatPropValue from './formatPropValue';\nimport type { Options } from './../options';\n\nexport default (\n  name: string,\n  hasValue: boolean,\n  value: any,\n  hasDefaultValue: boolean,\n  defaultValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): {\n  attributeFormattedInline: string,\n  attributeFormattedMultiline: string,\n  isMultilineAttribute: boolean,\n} => {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\n      `The prop \"${name}\" has no value and no default: could not be formatted`\n    );\n  }\n\n  const usedValue = hasValue ? value : defaultValue;\n\n  const { useBooleanShorthandSyntax, tabStop } = options;\n\n  const formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n\n  let attributeFormattedInline = ' ';\n  let attributeFormattedMultiline = `\\n${spacer(lvl + 1, tabStop)}`;\n  const isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (\n    useBooleanShorthandSyntax &&\n    formattedPropValue === '{false}' &&\n    !hasDefaultValue\n  ) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += `${name}`;\n    attributeFormattedMultiline += `${name}`;\n  } else {\n    attributeFormattedInline += `${name}=${formattedPropValue}`;\n    attributeFormattedMultiline += `${name}=${formattedPropValue}`;\n  }\n\n  return {\n    attributeFormattedInline,\n    attributeFormattedMultiline,\n    isMultilineAttribute,\n  };\n};\n","/* @flow */\n\nimport { createStringTreeNode } from './../tree';\nimport type { TreeNode } from './../tree';\n\nexport default (\n  previousNodes: TreeNode[],\n  currentNode: TreeNode\n): TreeNode[] => {\n  const nodes = previousNodes.slice(\n    0,\n    previousNodes.length > 0 ? previousNodes.length - 1 : 0\n  );\n  const previousNode = previousNodes[previousNodes.length - 1];\n\n  if (\n    previousNode &&\n    (currentNode.type === 'string' || currentNode.type === 'number') &&\n    (previousNode.type === 'string' || previousNode.type === 'number')\n  ) {\n    nodes.push(\n      createStringTreeNode(\n        String(previousNode.value) + String(currentNode.value)\n      )\n    );\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n","/* @flow */\n\nconst isKeyOrRefProps = (propName: string) => ['key', 'ref'].includes(propName);\n\nexport default (shouldSortUserProps: boolean) => (\n  props: string[]\n): string[] => {\n  const haveKeyProp = props.includes('key');\n  const haveRefProp = props.includes('ref');\n\n  const userPropsOnly = props.filter(oneProp => !isKeyOrRefProps(oneProp));\n\n  const sortedProps = shouldSortUserProps\n    ? [...userPropsOnly.sort()] // We use basic lexical order\n    : [...userPropsOnly];\n\n  if (haveRefProp) {\n    sortedProps.unshift('ref');\n  }\n\n  if (haveKeyProp) {\n    sortedProps.unshift('key');\n  }\n\n  return sortedProps;\n};\n","/* @flow */\n\nexport default function createPropFilter(\n  props: {},\n  filter: string[] | ((any, string) => boolean)\n) {\n  if (Array.isArray(filter)) {\n    return (key: string) => filter.indexOf(key) === -1;\n  } else {\n    return (key: string) => filter(props[key], key);\n  }\n}\n","/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport sortPropsByNames from './sortPropsByNames';\nimport createPropFilter from './createPropFilter';\nimport type { Options } from './../options';\nimport type { ReactElementTreeNode } from './../tree';\n\nconst compensateMultilineStringElementIndentation = (\n  element,\n  formattedElement: string,\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => {\n  const { tabStop } = options;\n\n  if (element.type === 'string') {\n    return formattedElement\n      .split('\\n')\n      .map((line, offset) => {\n        if (offset === 0) {\n          return line;\n        }\n\n        return `${spacer(lvl, tabStop)}${line}`;\n      })\n      .join('\\n');\n  }\n\n  return formattedElement;\n};\n\nconst formatOneChildren = (\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => element =>\n  compensateMultilineStringElementIndentation(\n    element,\n    formatTreeNode(element, inline, lvl, options),\n    inline,\n    lvl,\n    options\n  );\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: ReactElementTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens,\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${type}`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  const propFilter = createPropFilter(props, filterProps);\n\n  Object.keys(props)\n    .filter(propFilter)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(propFilter)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(formatOneChildren(inline, newLvl, options))\n      .join(!inline ? `\\n${spacer(newLvl, tabStop)}` : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n","/* @flow */\n\nimport type { Key } from 'react';\nimport formatReactElementNode from './formatReactElementNode';\nimport type { Options } from './../options';\nimport type {\n  ReactElementTreeNode,\n  ReactFragmentTreeNode,\n  TreeNode,\n} from './../tree';\n\nconst REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nconst REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nconst toReactElementTreeNode = (\n  displayName: string,\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactElementTreeNode => {\n  let props = {};\n  if (key) {\n    props = { key };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps: {},\n    childrens,\n  };\n};\n\nconst isKeyedFragment = ({ key }: ReactFragmentTreeNode) => Boolean(key);\nconst hasNoChildren = ({ childrens }: ReactFragmentTreeNode) =>\n  childrens.length === 0;\n\nexport default (\n  node: ReactFragmentTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const { type, key, childrens } = node;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\n      `The \"formatReactFragmentNode\" function could only format node of type \"ReactFragment\". Given: ${type}`\n    );\n  }\n\n  const { useFragmentShortSyntax } = options;\n\n  let displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(\n    toReactElementTreeNode(displayName, key, childrens),\n    inline,\n    lvl,\n    options\n  );\n};\n","/* @flow */\n\nimport formatReactElementNode from './formatReactElementNode';\nimport formatReactFragmentNode from './formatReactFragmentNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst jsxStopChars = ['<', '>', '{', '}'];\nconst shouldBeEscaped = (s: string) =>\n  jsxStopChars.some(jsxStopChar => s.includes(jsxStopChar));\n\nconst escape = (s: string) => {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return `{\\`${s}\\`}`;\n};\n\nconst preserveTrailingSpace = (s: string) => {\n  let result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value\n      ? `${preserveTrailingSpace(escape(String(node.value)))}`\n      : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(`Unknow format type \"${node.type}\"`);\n};\n","/* @flow */\n\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nexport default (node: TreeNode, options: Options): string =>\n  formatTreeNode(node, false, 0, options);\n","/* @flow */\n\nimport formatTree from './formatter/formatTree';\nimport parseReactElement from './parser/parseReactElement';\nimport type { Element as ReactElement } from 'react';\nimport type { Options } from './options';\n\nconst reactElementToJsxString = (\n  element: ReactElement<any>,\n  {\n    filterProps = [],\n    showDefaultProps = true,\n    showFunctions = false,\n    functionValue,\n    tabStop = 2,\n    useBooleanShorthandSyntax = true,\n    useFragmentShortSyntax = true,\n    sortProps = true,\n    maxInlineAttributesLineLength,\n    displayName,\n  }: Options = {}\n) => {\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  const options = {\n    filterProps,\n    showDefaultProps,\n    showFunctions,\n    functionValue,\n    tabStop,\n    useBooleanShorthandSyntax,\n    useFragmentShortSyntax,\n    sortProps,\n    maxInlineAttributesLineLength,\n    displayName,\n  };\n\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexport default reactElementToJsxString;\n\nexport {\n  inlineFunction,\n  preserveFunctionLineBreak,\n} from './formatter/formatFunction';\n"]},"metadata":{},"sourceType":"script"}