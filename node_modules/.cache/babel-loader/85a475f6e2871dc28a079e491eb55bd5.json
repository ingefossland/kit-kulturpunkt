{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = void 0;\n\nconst assert = require(\"assert\");\n\nconst Windows1292Decoder_1 = require(\"./Windows1292Decoder\");\n\nclass Util {\n  /**\n   *\n   * @param buffer\n   * @param start\n   * @param end\n   * @param encoding // ToDo: ts.enum\n   * @return {number}\n   */\n  static findZero(buffer, start, end, encoding) {\n    let i = start;\n\n    if (encoding === 'utf16') {\n      while (buffer[i] !== 0 || buffer[i + 1] !== 0) {\n        if (i >= end) return end;\n        i += 2;\n      }\n\n      return i;\n    } else {\n      while (buffer[i] !== 0) {\n        if (i >= end) return end;\n        i++;\n      }\n\n      return i;\n    }\n  }\n\n  static trimRightNull(x) {\n    const pos0 = x.indexOf('\\0');\n    return pos0 === -1 ? x : x.substr(0, pos0);\n  }\n\n  static swapBytes(buffer) {\n    const l = buffer.length;\n    assert.ok((l & 1) === 0, 'Buffer length must be even');\n\n    for (let i = 0; i < l; i += 2) {\n      const a = buffer[i];\n      buffer[i] = buffer[i + 1];\n      buffer[i + 1] = a;\n    }\n\n    return buffer;\n  }\n\n  static readUTF16String(buffer) {\n    let offset = 0;\n\n    if (buffer[0] === 0xFE && buffer[1] === 0xFF) {\n      // big endian\n      buffer = Util.swapBytes(buffer);\n      offset = 2;\n    } else if (buffer[0] === 0xFF && buffer[1] === 0xFE) {\n      // little endian\n      offset = 2;\n    }\n\n    return buffer.toString('ucs2', offset);\n  }\n  /**\n   *\n   * @param buffer Decoder input data\n   * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'\n   * @return {string}\n   */\n\n\n  static decodeString(buffer, encoding) {\n    // annoying workaround for a double BOM issue\n    // https://github.com/leetreveil/musicmetadata/issues/84\n    if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {\n      buffer = buffer.slice(2);\n    }\n\n    if (encoding === 'utf16le' || encoding === 'utf16') {\n      return Util.readUTF16String(buffer);\n    } else if (encoding === 'utf8') {\n      return buffer.toString('utf8');\n    } else if (encoding === 'iso-8859-1') {\n      return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);\n    }\n\n    throw Error(encoding + ' encoding is not supported!');\n  }\n\n  static stripNulls(str) {\n    str = str.replace(/^\\x00+/g, '');\n    str = str.replace(/\\x00+$/g, '');\n    return str;\n  }\n  /**\n   * Read bit-aligned number start from buffer\n   * Total offset in bits = byteOffset * 8 + bitOffset\n   * @param buf Byte buffer\n   * @param byteOffset Starting offset in bytes\n   * @param bitOffset Starting offset in bits: 0 = lsb\n   * @param len Length of number in bits\n   * @return {number} decoded bit aligned number\n   */\n\n\n  static getBitAllignedNumber(buf, byteOffset, bitOffset, len) {\n    const byteOff = byteOffset + ~~(bitOffset / 8);\n    const bitOff = bitOffset % 8;\n    let value = buf[byteOff];\n    value &= 0xff >> bitOff;\n    const bitsRead = 8 - bitOff;\n    const bitsLeft = len - bitsRead;\n\n    if (bitsLeft < 0) {\n      value >>= 8 - bitOff - len;\n    } else if (bitsLeft > 0) {\n      value <<= bitsLeft;\n      value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);\n    }\n\n    return value;\n  }\n  /**\n   * Read bit-aligned number start from buffer\n   * Total offset in bits = byteOffset * 8 + bitOffset\n   * @param buf Byte buffer\n   * @param byteOffset Starting offset in bytes\n   * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit\n   * @return {number} decoded bit aligned number\n   */\n\n\n  static isBitSet(buf, byteOffset, bitOffset) {\n    return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;\n  }\n\n  static a2hex(str) {\n    const arr = [];\n\n    for (let i = 0, l = str.length; i < l; i++) {\n      const hex = Number(str.charCodeAt(i)).toString(16);\n      arr.push(hex.length === 1 ? '0' + hex : hex);\n    }\n\n    return arr.join(' ');\n  }\n\n}\n\nexports.default = Util;\nUtil.strtokBITSET = {\n  get: (buf, off, bit) => {\n    return (buf[off] & 1 << bit) !== 0;\n  },\n  len: 1\n};\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\n\nfunction ratioToDb(ratio) {\n  return 10 * Math.log10(ratio);\n}\n\nexports.ratioToDb = ratioToDb;\n/**\n * Convert dB to ratio\n * db Decibels\n */\n\nfunction dbToRatio(dB) {\n  return Math.pow(10, dB / 10);\n}\n\nexports.dbToRatio = dbToRatio;\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\n\nfunction toRatio(value) {\n  const ps = value.split(' ').map(p => p.trim().toLowerCase()); // @ts-ignore\n\n  if (ps.length >= 1) {\n    const v = parseFloat(ps[0]);\n\n    if (ps.length === 2 && ps[1] === 'db') {\n      return {\n        dB: v,\n        ratio: dbToRatio(v)\n      };\n    } else {\n      return {\n        dB: ratioToDb(v),\n        ratio: v\n      };\n    }\n  }\n}\n\nexports.toRatio = toRatio;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/common/Util.js"],"names":["Object","defineProperty","exports","value","toRatio","dbToRatio","ratioToDb","assert","require","Windows1292Decoder_1","Util","findZero","buffer","start","end","encoding","i","trimRightNull","x","pos0","indexOf","substr","swapBytes","l","length","ok","a","readUTF16String","offset","toString","decodeString","slice","Windows1292Decoder","decode","Error","stripNulls","str","replace","getBitAllignedNumber","buf","byteOffset","bitOffset","len","byteOff","bitOff","bitsRead","bitsLeft","isBitSet","a2hex","arr","hex","Number","charCodeAt","push","join","default","strtokBITSET","get","off","bit","ratio","Math","log10","dB","pow","ps","split","map","p","trim","toLowerCase","v","parseFloat"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toRatio = exports.dbToRatio = exports.ratioToDb = void 0;\nconst assert = require(\"assert\");\nconst Windows1292Decoder_1 = require(\"./Windows1292Decoder\");\nclass Util {\n    /**\n     *\n     * @param buffer\n     * @param start\n     * @param end\n     * @param encoding // ToDo: ts.enum\n     * @return {number}\n     */\n    static findZero(buffer, start, end, encoding) {\n        let i = start;\n        if (encoding === 'utf16') {\n            while (buffer[i] !== 0 || buffer[i + 1] !== 0) {\n                if (i >= end)\n                    return end;\n                i += 2;\n            }\n            return i;\n        }\n        else {\n            while (buffer[i] !== 0) {\n                if (i >= end)\n                    return end;\n                i++;\n            }\n            return i;\n        }\n    }\n    static trimRightNull(x) {\n        const pos0 = x.indexOf('\\0');\n        return pos0 === -1 ? x : x.substr(0, pos0);\n    }\n    static swapBytes(buffer) {\n        const l = buffer.length;\n        assert.ok((l & 1) === 0, 'Buffer length must be even');\n        for (let i = 0; i < l; i += 2) {\n            const a = buffer[i];\n            buffer[i] = buffer[i + 1];\n            buffer[i + 1] = a;\n        }\n        return buffer;\n    }\n    static readUTF16String(buffer) {\n        let offset = 0;\n        if (buffer[0] === 0xFE && buffer[1] === 0xFF) { // big endian\n            buffer = Util.swapBytes(buffer);\n            offset = 2;\n        }\n        else if (buffer[0] === 0xFF && buffer[1] === 0xFE) { // little endian\n            offset = 2;\n        }\n        return buffer.toString('ucs2', offset);\n    }\n    /**\n     *\n     * @param buffer Decoder input data\n     * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'\n     * @return {string}\n     */\n    static decodeString(buffer, encoding) {\n        // annoying workaround for a double BOM issue\n        // https://github.com/leetreveil/musicmetadata/issues/84\n        if (buffer[0] === 0xFF && buffer[1] === 0xFE && buffer[2] === 0xFE && buffer[3] === 0xFF) {\n            buffer = buffer.slice(2);\n        }\n        if (encoding === 'utf16le' || encoding === 'utf16') {\n            return Util.readUTF16String(buffer);\n        }\n        else if (encoding === 'utf8') {\n            return buffer.toString('utf8');\n        }\n        else if (encoding === 'iso-8859-1') {\n            return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);\n        }\n        throw Error(encoding + ' encoding is not supported!');\n    }\n    static stripNulls(str) {\n        str = str.replace(/^\\x00+/g, '');\n        str = str.replace(/\\x00+$/g, '');\n        return str;\n    }\n    /**\n     * Read bit-aligned number start from buffer\n     * Total offset in bits = byteOffset * 8 + bitOffset\n     * @param buf Byte buffer\n     * @param byteOffset Starting offset in bytes\n     * @param bitOffset Starting offset in bits: 0 = lsb\n     * @param len Length of number in bits\n     * @return {number} decoded bit aligned number\n     */\n    static getBitAllignedNumber(buf, byteOffset, bitOffset, len) {\n        const byteOff = byteOffset + ~~(bitOffset / 8);\n        const bitOff = bitOffset % 8;\n        let value = buf[byteOff];\n        value &= 0xff >> bitOff;\n        const bitsRead = 8 - bitOff;\n        const bitsLeft = len - bitsRead;\n        if (bitsLeft < 0) {\n            value >>= (8 - bitOff - len);\n        }\n        else if (bitsLeft > 0) {\n            value <<= bitsLeft;\n            value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);\n        }\n        return value;\n    }\n    /**\n     * Read bit-aligned number start from buffer\n     * Total offset in bits = byteOffset * 8 + bitOffset\n     * @param buf Byte buffer\n     * @param byteOffset Starting offset in bytes\n     * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit\n     * @return {number} decoded bit aligned number\n     */\n    static isBitSet(buf, byteOffset, bitOffset) {\n        return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;\n    }\n    static a2hex(str) {\n        const arr = [];\n        for (let i = 0, l = str.length; i < l; i++) {\n            const hex = Number(str.charCodeAt(i)).toString(16);\n            arr.push(hex.length === 1 ? '0' + hex : hex);\n        }\n        return arr.join(' ');\n    }\n}\nexports.default = Util;\nUtil.strtokBITSET = {\n    get: (buf, off, bit) => {\n        return (buf[off] & (1 << bit)) !== 0;\n    },\n    len: 1\n};\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nfunction ratioToDb(ratio) {\n    return 10 * Math.log10(ratio);\n}\nexports.ratioToDb = ratioToDb;\n/**\n * Convert dB to ratio\n * db Decibels\n */\nfunction dbToRatio(dB) {\n    return Math.pow(10, dB / 10);\n}\nexports.dbToRatio = dbToRatio;\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nfunction toRatio(value) {\n    const ps = value.split(' ').map(p => p.trim().toLowerCase());\n    // @ts-ignore\n    if (ps.length >= 1) {\n        const v = parseFloat(ps[0]);\n        if (ps.length === 2 && ps[1] === 'db') {\n            return {\n                dB: v,\n                ratio: dbToRatio(v)\n            };\n        }\n        else {\n            return {\n                dB: ratioToDb(v),\n                ratio: v\n            };\n        }\n    }\n}\nexports.toRatio = toRatio;\n//# sourceMappingURL=Util.js.map"]},"metadata":{},"sourceType":"script"}