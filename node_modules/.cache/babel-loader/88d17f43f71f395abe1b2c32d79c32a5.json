{"ast":null,"code":"import { API } from \"../settings\";\nimport { createSlice } from '@reduxjs/toolkit';\nimport qs from 'query-string';\nconst searchByIdSlice = createSlice({\n  name: 'search',\n  initialState: {},\n  reducers: {\n    requestSearch(state, action) {\n      const {\n        models,\n        id,\n        page,\n        url,\n        query\n      } = action.payload;\n\n      if (state[id] && state[id].page) {\n        return { ...state,\n          [id]: { ...state[id],\n            isLoading: true,\n            url: url,\n            query: { ...query,\n              models: models,\n              id: id\n            }\n          }\n        };\n      }\n\n      return { ...state,\n        [id]: {\n          isLoading: true,\n          url: url,\n          query: { ...query,\n            models: models,\n            id: id\n          }\n        }\n      };\n    },\n\n    receiveError(state, action) {\n      const {\n        id,\n        error\n      } = action.payload;\n      return { ...state,\n        [id]: {\n          isLoading: false,\n          error: error.toString()\n        }\n      };\n    },\n\n    receiveSearch(state, action) {\n      const {\n        id,\n        results\n      } = action.payload;\n      return { ...state,\n        [id]: { ...state[id],\n          isLoading: false,\n          results: results\n        }\n      };\n    },\n\n    receivePage(state, action) {\n      const {\n        id,\n        page,\n        results\n      } = action.payload;\n      const {\n        start,\n        rows,\n        count\n      } = results;\n      const pages = Math.ceil(count / rows);\n      const currentPage = Math.ceil((start + rows) / rows);\n      const resultsByPage = { ...state[id].resultsByPage,\n        [page]: results.models\n      };\n      let resultsLoaded = [];\n      Object.values(resultsByPage).map(page => {\n        resultsLoaded = resultsLoaded.concat(page);\n      });\n      let nextPage, prevPage;\n\n      for (let p = page; p <= pages; p++) {\n        if (!resultsByPage[p]) {\n          nextPage = p;\n          break;\n        }\n      }\n\n      for (let p = page; p >= 1; p--) {\n        if (!resultsByPage[p]) {\n          prevPage = p;\n          break;\n        }\n      }\n\n      return { ...state,\n        [id]: { ...state[id],\n          count: count,\n          start: start,\n          rows: rows,\n          page: currentPage,\n          pages: pages,\n          nextPage: nextPage,\n          prevPage: prevPage,\n          resultsByPage: resultsByPage,\n          resultsLoaded: resultsLoaded\n        }\n      };\n    }\n\n  }\n});\nexport const getQuery = ({\n  models,\n  id,\n  page = 1,\n  ...query\n}) => dispatch => {\n  let url = API + '/admin/api/' + models + '/search';\n\n  if (page > 1 && query.rows) {\n    query.start = query.rows * (page - 1);\n  }\n\n  const sq = qs.stringify(query);\n\n  if (sq) {\n    url = url + '?' + sq;\n  } //    if (page === 1) {\n\n\n  dispatch(requestSearch({\n    models,\n    id,\n    page,\n    url,\n    query\n  })); //    }\n\n  fetch(url, {\n    method: \"GET\",\n    headers: {\n      \"Accept\": \"application/json\"\n    }\n  }).then(response => response.json(), error => console.log('An error occurred.', error)).then(results => {\n    dispatch(receiveSearch({\n      id,\n      results\n    }));\n    dispatch(receivePage({\n      id,\n      page,\n      results\n    }));\n  });\n};\nexport const {\n  requestSearch,\n  receiveSearch,\n  receivePage,\n  receiveError\n} = searchByIdSlice.actions;\nexport default searchByIdSlice.reducer;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/src/redux/searchById/searchByIdSlice.js"],"names":["API","createSlice","qs","searchByIdSlice","name","initialState","reducers","requestSearch","state","action","models","id","page","url","query","payload","isLoading","receiveError","error","toString","receiveSearch","results","receivePage","start","rows","count","pages","Math","ceil","currentPage","resultsByPage","resultsLoaded","Object","values","map","concat","nextPage","prevPage","p","getQuery","dispatch","sq","stringify","fetch","method","headers","then","response","json","console","log","actions","reducer"],"mappings":"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","sourcesContent":["import { API } from \"../settings\"\nimport { createSlice } from '@reduxjs/toolkit'\nimport qs from 'query-string';\n\nconst searchByIdSlice = createSlice({\n    name: 'search',\n    initialState: {\n    }, \n    reducers: {\n        requestSearch(state, action) {\n            const { models, id, page, url, query } = action.payload\n\n            if (state[id] && state[id].page) {\n                return {\n                    ...state,\n                    [id]: {\n                        ...state[id],\n                        isLoading: true,\n                        url: url,\n                        query: {\n                            ...query,\n                            models: models,\n                            id: id\n                        }\n                    }\n                }\n            }\n\n            return {\n                ...state,\n                [id]: {\n                    isLoading: true,\n                    url: url,\n                    query: {\n                        ...query,\n                        models: models,\n                        id: id\n                    }\n                }\n            }\n        },\n        receiveError(state, action) {\n            const { id, error } = action.payload\n\n            return {\n                ...state,\n                [id]: {\n                    isLoading: false,\n                    error: error.toString()\n                }\n            }\n\n        },\n        receiveSearch(state, action) {\n            const { id, results } = action.payload\n\n            return {\n                ...state,\n                [id]: {\n                    ...state[id],\n                    isLoading: false,\n                    results: results\n                }\n            }\n        },\n        receivePage(state, action) {\n            const { id, page, results } = action.payload\n\n            const { start, rows, count } = results\n\n            const pages = Math.ceil(count/rows)\n            const currentPage = Math.ceil((start+rows)/rows)\n\n            const resultsByPage = {\n                ...state[id].resultsByPage,\n                [page]: results.models\n            }\n\n            let resultsLoaded = []\n\n            Object.values(resultsByPage).map(page => {\n                resultsLoaded = resultsLoaded.concat(page)\n            })\n\n            let nextPage, prevPage\n\n            for (let p = page; p <= pages; p++) {\n                if (!resultsByPage[p]) {\n                    nextPage = p\n                    break\n                }\n            }    \n\n            for (let p = page; p >= 1; p--) {\n                if (!resultsByPage[p]) {\n                    prevPage = p\n                    break\n                }\n            }    \n\n            return {\n                ...state,\n                [id]: {\n                    ...state[id],\n                    count: count,\n                    start: start,\n                    rows: rows,\n                    page: currentPage,\n                    pages: pages,\n                    nextPage: nextPage,\n                    prevPage: prevPage,\n                    resultsByPage: resultsByPage,\n                    resultsLoaded: resultsLoaded\n                }\n            }\n\n        }\n    }\n})\n\nexport const getQuery = ({models, id, page = 1, ...query}) => dispatch => {\n    let url = API + '/admin/api/' + models + '/search';\n\n    if (page > 1 && query.rows) {\n        query.start = query.rows * (page-1)\n    }\n    \n    const sq = qs.stringify(query)\n\n    if (sq) {\n        url = url + '?' + sq;\n    }\n\n//    if (page === 1) {\n        dispatch(requestSearch({models, id, page, url, query}))\n//    }\n    \n    fetch(url, {\n        method: \"GET\",\n        headers: {\n            \"Accept\": \"application/json\",\n        },\n    })\n    .then(\n        response => response.json(),\n        error => console.log('An error occurred.', error)\n    )\n    .then(results => {\n        dispatch(receiveSearch({id, results}))\n        dispatch(receivePage({id, page, results}))\n    })\n\n}\n\n\nexport const { requestSearch, receiveSearch, receivePage, receiveError } = searchByIdSlice.actions\nexport default searchByIdSlice.reducer"]},"metadata":{},"sourceType":"module"}