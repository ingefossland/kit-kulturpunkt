{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MP4Parser = void 0;\n\nconst initDebug = require(\"debug\");\n\nconst Token = require(\"token-types\");\n\nconst assert = require(\"assert\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst Atom_1 = require(\"./Atom\");\n\nconst AtomToken = require(\"./AtomToken\");\n\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\n\nconst type_1 = require(\"../type\");\n\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n  raw: {\n    lossy: false,\n    format: 'raw'\n  },\n  MAC3: {\n    lossy: true,\n    format: 'MACE 3:1'\n  },\n  MAC6: {\n    lossy: true,\n    format: 'MACE 6:1'\n  },\n  ima4: {\n    lossy: true,\n    format: 'IMA 4:1'\n  },\n  ulaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  alaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  Qclp: {\n    lossy: true,\n    format: 'QUALCOMM PureVoice'\n  },\n  '.mp3': {\n    lossy: true,\n    format: 'MPEG-1 layer 3'\n  },\n  alac: {\n    lossy: false,\n    format: 'ALAC'\n  },\n  'ac-3': {\n    lossy: true,\n    format: 'AC-3'\n  },\n  mp4a: {\n    lossy: true,\n    format: 'MPEG-4/AAC'\n  },\n  mp4s: {\n    lossy: true,\n    format: 'MP4S'\n  },\n  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n  c608: {\n    lossy: true,\n    format: 'CEA-608'\n  },\n  c708: {\n    lossy: true,\n    format: 'CEA-708'\n  }\n};\n\nfunction distinct(value, index, self) {\n  return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\n\n\nclass MP4Parser extends BasicParser_1.BasicParser {\n  static read_BE_Signed_Integer(value) {\n    return Token.readIntBE(value, 0, value.length);\n  }\n\n  static read_BE_Unsigned_Integer(value) {\n    return Token.readUIntBE(value, 0, value.length);\n  }\n\n  async parse() {\n    this.tracks = [];\n    let remainingFileSize = this.tokenizer.fileInfo.size;\n\n    while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n      try {\n        const token = await this.tokenizer.peekToken(AtomToken.Header);\n\n        if (token.name === '\\0\\0\\0\\0') {\n          const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n          debug(errMsg);\n          this.addWarning(errMsg);\n          break;\n        }\n      } catch (error) {\n        const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n        debug(errMsg);\n        this.addWarning(errMsg);\n        break;\n      }\n\n      const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, atom => this.handleAtom(atom), null);\n      remainingFileSize -= rootAtom.header.length;\n    } // Post process metadata\n\n\n    const formatList = [];\n    this.tracks.forEach(track => {\n      const trackFormats = [];\n      track.soundSampleDescription.forEach(ssd => {\n        const streamInfo = {};\n        const encoderInfo = encoderDict[ssd.dataFormat];\n\n        if (encoderInfo) {\n          trackFormats.push(encoderInfo.format);\n          streamInfo.codecName = encoderInfo.format;\n        } else {\n          streamInfo.codecName = `<${ssd.dataFormat}>`;\n        }\n\n        if (ssd.description) {\n          const {\n            description\n          } = ssd;\n\n          if (description.sampleRate > 0) {\n            streamInfo.type = type_1.TrackType.audio;\n            streamInfo.audio = {\n              samplingFrequency: description.sampleRate,\n              bitDepth: description.sampleSize,\n              channels: description.numAudioChannels\n            };\n          }\n        }\n\n        this.metadata.addStreamInfo(streamInfo);\n      });\n\n      if (trackFormats.length >= 1) {\n        formatList.push(trackFormats.join('/'));\n      }\n    });\n\n    if (formatList.length > 0) {\n      this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n    }\n\n    const audioTracks = this.tracks.filter(track => {\n      return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.sampleRate > 0;\n    });\n\n    if (audioTracks.length >= 1) {\n      const audioTrack = audioTracks[0];\n      const duration = audioTrack.duration / audioTrack.timeScale;\n      this.metadata.setFormat('duration', duration); // calculate duration in seconds\n\n      const ssd = audioTrack.soundSampleDescription[0];\n\n      if (ssd.description) {\n        this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n        this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n        this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n      }\n\n      const encoderInfo = encoderDict[ssd.dataFormat];\n\n      if (encoderInfo) {\n        this.metadata.setFormat('lossless', !encoderInfo.lossy);\n      }\n\n      this.calculateBitRate();\n    }\n  }\n\n  async handleAtom(atom) {\n    if (atom.parent) {\n      switch (atom.parent.header.name) {\n        case 'ilst':\n        case '<id>':\n          return this.parseMetadataItemData(atom);\n\n        case 'stbl':\n          // The Sample Table Atom\n          switch (atom.header.name) {\n            case 'stsd':\n              // sample descriptions\n              return this.parseAtom_stsd(atom.getPayloadLength());\n\n            case 'stsc':\n              // sample-to-Chunk Atoms\n              return this.parseAtom_stsc(atom.getPayloadLength());\n\n            case 'stts':\n              // time to sample\n              return this.parseAtom_stts(atom.getPayloadLength());\n\n            case 'stsz':\n              // sample sizes\n              return this.parseAtom_stsz(atom.getPayloadLength());\n\n            case 'stco':\n              return this.parseAtom_stco(atom.getPayloadLength());\n\n            default:\n              debug(`Ignore: stbl/${atom.header.name} atom`);\n          }\n\n          break;\n      }\n    }\n\n    switch (atom.header.name) {\n      case 'ftyp':\n        const types = await this.parseAtom_ftyp(atom.getPayloadLength());\n        debug(`ftyp: ${types.join('/')}`);\n        const x = types.filter(distinct).join('/');\n        this.metadata.setFormat('container', x);\n        return;\n\n      case 'mdhd':\n        // Media header atom\n        return this.parseAtom_mdhd(atom);\n\n      case 'mvhd':\n        // 'movie' => 'mvhd': movie header atom; child of Movie Atom\n        return this.parseAtom_mvhd(atom);\n\n      case 'chap':\n        // Chapter or scene list atom. Usually references a text track.\n        const td = this.getTrackDescription();\n        td.chapterList = await this.parseAtom_chap(atom);\n        return;\n\n      case 'tkhd':\n        // Chapter or scene list atom. Usually references a text track.\n        await this.parseAtom_tkhd(atom.getPayloadLength());\n        return;\n\n      case 'mdat':\n        // media data atom:\n        this.audioLengthInBytes = atom.getPayloadLength();\n        this.calculateBitRate();\n        return this.parseAtom_mdat(atom.getPayloadLength());\n    }\n\n    await this.tokenizer.ignore(atom.getPayloadLength());\n    debug(`Ignore atom data: path=${atom.atomPath}, payload-len=${atom.getPayloadLength()}`);\n  }\n\n  getTrackDescription() {\n    return this.tracks[this.tracks.length - 1];\n  }\n\n  calculateBitRate() {\n    if (this.audioLengthInBytes && this.metadata.format.duration) {\n      this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n    }\n  }\n\n  addTag(id, value) {\n    this.metadata.addTag(tagFormat, id, value);\n  }\n\n  addWarning(message) {\n    debug('Warning: ' + message);\n    this.metadata.addWarning(message);\n  }\n  /**\n   * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n   * @param metaAtom\n   * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n   */\n\n\n  parseMetadataItemData(metaAtom) {\n    let tagKey = metaAtom.header.name;\n    return metaAtom.readAtoms(this.tokenizer, async child => {\n      switch (child.header.name) {\n        case 'data':\n          // value atom\n          return this.parseValueAtom(tagKey, child);\n\n        case 'name':\n          // name atom (optional)\n          const name = await this.tokenizer.readToken(new AtomToken.NameAtom(child.getPayloadLength()));\n          tagKey += ':' + name.name;\n          break;\n\n        case 'mean':\n          // name atom (optional)\n          const mean = await this.tokenizer.readToken(new AtomToken.NameAtom(child.getPayloadLength())); // console.log(\"  %s[%s] = %s\", tagKey, header.name, mean.name);\n\n          tagKey += ':' + mean.name;\n          break;\n\n        default:\n          const dataAtom = await this.tokenizer.readToken(new Token.BufferType(child.getPayloadLength()));\n          this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n      }\n    }, metaAtom.getPayloadLength());\n  }\n\n  async parseValueAtom(tagKey, metaAtom) {\n    const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len));\n\n    if (dataAtom.type.set !== 0) {\n      throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n    } // Use well-known-type table\n    // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n\n\n    switch (dataAtom.type.type) {\n      case 0:\n        // reserved: Reserved for use where no type needs to be indicated\n        switch (tagKey) {\n          case 'trkn':\n          case 'disk':\n            const num = Token.UINT8.get(dataAtom.value, 3);\n            const of = Token.UINT8.get(dataAtom.value, 5); // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n\n            this.addTag(tagKey, num + '/' + of);\n            break;\n\n          case 'gnre':\n            const genreInt = Token.UINT8.get(dataAtom.value, 1);\n            const genreStr = ID3v1Parser_1.Genres[genreInt - 1]; // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n\n            this.addTag(tagKey, genreStr);\n            break;\n\n          default: // console.log(\"  reserved-data: name=%s, len=%s, set=%s, type=%s, locale=%s, value{ hex=%s, ascii=%s }\",\n          // header.name, header.length, dataAtom.type.set, dataAtom.type.type, dataAtom.locale, dataAtom.value.toString('hex'), dataAtom.value.toString('ascii'));\n\n        }\n\n        break;\n\n      case 1: // UTF-8: Without any count or NULL terminator\n\n      case 18:\n        // Unknown: Found in m4b in combination with a 'Â©gen' tag\n        this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n        break;\n\n      case 13:\n        // JPEG\n        if (this.options.skipCovers) break;\n        this.addTag(tagKey, {\n          format: 'image/jpeg',\n          data: Buffer.from(dataAtom.value)\n        });\n        break;\n\n      case 14:\n        // PNG\n        if (this.options.skipCovers) break;\n        this.addTag(tagKey, {\n          format: 'image/png',\n          data: Buffer.from(dataAtom.value)\n        });\n        break;\n\n      case 21:\n        // BE Signed Integer\n        this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));\n        break;\n\n      case 22:\n        // BE Unsigned Integer\n        this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));\n        break;\n\n      case 65:\n        // An 8-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt8(0));\n        break;\n\n      case 66:\n        // A big-endian 16-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n        break;\n\n      case 67:\n        // A big-endian 32-bit signed integer\n        this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n        break;\n\n      default:\n        this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n    }\n  }\n  /**\n   * Parse movie header (mvhd) atom\n   * @param mvhd mvhd atom\n   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n   */\n\n\n  async parseAtom_mvhd(mvhd) {\n    // await this.tokenizer.readToken<AtomToken.IAtomMvhd>(new AtomToken.MvhdAtom(mvhd.getPayloadLength()));\n    // ToDo: export movie metadata\n    await this.tokenizer.ignore(mvhd.getPayloadLength());\n  }\n  /**\n   * Parse media header (mdhd) atom\n   * @param mdhd mdhd atom\n   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\n   */\n\n\n  async parseAtom_mdhd(mdhd) {\n    const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(mdhd.getPayloadLength())); // this.parse_mxhd(mdhd_data, this.currentTrack);\n\n    const td = this.getTrackDescription();\n    td.creationTime = mdhd_data.creationTime;\n    td.modificationTime = mdhd_data.modificationTime;\n    td.timeScale = mdhd_data.timeScale;\n    td.duration = mdhd_data.duration;\n  }\n\n  async parseAtom_ftyp(len) {\n    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n    len -= AtomToken.ftyp.len;\n\n    if (len > 0) {\n      const types = await this.parseAtom_ftyp(len);\n      const value = ftype.type.replace(/\\W/g, '');\n\n      if (value.length > 0) {\n        types.push(value);\n      }\n\n      return types;\n    }\n\n    return [];\n  }\n\n  async parseAtom_tkhd(len) {\n    const track = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len));\n    this.tracks.push(track);\n  }\n  /**\n   * Parse sample description atom\n   * @param len\n   */\n\n\n  async parseAtom_stsd(len) {\n    const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n    const trackDescription = this.getTrackDescription();\n    trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n  }\n\n  async parseAtom_stsc(len) {\n    const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n    this.getTrackDescription().sampleToChunkTable = stsc.entries;\n  }\n\n  async parseAtom_stts(len) {\n    const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n    this.getTrackDescription().timeToSampleTable = stts.entries;\n  }\n  /**\n   * @param sampleDescription\n   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n   */\n\n\n  parseSoundSampleDescription(sampleDescription) {\n    const ssd = {\n      dataFormat: sampleDescription.dataFormat,\n      dataReferenceIndex: sampleDescription.dataReferenceIndex\n    };\n    let offset = 0;\n    const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n    offset += AtomToken.SoundSampleDescriptionVersion.len;\n\n    if (version.version === 0 || version.version === 1) {\n      // Sound Sample Description (Version 0)\n      ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n    } else {\n      debug(`Warning: sound-sample-description ${version} not implemented`);\n    }\n\n    return ssd;\n  }\n  /**\n   * Parse chapter-list atom\n   * @param chap chap atom\n   */\n\n\n  async parseAtom_chap(chap) {\n    const trackIds = [];\n    let len = chap.getPayloadLength();\n\n    while (len >= Token.UINT32_BE.len) {\n      trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n      len -= Token.UINT32_BE.len;\n    }\n\n    return trackIds;\n  }\n  /**\n   * Parse sample-sizes atom ('stsz')\n   * @param len\n   */\n\n\n  async parseAtom_stsz(len) {\n    const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n    const td = this.getTrackDescription();\n    td.sampleSize = stsz.sampleSize;\n    td.sampleSizeTable = stsz.entries;\n  }\n  /**\n   * Parse chunk-offset atom ('stco')\n   * @param len\n   */\n\n\n  async parseAtom_stco(len) {\n    const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n    this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n  }\n  /**\n   * Parse mdat atom.\n   * Will scan for chapters\n   * @param len\n   */\n\n\n  async parseAtom_mdat(len) {\n    if (this.options.includeChapters) {\n      const trackWithChapters = this.tracks.filter(track => track.chapterList);\n\n      if (trackWithChapters.length === 1) {\n        const chapterTrackIds = trackWithChapters[0].chapterList;\n        const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n\n        if (chapterTracks.length === 1) {\n          return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n        }\n      }\n    }\n\n    await this.tokenizer.ignore(len);\n  }\n\n  async parseChapterTrack(chapterTrack, track, len) {\n    if (!chapterTrack.sampleSize) {\n      assert.equal(chapterTrack.chunkOffsetTable.length, chapterTrack.sampleSizeTable.length, 'chunk-offset-table & sample-size-table length');\n    }\n\n    const chapters = [];\n\n    for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n      const chunkOffset = chapterTrack.chunkOffsetTable[i];\n      const nextChunkLen = chunkOffset - this.tokenizer.position;\n      const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n      len -= nextChunkLen + sampleSize;\n      assert.ok(len >= 0, 'Chapter chunk exceeding token length');\n      await this.tokenizer.ignore(nextChunkLen);\n      const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n      debug(`Chapter ${i + 1}: ${title}`);\n      const chapter = {\n        title,\n        sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n      };\n      debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\n      chapters.push(chapter);\n    }\n\n    this.metadata.setFormat('chapters', chapters);\n    await this.tokenizer.ignore(len);\n  }\n\n  findSampleOffset(track, chapterOffset) {\n    let totalDuration = 0;\n    track.timeToSampleTable.forEach(e => {\n      totalDuration += e.count * e.duration;\n    });\n    debug(`Total duration=${totalDuration}`);\n    let chunkIndex = 0;\n\n    while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n      ++chunkIndex;\n    }\n\n    return this.getChunkDuration(chunkIndex + 1, track);\n  }\n\n  getChunkDuration(chunkId, track) {\n    let ttsi = 0;\n    let ttsc = track.timeToSampleTable[ttsi].count;\n    let ttsd = track.timeToSampleTable[ttsi].duration;\n    let curChunkId = 1;\n    let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n    let totalDuration = 0;\n\n    while (curChunkId < chunkId) {\n      const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n      totalDuration += nrOfSamples * ttsd;\n      ttsc -= nrOfSamples;\n      samplesPerChunk -= nrOfSamples;\n\n      if (samplesPerChunk === 0) {\n        ++curChunkId;\n        samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n      } else {\n        ++ttsi;\n        ttsc = track.timeToSampleTable[ttsi].count;\n        ttsd = track.timeToSampleTable[ttsi].duration;\n      }\n    }\n\n    return totalDuration;\n  }\n\n  getSamplesPerChunk(chunkId, stcTable) {\n    for (let i = 0; i < stcTable.length - 1; ++i) {\n      if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n        return stcTable[i].samplesPerChunk;\n      }\n    }\n\n    return stcTable[stcTable.length - 1].samplesPerChunk;\n  }\n\n}\n\nexports.MP4Parser = MP4Parser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/mp4/MP4Parser.js"],"names":["Object","defineProperty","exports","value","MP4Parser","initDebug","require","Token","assert","BasicParser_1","Atom_1","AtomToken","ID3v1Parser_1","type_1","debug","tagFormat","encoderDict","raw","lossy","format","MAC3","MAC6","ima4","ulaw","alaw","Qclp","alac","mp4a","mp4s","c608","c708","distinct","index","self","indexOf","BasicParser","read_BE_Signed_Integer","readIntBE","length","read_BE_Unsigned_Integer","readUIntBE","parse","tracks","remainingFileSize","tokenizer","fileInfo","size","token","peekToken","Header","name","errMsg","position","addWarning","error","message","rootAtom","Atom","readAtom","atom","handleAtom","header","formatList","forEach","track","trackFormats","soundSampleDescription","ssd","streamInfo","encoderInfo","dataFormat","push","codecName","description","sampleRate","type","TrackType","audio","samplingFrequency","bitDepth","sampleSize","channels","numAudioChannels","metadata","addStreamInfo","join","setFormat","filter","audioTracks","audioTrack","duration","timeScale","calculateBitRate","parent","parseMetadataItemData","parseAtom_stsd","getPayloadLength","parseAtom_stsc","parseAtom_stts","parseAtom_stsz","parseAtom_stco","types","parseAtom_ftyp","x","parseAtom_mdhd","parseAtom_mvhd","td","getTrackDescription","chapterList","parseAtom_chap","parseAtom_tkhd","audioLengthInBytes","parseAtom_mdat","ignore","atomPath","addTag","id","metaAtom","tagKey","readAtoms","child","parseValueAtom","readToken","NameAtom","mean","dataAtom","BufferType","toString","DataAtom","len","set","Error","num","UINT8","get","of","genreInt","genreStr","Genres","options","skipCovers","data","Buffer","from","readInt8","readInt16BE","readInt32BE","mvhd","mdhd","mdhd_data","MdhdAtom","creationTime","modificationTime","ftype","ftyp","replace","TrackHeaderAtom","stsd","StsdAtom","trackDescription","table","map","dfEntry","parseSoundSampleDescription","stsc","StscAtom","sampleToChunkTable","entries","stts","SttsAtom","timeToSampleTable","sampleDescription","dataReferenceIndex","offset","version","SoundSampleDescriptionVersion","SoundSampleDescriptionV0","chap","trackIds","UINT32_BE","readNumber","stsz","StszAtom","sampleSizeTable","stco","StcoAtom","chunkOffsetTable","includeChapters","trackWithChapters","chapterTrackIds","chapterTracks","trackId","parseChapterTrack","chapterTrack","equal","chapters","i","chunkOffset","nextChunkLen","ok","title","ChapterText","chapter","sampleOffset","findSampleOffset","chapterOffset","totalDuration","e","count","chunkIndex","getChunkDuration","chunkId","ttsi","ttsc","ttsd","curChunkId","samplesPerChunk","getSamplesPerChunk","nrOfSamples","Math","min","stcTable","firstChunk"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MP4Parser = void 0;\nconst initDebug = require(\"debug\");\nconst Token = require(\"token-types\");\nconst assert = require(\"assert\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst Atom_1 = require(\"./Atom\");\nconst AtomToken = require(\"./AtomToken\");\nconst ID3v1Parser_1 = require(\"../id3v1/ID3v1Parser\");\nconst type_1 = require(\"../type\");\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n    raw: {\n        lossy: false,\n        format: 'raw'\n    },\n    MAC3: {\n        lossy: true,\n        format: 'MACE 3:1'\n    },\n    MAC6: {\n        lossy: true,\n        format: 'MACE 6:1'\n    },\n    ima4: {\n        lossy: true,\n        format: 'IMA 4:1'\n    },\n    ulaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    alaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    Qclp: {\n        lossy: true,\n        format: 'QUALCOMM PureVoice'\n    },\n    '.mp3': {\n        lossy: true,\n        format: 'MPEG-1 layer 3'\n    },\n    alac: {\n        lossy: false,\n        format: 'ALAC'\n    },\n    'ac-3': {\n        lossy: true,\n        format: 'AC-3'\n    },\n    mp4a: {\n        lossy: true,\n        format: 'MPEG-4/AAC'\n    },\n    mp4s: {\n        lossy: true,\n        format: 'MP4S'\n    },\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n    c608: {\n        lossy: true,\n        format: 'CEA-608'\n    },\n    c708: {\n        lossy: true,\n        format: 'CEA-708'\n    }\n};\nfunction distinct(value, index, self) {\n    return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nclass MP4Parser extends BasicParser_1.BasicParser {\n    static read_BE_Signed_Integer(value) {\n        return Token.readIntBE(value, 0, value.length);\n    }\n    static read_BE_Unsigned_Integer(value) {\n        return Token.readUIntBE(value, 0, value.length);\n    }\n    async parse() {\n        this.tracks = [];\n        let remainingFileSize = this.tokenizer.fileInfo.size;\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n            try {\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\n                if (token.name === '\\0\\0\\0\\0') {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                    break;\n                }\n            }\n            catch (error) {\n                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n                debug(errMsg);\n                this.addWarning(errMsg);\n                break;\n            }\n            const rootAtom = await Atom_1.Atom.readAtom(this.tokenizer, atom => this.handleAtom(atom), null);\n            remainingFileSize -= rootAtom.header.length;\n        }\n        // Post process metadata\n        const formatList = [];\n        this.tracks.forEach(track => {\n            const trackFormats = [];\n            track.soundSampleDescription.forEach(ssd => {\n                const streamInfo = {};\n                const encoderInfo = encoderDict[ssd.dataFormat];\n                if (encoderInfo) {\n                    trackFormats.push(encoderInfo.format);\n                    streamInfo.codecName = encoderInfo.format;\n                }\n                else {\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\n                }\n                if (ssd.description) {\n                    const { description } = ssd;\n                    if (description.sampleRate > 0) {\n                        streamInfo.type = type_1.TrackType.audio;\n                        streamInfo.audio = {\n                            samplingFrequency: description.sampleRate,\n                            bitDepth: description.sampleSize,\n                            channels: description.numAudioChannels\n                        };\n                    }\n                }\n                this.metadata.addStreamInfo(streamInfo);\n            });\n            if (trackFormats.length >= 1) {\n                formatList.push(trackFormats.join('/'));\n            }\n        });\n        if (formatList.length > 0) {\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n        }\n        const audioTracks = this.tracks.filter(track => {\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.sampleRate > 0;\n        });\n        if (audioTracks.length >= 1) {\n            const audioTrack = audioTracks[0];\n            const duration = audioTrack.duration / audioTrack.timeScale;\n            this.metadata.setFormat('duration', duration); // calculate duration in seconds\n            const ssd = audioTrack.soundSampleDescription[0];\n            if (ssd.description) {\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n            }\n            const encoderInfo = encoderDict[ssd.dataFormat];\n            if (encoderInfo) {\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\n            }\n            this.calculateBitRate();\n        }\n    }\n    async handleAtom(atom) {\n        if (atom.parent) {\n            switch (atom.parent.header.name) {\n                case 'ilst':\n                case '<id>':\n                    return this.parseMetadataItemData(atom);\n                case 'stbl': // The Sample Table Atom\n                    switch (atom.header.name) {\n                        case 'stsd': // sample descriptions\n                            return this.parseAtom_stsd(atom.getPayloadLength());\n                        case 'stsc': // sample-to-Chunk Atoms\n                            return this.parseAtom_stsc(atom.getPayloadLength());\n                        case 'stts': // time to sample\n                            return this.parseAtom_stts(atom.getPayloadLength());\n                        case 'stsz': // sample sizes\n                            return this.parseAtom_stsz(atom.getPayloadLength());\n                        case 'stco':\n                            return this.parseAtom_stco(atom.getPayloadLength());\n                        default:\n                            debug(`Ignore: stbl/${atom.header.name} atom`);\n                    }\n                    break;\n            }\n        }\n        switch (atom.header.name) {\n            case 'ftyp':\n                const types = await this.parseAtom_ftyp(atom.getPayloadLength());\n                debug(`ftyp: ${types.join('/')}`);\n                const x = types.filter(distinct).join('/');\n                this.metadata.setFormat('container', x);\n                return;\n            case 'mdhd': // Media header atom\n                return this.parseAtom_mdhd(atom);\n            case 'mvhd': // 'movie' => 'mvhd': movie header atom; child of Movie Atom\n                return this.parseAtom_mvhd(atom);\n            case 'chap': // Chapter or scene list atom. Usually references a text track.\n                const td = this.getTrackDescription();\n                td.chapterList = await this.parseAtom_chap(atom);\n                return;\n            case 'tkhd': // Chapter or scene list atom. Usually references a text track.\n                await this.parseAtom_tkhd(atom.getPayloadLength());\n                return;\n            case 'mdat': // media data atom:\n                this.audioLengthInBytes = atom.getPayloadLength();\n                this.calculateBitRate();\n                return this.parseAtom_mdat(atom.getPayloadLength());\n        }\n        await this.tokenizer.ignore(atom.getPayloadLength());\n        debug(`Ignore atom data: path=${atom.atomPath}, payload-len=${atom.getPayloadLength()}`);\n    }\n    getTrackDescription() {\n        return this.tracks[this.tracks.length - 1];\n    }\n    calculateBitRate() {\n        if (this.audioLengthInBytes && this.metadata.format.duration) {\n            this.metadata.setFormat('bitrate', 8 * this.audioLengthInBytes / this.metadata.format.duration);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag(tagFormat, id, value);\n    }\n    addWarning(message) {\n        debug('Warning: ' + message);\n        this.metadata.addWarning(message);\n    }\n    /**\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n     * @param metaAtom\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n     */\n    parseMetadataItemData(metaAtom) {\n        let tagKey = metaAtom.header.name;\n        return metaAtom.readAtoms(this.tokenizer, async (child) => {\n            switch (child.header.name) {\n                case 'data': // value atom\n                    return this.parseValueAtom(tagKey, child);\n                case 'name': // name atom (optional)\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(child.getPayloadLength()));\n                    tagKey += ':' + name.name;\n                    break;\n                case 'mean': // name atom (optional)\n                    const mean = await this.tokenizer.readToken(new AtomToken.NameAtom(child.getPayloadLength()));\n                    // console.log(\"  %s[%s] = %s\", tagKey, header.name, mean.name);\n                    tagKey += ':' + mean.name;\n                    break;\n                default:\n                    const dataAtom = await this.tokenizer.readToken(new Token.BufferType(child.getPayloadLength()));\n                    this.addWarning('Unsupported meta-item: ' + tagKey + '[' + child.header.name + '] => value=' + dataAtom.toString('hex') + ' ascii=' + dataAtom.toString('ascii'));\n            }\n        }, metaAtom.getPayloadLength());\n    }\n    async parseValueAtom(tagKey, metaAtom) {\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len));\n        if (dataAtom.type.set !== 0) {\n            throw new Error('Unsupported type-set != 0: ' + dataAtom.type.set);\n        }\n        // Use well-known-type table\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n        switch (dataAtom.type.type) {\n            case 0: // reserved: Reserved for use where no type needs to be indicated\n                switch (tagKey) {\n                    case 'trkn':\n                    case 'disk':\n                        const num = Token.UINT8.get(dataAtom.value, 3);\n                        const of = Token.UINT8.get(dataAtom.value, 5);\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n                        this.addTag(tagKey, num + '/' + of);\n                        break;\n                    case 'gnre':\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\n                        const genreStr = ID3v1Parser_1.Genres[genreInt - 1];\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n                        this.addTag(tagKey, genreStr);\n                        break;\n                    default:\n                    // console.log(\"  reserved-data: name=%s, len=%s, set=%s, type=%s, locale=%s, value{ hex=%s, ascii=%s }\",\n                    // header.name, header.length, dataAtom.type.set, dataAtom.type.type, dataAtom.locale, dataAtom.value.toString('hex'), dataAtom.value.toString('ascii'));\n                }\n                break;\n            case 1: // UTF-8: Without any count or NULL terminator\n            case 18: // Unknown: Found in m4b in combination with a 'Â©gen' tag\n                this.addTag(tagKey, dataAtom.value.toString('utf-8'));\n                break;\n            case 13: // JPEG\n                if (this.options.skipCovers)\n                    break;\n                this.addTag(tagKey, {\n                    format: 'image/jpeg',\n                    data: Buffer.from(dataAtom.value)\n                });\n                break;\n            case 14: // PNG\n                if (this.options.skipCovers)\n                    break;\n                this.addTag(tagKey, {\n                    format: 'image/png',\n                    data: Buffer.from(dataAtom.value)\n                });\n                break;\n            case 21: // BE Signed Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));\n                break;\n            case 22: // BE Unsigned Integer\n                this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));\n                break;\n            case 65: // An 8-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt8(0));\n                break;\n            case 66: // A big-endian 16-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt16BE(0));\n                break;\n            case 67: // A big-endian 32-bit signed integer\n                this.addTag(tagKey, dataAtom.value.readInt32BE(0));\n                break;\n            default:\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n        }\n    }\n    /**\n     * Parse movie header (mvhd) atom\n     * @param mvhd mvhd atom\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n     */\n    async parseAtom_mvhd(mvhd) {\n        // await this.tokenizer.readToken<AtomToken.IAtomMvhd>(new AtomToken.MvhdAtom(mvhd.getPayloadLength()));\n        // ToDo: export movie metadata\n        await this.tokenizer.ignore((mvhd.getPayloadLength()));\n    }\n    /**\n     * Parse media header (mdhd) atom\n     * @param mdhd mdhd atom\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615\n     */\n    async parseAtom_mdhd(mdhd) {\n        const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(mdhd.getPayloadLength()));\n        // this.parse_mxhd(mdhd_data, this.currentTrack);\n        const td = this.getTrackDescription();\n        td.creationTime = mdhd_data.creationTime;\n        td.modificationTime = mdhd_data.modificationTime;\n        td.timeScale = mdhd_data.timeScale;\n        td.duration = mdhd_data.duration;\n    }\n    async parseAtom_ftyp(len) {\n        const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n        len -= AtomToken.ftyp.len;\n        if (len > 0) {\n            const types = await this.parseAtom_ftyp(len);\n            const value = ftype.type.replace(/\\W/g, '');\n            if (value.length > 0) {\n                types.push(value);\n            }\n            return types;\n        }\n        return [];\n    }\n    async parseAtom_tkhd(len) {\n        const track = (await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(len)));\n        this.tracks.push(track);\n    }\n    /**\n     * Parse sample description atom\n     * @param len\n     */\n    async parseAtom_stsd(len) {\n        const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n        const trackDescription = this.getTrackDescription();\n        trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n    }\n    async parseAtom_stsc(len) {\n        const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(len));\n        this.getTrackDescription().sampleToChunkTable = stsc.entries;\n    }\n    async parseAtom_stts(len) {\n        const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(len));\n        this.getTrackDescription().timeToSampleTable = stts.entries;\n    }\n    /**\n     * @param sampleDescription\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n     */\n    parseSoundSampleDescription(sampleDescription) {\n        const ssd = {\n            dataFormat: sampleDescription.dataFormat,\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\n        };\n        let offset = 0;\n        const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n        offset += AtomToken.SoundSampleDescriptionVersion.len;\n        if (version.version === 0 || version.version === 1) {\n            // Sound Sample Description (Version 0)\n            ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n        }\n        else {\n            debug(`Warning: sound-sample-description ${version} not implemented`);\n        }\n        return ssd;\n    }\n    /**\n     * Parse chapter-list atom\n     * @param chap chap atom\n     */\n    async parseAtom_chap(chap) {\n        const trackIds = [];\n        let len = chap.getPayloadLength();\n        while (len >= Token.UINT32_BE.len) {\n            trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n            len -= Token.UINT32_BE.len;\n        }\n        return trackIds;\n    }\n    /**\n     * Parse sample-sizes atom ('stsz')\n     * @param len\n     */\n    async parseAtom_stsz(len) {\n        const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n        const td = this.getTrackDescription();\n        td.sampleSize = stsz.sampleSize;\n        td.sampleSizeTable = stsz.entries;\n    }\n    /**\n     * Parse chunk-offset atom ('stco')\n     * @param len\n     */\n    async parseAtom_stco(len) {\n        const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(len));\n        this.getTrackDescription().chunkOffsetTable = stco.entries; // remember chunk offsets\n    }\n    /**\n     * Parse mdat atom.\n     * Will scan for chapters\n     * @param len\n     */\n    async parseAtom_mdat(len) {\n        if (this.options.includeChapters) {\n            const trackWithChapters = this.tracks.filter(track => track.chapterList);\n            if (trackWithChapters.length === 1) {\n                const chapterTrackIds = trackWithChapters[0].chapterList;\n                const chapterTracks = this.tracks.filter(track => chapterTrackIds.indexOf(track.trackId) !== -1);\n                if (chapterTracks.length === 1) {\n                    return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n                }\n            }\n        }\n        await this.tokenizer.ignore(len);\n    }\n    async parseChapterTrack(chapterTrack, track, len) {\n        if (!chapterTrack.sampleSize) {\n            assert.equal(chapterTrack.chunkOffsetTable.length, chapterTrack.sampleSizeTable.length, 'chunk-offset-table & sample-size-table length');\n        }\n        const chapters = [];\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n            len -= nextChunkLen + sampleSize;\n            assert.ok(len >= 0, 'Chapter chunk exceeding token length');\n            await this.tokenizer.ignore(nextChunkLen);\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n            debug(`Chapter ${i + 1}: ${title}`);\n            const chapter = {\n                title,\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n            };\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);\n            chapters.push(chapter);\n        }\n        this.metadata.setFormat('chapters', chapters);\n        await this.tokenizer.ignore(len);\n    }\n    findSampleOffset(track, chapterOffset) {\n        let totalDuration = 0;\n        track.timeToSampleTable.forEach(e => {\n            totalDuration += e.count * e.duration;\n        });\n        debug(`Total duration=${totalDuration}`);\n        let chunkIndex = 0;\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n            ++chunkIndex;\n        }\n        return this.getChunkDuration(chunkIndex + 1, track);\n    }\n    getChunkDuration(chunkId, track) {\n        let ttsi = 0;\n        let ttsc = track.timeToSampleTable[ttsi].count;\n        let ttsd = track.timeToSampleTable[ttsi].duration;\n        let curChunkId = 1;\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        let totalDuration = 0;\n        while (curChunkId < chunkId) {\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n            totalDuration += nrOfSamples * ttsd;\n            ttsc -= nrOfSamples;\n            samplesPerChunk -= nrOfSamples;\n            if (samplesPerChunk === 0) {\n                ++curChunkId;\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n            }\n            else {\n                ++ttsi;\n                ttsc = track.timeToSampleTable[ttsi].count;\n                ttsd = track.timeToSampleTable[ttsi].duration;\n            }\n        }\n        return totalDuration;\n    }\n    getSamplesPerChunk(chunkId, stcTable) {\n        for (let i = 0; i < stcTable.length - 1; ++i) {\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n                return stcTable[i].samplesPerChunk;\n            }\n        }\n        return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n}\nexports.MP4Parser = MP4Parser;\n//# sourceMappingURL=MP4Parser.js.map"]},"metadata":{},"sourceType":"script"}