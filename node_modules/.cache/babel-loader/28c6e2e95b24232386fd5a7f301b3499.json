{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WaveParser = void 0;\n\nconst strtok3 = require(\"strtok3/lib/core\");\n\nconst Token = require(\"token-types\");\n\nconst initDebug = require(\"debug\");\n\nconst riff = require(\"./RiffChunk\");\n\nconst WaveChunk = require(\"./../wav/WaveChunk\");\n\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nconst Util_1 = require(\"../common/Util\");\n\nconst FourCC_1 = require(\"../common/FourCC\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst debug = initDebug('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n *  http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n *  http://soundfile.sapp.org/doc/WaveFormat\n *\n *  ToDo: Split WAVE part from RIFF parser\n */\n\nclass WaveParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const riffHeader = await this.tokenizer.readToken(riff.Header);\n    debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n    if (riffHeader.chunkID !== 'RIFF') return; // Not RIFF format\n\n    return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n      if (!(err instanceof strtok3.EndOfStreamError)) {\n        throw err;\n      }\n    });\n  }\n\n  async parseRiffChunk(chunkSize) {\n    const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    this.metadata.setFormat('container', type);\n\n    switch (type) {\n      case 'WAVE':\n        return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\n\n      default:\n        throw new Error(`Unsupported RIFF format: RIFF/${type}`);\n    }\n  }\n\n  async readWaveChunk(remaining) {\n    while (remaining >= riff.Header.len) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      remaining -= riff.Header.len + header.chunkSize;\n      this.header = header;\n      debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n\n      switch (header.chunkID) {\n        case 'LIST':\n          await this.parseListTag(header);\n          break;\n\n        case 'fact':\n          // extended Format chunk,\n          this.metadata.setFormat('lossless', false);\n          this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n          break;\n\n        case 'fmt ':\n          // The Util Chunk, non-PCM Formats\n          const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n          let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n\n          if (!subFormat) {\n            debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n            subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n          }\n\n          this.metadata.setFormat('codec', subFormat);\n          this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n          this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n          this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n          this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n          this.blockAlign = fmt.nBlockAlign;\n          break;\n\n        case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n\n        case 'ID3 ':\n          // The way Mp3Tags stores ID3 meta-data\n          const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n          const rst = strtok3.fromBuffer(id3_data);\n          await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n          break;\n\n        case 'data':\n          // PCM-data\n          if (this.metadata.format.lossless !== false) {\n            this.metadata.setFormat('lossless', true);\n          }\n\n          const numberOfSamples = this.fact ? this.fact.dwSampleLength : header.chunkSize / this.blockAlign;\n          this.metadata.setFormat('numberOfSamples', numberOfSamples);\n          this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n          this.metadata.setFormat('bitrate', this.metadata.format.numberOfChannels * this.blockAlign * this.metadata.format.sampleRate); // ToDo: check me\n\n          await this.tokenizer.ignore(header.chunkSize);\n          break;\n\n        default:\n          debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n          this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n          await this.tokenizer.ignore(header.chunkSize);\n      }\n\n      if (this.header.chunkSize % 2 === 1) {\n        debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n\n        await this.tokenizer.ignore(1);\n      }\n    }\n  }\n\n  async parseListTag(listHeader) {\n    const listType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n    debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n\n    switch (listType) {\n      case 'INFO':\n        return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n\n      case 'adtl':\n      default:\n        this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n        debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n        return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n    }\n  }\n\n  async parseRiffInfoTags(chunkSize) {\n    while (chunkSize >= 8) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      const valueToken = new riff.ListInfoTagValue(header);\n      const value = await this.tokenizer.readToken(valueToken);\n      this.addTag(header.chunkID, Util_1.default.stripNulls(value));\n      chunkSize -= 8 + valueToken.len;\n    }\n\n    if (chunkSize !== 0) {\n      throw Error('Illegal remaining size: ' + chunkSize);\n    }\n  }\n\n  addTag(id, value) {\n    this.metadata.addTag('exif', id, value);\n  }\n\n}\n\nexports.WaveParser = WaveParser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/riff/WaveParser.js"],"names":["Object","defineProperty","exports","value","WaveParser","strtok3","require","Token","initDebug","riff","WaveChunk","ID3v2Parser_1","Util_1","FourCC_1","BasicParser_1","debug","BasicParser","parse","riffHeader","tokenizer","readToken","Header","position","chunkID","parseRiffChunk","chunkSize","catch","err","EndOfStreamError","type","FourCcToken","metadata","setFormat","readWaveChunk","len","Error","remaining","header","parseListTag","fact","FactChunk","fmt","Format","subFormat","WaveFormat","wFormatTag","wBitsPerSample","nSamplesPerSec","nChannels","nBlockAlign","blockAlign","id3_data","BufferType","rst","fromBuffer","ID3v2Parser","options","format","lossless","numberOfSamples","dwSampleLength","sampleRate","numberOfChannels","ignore","addWarning","listHeader","listType","parseRiffInfoTags","then","valueToken","ListInfoTagValue","addTag","default","stripNulls","id"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WaveParser = void 0;\nconst strtok3 = require(\"strtok3/lib/core\");\nconst Token = require(\"token-types\");\nconst initDebug = require(\"debug\");\nconst riff = require(\"./RiffChunk\");\nconst WaveChunk = require(\"./../wav/WaveChunk\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst Util_1 = require(\"../common/Util\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst debug = initDebug('music-metadata:parser:RIFF');\n/**\n * Resource Interchange File Format (RIFF) Parser\n *\n * WAVE PCM soundfile format\n *\n * Ref:\n *  http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\n *  http://soundfile.sapp.org/doc/WaveFormat\n *\n *  ToDo: Split WAVE part from RIFF parser\n */\nclass WaveParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n        if (riffHeader.chunkID !== 'RIFF')\n            return; // Not RIFF format\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n            if (!(err instanceof strtok3.EndOfStreamError)) {\n                throw err;\n            }\n        });\n    }\n    async parseRiffChunk(chunkSize) {\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        this.metadata.setFormat('container', type);\n        switch (type) {\n            case 'WAVE':\n                return this.readWaveChunk(chunkSize - FourCC_1.FourCcToken.len);\n            default:\n                throw new Error(`Unsupported RIFF format: RIFF/${type}`);\n        }\n    }\n    async readWaveChunk(remaining) {\n        while (remaining >= riff.Header.len) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            remaining -= riff.Header.len + header.chunkSize;\n            this.header = header;\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n            switch (header.chunkID) {\n                case 'LIST':\n                    await this.parseListTag(header);\n                    break;\n                case 'fact': // extended Format chunk,\n                    this.metadata.setFormat('lossless', false);\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n                    break;\n                case 'fmt ': // The Util Chunk, non-PCM Formats\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n                    let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];\n                    if (!subFormat) {\n                        debug('WAVE/non-PCM format=' + fmt.wFormatTag);\n                        subFormat = 'non-PCM (' + fmt.wFormatTag + ')';\n                    }\n                    this.metadata.setFormat('codec', subFormat);\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n                    this.blockAlign = fmt.nBlockAlign;\n                    break;\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n                case 'ID3 ': // The way Mp3Tags stores ID3 meta-data\n                    const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n                    const rst = strtok3.fromBuffer(id3_data);\n                    await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                    break;\n                case 'data': // PCM-data\n                    if (this.metadata.format.lossless !== false) {\n                        this.metadata.setFormat('lossless', true);\n                    }\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (header.chunkSize / this.blockAlign);\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\n                    this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n                    this.metadata.setFormat('bitrate', this.metadata.format.numberOfChannels * this.blockAlign * this.metadata.format.sampleRate); // ToDo: check me\n                    await this.tokenizer.ignore(header.chunkSize);\n                    break;\n                default:\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n                    this.metadata.addWarning('Ignore chunk: RIFF/' + header.chunkID);\n                    await this.tokenizer.ignore(header.chunkSize);\n            }\n            if (this.header.chunkSize % 2 === 1) {\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n                await this.tokenizer.ignore(1);\n            }\n        }\n    }\n    async parseListTag(listHeader) {\n        const listType = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n        switch (listType) {\n            case 'INFO':\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n            case 'adtl':\n            default:\n                this.metadata.addWarning('Ignore chunk: RIFF/WAVE/LIST/' + listType);\n                debug('Ignoring chunkID=RIFF/WAVE/LIST/' + listType);\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n        }\n    }\n    async parseRiffInfoTags(chunkSize) {\n        while (chunkSize >= 8) {\n            const header = await this.tokenizer.readToken(riff.Header);\n            const valueToken = new riff.ListInfoTagValue(header);\n            const value = await this.tokenizer.readToken(valueToken);\n            this.addTag(header.chunkID, Util_1.default.stripNulls(value));\n            chunkSize -= (8 + valueToken.len);\n        }\n        if (chunkSize !== 0) {\n            throw Error('Illegal remaining size: ' + chunkSize);\n        }\n    }\n    addTag(id, value) {\n        this.metadata.addTag('exif', id, value);\n    }\n}\nexports.WaveParser = WaveParser;\n//# sourceMappingURL=WaveParser.js.map"]},"metadata":{},"sourceType":"script"}