{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VorbisParser = void 0;\n\nconst Token = require(\"token-types\");\n\nconst _debug = require(\"debug\");\n\nconst VorbisDecoder_1 = require(\"./VorbisDecoder\");\n\nconst Vorbis_1 = require(\"./Vorbis\");\n\nconst debug = _debug('music-metadata:parser:ogg:vorbis1');\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\n\n\nclass VorbisParser {\n  constructor(metadata, options) {\n    this.metadata = metadata;\n    this.options = options;\n    this.pageSegments = [];\n  }\n  /**\n   * Vorbis 1 parser\n   * @param header Ogg Page Header\n   * @param pageData Page data\n   */\n\n\n  parsePage(header, pageData) {\n    if (header.headerType.firstPage) {\n      this.parseFirstPage(header, pageData);\n    } else {\n      if (header.headerType.continued) {\n        if (this.pageSegments.length === 0) {\n          throw new Error(\"Cannot continue on previous page\");\n        }\n\n        this.pageSegments.push(pageData);\n      }\n\n      if (header.headerType.lastPage || !header.headerType.continued) {\n        // Flush page segments\n        if (this.pageSegments.length > 0) {\n          const fullPage = Buffer.concat(this.pageSegments);\n          this.parseFullPage(fullPage);\n        } // Reset page segments\n\n\n        this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n      }\n    }\n\n    if (header.headerType.lastPage) {\n      this.calculateDuration(header);\n    }\n  }\n\n  flush() {\n    this.parseFullPage(Buffer.concat(this.pageSegments));\n  }\n\n  parseUserComment(pageData, offset) {\n    const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\n    const tag = decoder.parseUserComment();\n    this.addTag(tag.key, tag.value);\n    return tag.len;\n  }\n\n  addTag(id, value) {\n    if (id === 'METADATA_BLOCK_PICTURE' && typeof value === 'string') {\n      if (this.options.skipCovers) {\n        debug(`Ignore picture`);\n        return;\n      }\n\n      value = Vorbis_1.VorbisPictureToken.fromBase64(value);\n      debug(`Push picture: id=${id}, format=${value.format}`);\n    } else {\n      debug(`Push tag: id=${id}, value=${value}`);\n    }\n\n    this.metadata.addTag('vorbis', id, value);\n  }\n\n  calculateDuration(header) {\n    if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n      // Calculate duration\n      this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n      this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n    }\n  }\n  /**\n   * Parse first Ogg/Vorbis page\n   * @param {IPageHeader} header\n   * @param {Buffer} pageData\n   */\n\n\n  parseFirstPage(header, pageData) {\n    this.metadata.setFormat('codec', 'Vorbis I');\n    debug(\"Parse first page\"); // Parse  Vorbis common header\n\n    const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n    if (commonHeader.vorbis !== 'vorbis') throw new Error('Metadata does not look like Vorbis');\n\n    if (commonHeader.packetType === 1) {\n      const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\n      this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n      this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n      this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n      debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n    } else throw new Error('First Ogg page should be type 1: the identification header');\n  }\n\n  parseFullPage(pageData) {\n    // New page\n    const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n    debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\n\n    switch (commonHeader.packetType) {\n      case 3:\n        //  type 3: comment header\n        return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\n\n      case 1: // type 1: the identification header\n\n      case 5:\n        // type 5: setup header type\n        break;\n      // ignore\n    }\n  }\n  /**\n   * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n   */\n\n\n  parseUserCommentList(pageData, offset) {\n    const strLen = Token.UINT32_LE.get(pageData, offset);\n    offset += 4; // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n\n    offset += strLen;\n    let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n    offset += 4;\n\n    while (userCommentListLength-- > 0) {\n      offset += this.parseUserComment(pageData, offset);\n    }\n  }\n\n}\n\nexports.VorbisParser = VorbisParser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js"],"names":["Object","defineProperty","exports","value","VorbisParser","Token","require","_debug","VorbisDecoder_1","Vorbis_1","debug","constructor","metadata","options","pageSegments","parsePage","header","pageData","headerType","firstPage","parseFirstPage","continued","length","Error","push","lastPage","fullPage","Buffer","concat","parseFullPage","calculateDuration","flush","parseUserComment","offset","decoder","VorbisDecoder","tag","addTag","key","len","id","skipCovers","VorbisPictureToken","fromBase64","format","sampleRate","absoluteGranulePosition","setFormat","numberOfSamples","commonHeader","CommonHeader","get","vorbis","packetType","idHeader","IdentificationHeader","bitrateNominal","channelMode","byteLength","parseUserCommentList","strLen","UINT32_LE","userCommentListLength"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VorbisParser = void 0;\nconst Token = require(\"token-types\");\nconst _debug = require(\"debug\");\nconst VorbisDecoder_1 = require(\"./VorbisDecoder\");\nconst Vorbis_1 = require(\"./Vorbis\");\nconst debug = _debug('music-metadata:parser:ogg:vorbis1');\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nclass VorbisParser {\n    constructor(metadata, options) {\n        this.metadata = metadata;\n        this.options = options;\n        this.pageSegments = [];\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new Error(\"Cannot continue on previous page\");\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = Buffer.concat(this.pageSegments);\n                    this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.calculateDuration(header);\n        }\n    }\n    flush() {\n        this.parseFullPage(Buffer.concat(this.pageSegments));\n    }\n    parseUserComment(pageData, offset) {\n        const decoder = new VorbisDecoder_1.VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(`Ignore picture`);\n                return;\n            }\n            value = Vorbis_1.VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n            this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param {IPageHeader} header\n     * @param {Buffer} pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        debug(\"Parse first page\");\n        // Parse  Vorbis common header\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new Error('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = Vorbis_1.IdentificationHeader.get(pageData, Vorbis_1.CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug(\"sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s\", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new Error('First Ogg page should be type 1: the identification header');\n    }\n    parseFullPage(pageData) {\n        // New page\n        const commonHeader = Vorbis_1.CommonHeader.get(pageData, 0);\n        debug(\"Parse full page: type=%s, byteLength=%s\", commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, Vorbis_1.CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    parseUserCommentList(pageData, offset) {\n        const strLen = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += this.parseUserComment(pageData, offset);\n        }\n    }\n}\nexports.VorbisParser = VorbisParser;\n//# sourceMappingURL=VorbisParser.js.map"]},"metadata":{},"sourceType":"script"}