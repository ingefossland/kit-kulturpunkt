{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\n\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\n\nexports.EndOfStreamError = EndOfFileStream_2.EndOfStreamError;\n\nclass Deferred {\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.reject = reject;\n      this.resolve = resolve;\n    });\n  }\n\n}\n\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\n\nclass StreamReader {\n  constructor(s) {\n    this.s = s;\n    this.endOfStream = false;\n    /**\n     * Store peeked data\n     * @type {Array}\n     */\n\n    this.peekQueue = [];\n\n    if (!s.read || !s.once) {\n      throw new Error('Expected an instance of stream.Readable');\n    }\n\n    this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n    this.s.once('error', err => this.reject(err));\n    this.s.once('close', () => this.reject(new Error('Stream closed')));\n  }\n  /**\n   * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n   * @param buffer - Buffer to store data read from stream in\n   * @param offset - Offset buffer\n   * @param length - Number of bytes to read\n   * @returns Number of bytes peeked\n   */\n\n\n  async peek(buffer, offset, length) {\n    const bytesRead = await this.read(buffer, offset, length);\n    this.peekQueue.push(buffer.slice(offset, offset + bytesRead)); // Put read data back to peek buffer\n\n    return bytesRead;\n  }\n  /**\n   * Read chunk from stream\n   * @param buffer - Target buffer to store data read from stream in\n   * @param offset - Offset of target buffer\n   * @param length - Number of bytes to read\n   * @returns Number of bytes read\n   */\n\n\n  async read(buffer, offset, length) {\n    if (length === 0) {\n      return 0;\n    }\n\n    if (this.peekQueue.length === 0 && this.endOfStream) {\n      throw new EndOfFileStream_1.EndOfStreamError();\n    }\n\n    let remaining = length;\n    let bytesRead = 0; // consume peeked data first\n\n    while (this.peekQueue.length > 0 && remaining > 0) {\n      const peekData = this.peekQueue.pop(); // Front of queue\n\n      const lenCopy = Math.min(peekData.length, remaining);\n      peekData.copy(buffer, offset + bytesRead, 0, lenCopy);\n      bytesRead += lenCopy;\n      remaining -= lenCopy;\n\n      if (lenCopy < peekData.length) {\n        // remainder back to queue\n        this.peekQueue.push(peekData.slice(lenCopy));\n      }\n    } // continue reading from stream if required\n\n\n    while (remaining > 0 && !this.endOfStream) {\n      const reqLen = Math.min(remaining, maxStreamReadSize);\n      const chunkLen = await this._read(buffer, offset + bytesRead, reqLen);\n      bytesRead += chunkLen;\n      if (chunkLen < reqLen) break;\n      remaining -= chunkLen;\n    }\n\n    return bytesRead;\n  }\n  /**\n   * Read chunk from stream\n   * @param buffer Buffer to store data read from stream in\n   * @param offset Offset buffer\n   * @param length Number of bytes to read\n   * @returns {any}\n   */\n\n\n  async _read(buffer, offset, length) {\n    assert.ok(!this.request, 'Concurrent read operation?');\n    const readBuffer = this.s.read(length);\n\n    if (readBuffer) {\n      readBuffer.copy(buffer, offset);\n      return readBuffer.length;\n    } else {\n      this.request = {\n        buffer,\n        offset,\n        length,\n        deferred: new Deferred()\n      };\n      this.s.once('readable', () => {\n        this.tryRead();\n      });\n      return this.request.deferred.promise.then(n => {\n        this.request = null;\n        return n;\n      }, err => {\n        this.request = null;\n        throw err;\n      });\n    }\n  }\n\n  tryRead() {\n    const readBuffer = this.s.read(this.request.length);\n\n    if (readBuffer) {\n      readBuffer.copy(this.request.buffer, this.request.offset);\n      this.request.deferred.resolve(readBuffer.length);\n    } else {\n      this.s.once('readable', () => {\n        this.tryRead();\n      });\n    }\n  }\n\n  reject(err) {\n    this.endOfStream = true;\n\n    if (this.request) {\n      this.request.deferred.reject(err);\n      this.request = null;\n    }\n  }\n\n}\n\nexports.StreamReader = StreamReader;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/peek-readable/lib/index.js"],"names":["Object","defineProperty","exports","value","assert","require","EndOfFileStream_1","EndOfFileStream_2","EndOfStreamError","Deferred","constructor","promise","Promise","resolve","reject","maxStreamReadSize","StreamReader","s","endOfStream","peekQueue","read","once","Error","err","peek","buffer","offset","length","bytesRead","push","slice","remaining","peekData","pop","lenCopy","Math","min","copy","reqLen","chunkLen","_read","ok","request","readBuffer","deferred","tryRead","then","n"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst EndOfFileStream_1 = require(\"./EndOfFileStream\");\nvar EndOfFileStream_2 = require(\"./EndOfFileStream\");\nexports.EndOfStreamError = EndOfFileStream_2.EndOfStreamError;\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\nconst maxStreamReadSize = 1 * 1024 * 1024; // Maximum request length on read-stream operation\nclass StreamReader {\n    constructor(s) {\n        this.s = s;\n        this.endOfStream = false;\n        /**\n         * Store peeked data\n         * @type {Array}\n         */\n        this.peekQueue = [];\n        if (!s.read || !s.once) {\n            throw new Error('Expected an instance of stream.Readable');\n        }\n        this.s.once('end', () => this.reject(new EndOfFileStream_1.EndOfStreamError()));\n        this.s.once('error', err => this.reject(err));\n        this.s.once('close', () => this.reject(new Error('Stream closed')));\n    }\n    /**\n     * Read ahead (peek) from stream. Subsequent read or peeks will return the same data\n     * @param buffer - Buffer to store data read from stream in\n     * @param offset - Offset buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes peeked\n     */\n    async peek(buffer, offset, length) {\n        const bytesRead = await this.read(buffer, offset, length);\n        this.peekQueue.push(buffer.slice(offset, offset + bytesRead)); // Put read data back to peek buffer\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer - Target buffer to store data read from stream in\n     * @param offset - Offset of target buffer\n     * @param length - Number of bytes to read\n     * @returns Number of bytes read\n     */\n    async read(buffer, offset, length) {\n        if (length === 0) {\n            return 0;\n        }\n        if (this.peekQueue.length === 0 && this.endOfStream) {\n            throw new EndOfFileStream_1.EndOfStreamError();\n        }\n        let remaining = length;\n        let bytesRead = 0;\n        // consume peeked data first\n        while (this.peekQueue.length > 0 && remaining > 0) {\n            const peekData = this.peekQueue.pop(); // Front of queue\n            const lenCopy = Math.min(peekData.length, remaining);\n            peekData.copy(buffer, offset + bytesRead, 0, lenCopy);\n            bytesRead += lenCopy;\n            remaining -= lenCopy;\n            if (lenCopy < peekData.length) {\n                // remainder back to queue\n                this.peekQueue.push(peekData.slice(lenCopy));\n            }\n        }\n        // continue reading from stream if required\n        while (remaining > 0 && !this.endOfStream) {\n            const reqLen = Math.min(remaining, maxStreamReadSize);\n            const chunkLen = await this._read(buffer, offset + bytesRead, reqLen);\n            bytesRead += chunkLen;\n            if (chunkLen < reqLen)\n                break;\n            remaining -= chunkLen;\n        }\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer Buffer to store data read from stream in\n     * @param offset Offset buffer\n     * @param length Number of bytes to read\n     * @returns {any}\n     */\n    async _read(buffer, offset, length) {\n        assert.ok(!this.request, 'Concurrent read operation?');\n        const readBuffer = this.s.read(length);\n        if (readBuffer) {\n            readBuffer.copy(buffer, offset);\n            return readBuffer.length;\n        }\n        else {\n            this.request = {\n                buffer,\n                offset,\n                length,\n                deferred: new Deferred()\n            };\n            this.s.once('readable', () => {\n                this.tryRead();\n            });\n            return this.request.deferred.promise.then(n => {\n                this.request = null;\n                return n;\n            }, err => {\n                this.request = null;\n                throw err;\n            });\n        }\n    }\n    tryRead() {\n        const readBuffer = this.s.read(this.request.length);\n        if (readBuffer) {\n            readBuffer.copy(this.request.buffer, this.request.offset);\n            this.request.deferred.resolve(readBuffer.length);\n        }\n        else {\n            this.s.once('readable', () => {\n                this.tryRead();\n            });\n        }\n    }\n    reject(err) {\n        this.endOfStream = true;\n        if (this.request) {\n            this.request.deferred.reject(err);\n            this.request = null;\n        }\n    }\n}\nexports.StreamReader = StreamReader;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}