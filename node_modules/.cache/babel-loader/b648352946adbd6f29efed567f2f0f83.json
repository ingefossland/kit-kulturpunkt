{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AIFFParser = void 0;\n\nconst Token = require(\"token-types\");\n\nconst initDebug = require(\"debug\");\n\nconst strtok3 = require(\"strtok3/lib/core\");\n\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nconst FourCC_1 = require(\"../common/FourCC\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst AiffToken = require(\"./AiffToken\");\n\nconst iff = require(\"../iff\");\n\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\n * AIFF - Audio Interchange File Format\n *\n * Ref:\n *  http://www.onicos.com/staff/iz/formats/aiff.html\n *  http://muratnkonar.com/aiff/index.html\n *  http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\n */\n\nclass AIFFParser extends BasicParser_1.BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(iff.Header);\n    if (header.chunkID !== 'FORM') throw new Error('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n\n    const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n\n    switch (type) {\n      case 'AIFF':\n        this.metadata.setFormat('container', type);\n        this.isCompressed = false;\n        break;\n\n      case 'AIFC':\n        this.metadata.setFormat('container', 'AIFF-C');\n        this.isCompressed = true;\n        break;\n\n      default:\n        throw Error('Unsupported AIFF type: ' + type);\n    }\n\n    this.metadata.setFormat('lossless', !this.isCompressed);\n\n    try {\n      while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\n        debug('Reading AIFF chunk at offset=' + this.tokenizer.position);\n        const chunkHeader = await this.tokenizer.readToken(iff.Header);\n        debug(`Chunk id=${chunkHeader.chunkID}`);\n        const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n        const bytesRead = await this.readData(chunkHeader);\n        await this.tokenizer.ignore(nextChunk - bytesRead);\n      }\n    } catch (err) {\n      if (err instanceof strtok3.EndOfStreamError) {\n        debug(`End-of-stream`);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  async readData(header) {\n    switch (header.chunkID) {\n      case 'COMM':\n        // The Common Chunk\n        const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n        this.metadata.setFormat('bitsPerSample', common.sampleSize);\n        this.metadata.setFormat('sampleRate', common.sampleRate);\n        this.metadata.setFormat('numberOfChannels', common.numChannels);\n        this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n        this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n        this.metadata.setFormat('codec', common.compressionName);\n        return header.chunkSize;\n\n      case 'ID3 ':\n        // ID3-meta-data\n        const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n        const rst = strtok3.fromBuffer(id3_data);\n        await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n        return header.chunkSize;\n\n      case 'SSND':\n        // Sound Data Chunk\n        if (this.metadata.format.duration) {\n          this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n        }\n\n        return 0;\n\n      default:\n        return 0;\n    }\n  }\n\n}\n\nexports.AIFFParser = AIFFParser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/aiff/AiffParser.js"],"names":["Object","defineProperty","exports","value","AIFFParser","Token","require","initDebug","strtok3","ID3v2Parser_1","FourCC_1","BasicParser_1","AiffToken","iff","debug","BasicParser","parse","header","tokenizer","readToken","Header","chunkID","Error","type","FourCcToken","metadata","setFormat","isCompressed","fileInfo","size","position","len","chunkHeader","nextChunk","Math","round","chunkSize","bytesRead","readData","ignore","err","EndOfStreamError","common","Common","sampleSize","sampleRate","numChannels","numSampleFrames","compressionName","id3_data","BufferType","rst","fromBuffer","ID3v2Parser","options","format","duration"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AIFFParser = void 0;\nconst Token = require(\"token-types\");\nconst initDebug = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst AiffToken = require(\"./AiffToken\");\nconst iff = require(\"../iff\");\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\n * AIFF - Audio Interchange File Format\n *\n * Ref:\n *  http://www.onicos.com/staff/iz/formats/aiff.html\n *  http://muratnkonar.com/aiff/index.html\n *  http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\n */\nclass AIFFParser extends BasicParser_1.BasicParser {\n    async parse() {\n        const header = await this.tokenizer.readToken(iff.Header);\n        if (header.chunkID !== 'FORM')\n            throw new Error('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n        const type = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        switch (type) {\n            case 'AIFF':\n                this.metadata.setFormat('container', type);\n                this.isCompressed = false;\n                break;\n            case 'AIFC':\n                this.metadata.setFormat('container', 'AIFF-C');\n                this.isCompressed = true;\n                break;\n            default:\n                throw Error('Unsupported AIFF type: ' + type);\n        }\n        this.metadata.setFormat('lossless', !this.isCompressed);\n        try {\n            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\n                debug('Reading AIFF chunk at offset=' + this.tokenizer.position);\n                const chunkHeader = await this.tokenizer.readToken(iff.Header);\n                debug(`Chunk id=${chunkHeader.chunkID}`);\n                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n                const bytesRead = await this.readData(chunkHeader);\n                await this.tokenizer.ignore(nextChunk - bytesRead);\n            }\n        }\n        catch (err) {\n            if (err instanceof strtok3.EndOfStreamError) {\n                debug(`End-of-stream`);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    async readData(header) {\n        switch (header.chunkID) {\n            case 'COMM': // The Common Chunk\n                const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n                this.metadata.setFormat('bitsPerSample', common.sampleSize);\n                this.metadata.setFormat('sampleRate', common.sampleRate);\n                this.metadata.setFormat('numberOfChannels', common.numChannels);\n                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n                this.metadata.setFormat('codec', common.compressionName);\n                return header.chunkSize;\n            case 'ID3 ': // ID3-meta-data\n                const id3_data = await this.tokenizer.readToken(new Token.BufferType(header.chunkSize));\n                const rst = strtok3.fromBuffer(id3_data);\n                await new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);\n                return header.chunkSize;\n            case 'SSND': // Sound Data Chunk\n                if (this.metadata.format.duration) {\n                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n                }\n                return 0;\n            default:\n                return 0;\n        }\n    }\n}\nexports.AIFFParser = AIFFParser;\n//# sourceMappingURL=AiffParser.js.map"]},"metadata":{},"sourceType":"script"}