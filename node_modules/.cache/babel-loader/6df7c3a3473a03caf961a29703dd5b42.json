{"ast":null,"code":"function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nvar IframeUrl = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(IframeUrl, _Component);\n\n  function IframeUrl() {\n    var _this;\n\n    _this = _Component.call(this) || this;\n\n    _defineProperty(_assertThisInitialized(_this), \"componentDidUpdate\", function (prevProps) {\n      if (prevProps.postMessage !== _this.props.postMessage) {\n        _this.sendMessage();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onLoad\", function () {\n      if (_this.props.onLoad) {\n        _this.props.onLoad();\n      } // TODO: Look into doing a syn-ack TCP-like handshake\n      //       to make sure iFrame is ready to REALLY accept messages, not just loaded.\n      // send intial props when iframe loads\n\n\n      _this.sendMessage();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"serializepostMessage\", function (data) {\n      // Rely on the browser's built-in structured clone algorithm for serialization of the\n      // message as described in\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n      if (!_this.props.serializeMessage) {\n        return data;\n      } // To be on the safe side we can also ignore the browser's built-in serialization feature\n      // and serialize the data manually.\n\n\n      if (typeof data === \"object\") {\n        return JSON.stringify(data);\n      } else if (typeof data === \"string\") {\n        return data;\n      } else {\n        return \"\" + data;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"sendMessage\", function () {\n      // Using postMessage data from props will result in a subtle but deadly bug,\n      // where old data from props is being sent instead of new postMessage.\n      // This is because data sent from componentWillReceiveProps is not yet in props but only in nextProps.\n      var _this$props = _this.props,\n          postMessage = _this$props.postMessage,\n          targetOrigin = _this$props.targetOrigin;\n\n      var serializedData = _this.serializepostMessage(postMessage);\n\n      _this._frame.contentWindow.postMessage(serializedData, targetOrigin);\n    });\n\n    _this.onReceiveMessage = _this.onReceiveMessage.bind(_assertThisInitialized(_this));\n    _this.onLoad = _this.onLoad.bind(_assertThisInitialized(_this));\n    _this.sendMessage = _this.sendMessage.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = IframeUrl.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    window.addEventListener(\"message\", this.onReceiveMessage);\n\n    this._frame.addEventListener(\"load\", this.onLoad);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    window.removeEventListener(\"message\", this.onReceiveMessage, false);\n  };\n\n  _proto.onReceiveMessage = function onReceiveMessage(event) {\n    if (this.props.onReceiveMessage) {\n      this.props.onReceiveMessage(event);\n    }\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props2 = this.props,\n        className = _this$props2.className,\n        url = _this$props2.url;\n    return /*#__PURE__*/React.createElement(\"iframe\", {\n      ref: function ref(el) {\n        _this2._frame = el;\n      },\n      className: className,\n      src: url\n    });\n  };\n\n  return IframeUrl;\n}(Component);\n\n_defineProperty(IframeUrl, \"defaultProps\", {\n  serializeMessage: true,\n  targetOrigin: \"*\",\n  postMessage: \"\"\n});\n\nIframeUrl.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  className: PropTypes.string,\n  url: PropTypes.string,\n  // Callback function called when iFrame sends the parent window a message.\n  onReceiveMessage: PropTypes.func,\n\n  /*    \n      Callback function called when iframe loads. \n      We're simply listening to the iframe's `window.onload`.\n      To ensure communication code in your iframe is totally loaded,\n      you can implement a syn-ack TCP-like handshake using `postMessage` and `onReceiveMessage`.\n  */\n  onLoad: PropTypes.func,\n\n  /*\n      You can pass it anything you want, we'll serialize to a string\n      preferablly use a simple string message or an object.\n      If you use an object, you need to follow the same naming convention\n      in the iframe so you can parse it accordingly.\n  */\n  postMessage: PropTypes.any.isRequired,\n\n  /*\n      Enable use of the browser's built-in structured clone algorithm for serialization\n      by settings this to `false`. \n      Default is `true`, using our built in logic for serializing everything to a string.\n  */\n  serializeMessage: PropTypes.bool,\n\n  /*\n      Always provide a specific targetOrigin, not *, if you know where the other window's document should be located. Failing to provide a specific target discloses the data you send to any interested malicious site.\n  */\n  targetOrigin: PropTypes.string\n} : {};\nexport default IframeUrl;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/@kit-ui/schema/node_modules/@kit-ui/core/es/Iframe/IframeUrl.js"],"names":["_assertThisInitialized","self","ReferenceError","_inheritsLoose","subClass","superClass","prototype","Object","create","constructor","__proto__","_defineProperty","obj","key","value","defineProperty","enumerable","configurable","writable","React","Component","PropTypes","IframeUrl","_Component","_this","call","prevProps","postMessage","props","sendMessage","onLoad","data","serializeMessage","JSON","stringify","_this$props","targetOrigin","serializedData","serializepostMessage","_frame","contentWindow","onReceiveMessage","bind","_proto","componentDidMount","window","addEventListener","componentWillUnmount","removeEventListener","event","render","_this2","_this$props2","className","url","createElement","ref","el","src","propTypes","process","env","NODE_ENV","string","func","any","isRequired","bool"],"mappings":"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","sourcesContent":["function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nvar IframeUrl = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(IframeUrl, _Component);\n\n  function IframeUrl() {\n    var _this;\n\n    _this = _Component.call(this) || this;\n\n    _defineProperty(_assertThisInitialized(_this), \"componentDidUpdate\", function (prevProps) {\n      if (prevProps.postMessage !== _this.props.postMessage) {\n        _this.sendMessage();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onLoad\", function () {\n      if (_this.props.onLoad) {\n        _this.props.onLoad();\n      } // TODO: Look into doing a syn-ack TCP-like handshake\n      //       to make sure iFrame is ready to REALLY accept messages, not just loaded.\n      // send intial props when iframe loads\n\n\n      _this.sendMessage();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"serializepostMessage\", function (data) {\n      // Rely on the browser's built-in structured clone algorithm for serialization of the\n      // message as described in\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n      if (!_this.props.serializeMessage) {\n        return data;\n      } // To be on the safe side we can also ignore the browser's built-in serialization feature\n      // and serialize the data manually.\n\n\n      if (typeof data === \"object\") {\n        return JSON.stringify(data);\n      } else if (typeof data === \"string\") {\n        return data;\n      } else {\n        return \"\" + data;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"sendMessage\", function () {\n      // Using postMessage data from props will result in a subtle but deadly bug,\n      // where old data from props is being sent instead of new postMessage.\n      // This is because data sent from componentWillReceiveProps is not yet in props but only in nextProps.\n      var _this$props = _this.props,\n          postMessage = _this$props.postMessage,\n          targetOrigin = _this$props.targetOrigin;\n\n      var serializedData = _this.serializepostMessage(postMessage);\n\n      _this._frame.contentWindow.postMessage(serializedData, targetOrigin);\n    });\n\n    _this.onReceiveMessage = _this.onReceiveMessage.bind(_assertThisInitialized(_this));\n    _this.onLoad = _this.onLoad.bind(_assertThisInitialized(_this));\n    _this.sendMessage = _this.sendMessage.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = IframeUrl.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    window.addEventListener(\"message\", this.onReceiveMessage);\n\n    this._frame.addEventListener(\"load\", this.onLoad);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    window.removeEventListener(\"message\", this.onReceiveMessage, false);\n  };\n\n  _proto.onReceiveMessage = function onReceiveMessage(event) {\n    if (this.props.onReceiveMessage) {\n      this.props.onReceiveMessage(event);\n    }\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props2 = this.props,\n        className = _this$props2.className,\n        url = _this$props2.url;\n    return /*#__PURE__*/React.createElement(\"iframe\", {\n      ref: function ref(el) {\n        _this2._frame = el;\n      },\n      className: className,\n      src: url\n    });\n  };\n\n  return IframeUrl;\n}(Component);\n\n_defineProperty(IframeUrl, \"defaultProps\", {\n  serializeMessage: true,\n  targetOrigin: \"*\",\n  postMessage: \"\"\n});\n\nIframeUrl.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  className: PropTypes.string,\n  url: PropTypes.string,\n  // Callback function called when iFrame sends the parent window a message.\n  onReceiveMessage: PropTypes.func,\n\n  /*    \n      Callback function called when iframe loads. \n      We're simply listening to the iframe's `window.onload`.\n      To ensure communication code in your iframe is totally loaded,\n      you can implement a syn-ack TCP-like handshake using `postMessage` and `onReceiveMessage`.\n  */\n  onLoad: PropTypes.func,\n\n  /*\n      You can pass it anything you want, we'll serialize to a string\n      preferablly use a simple string message or an object.\n      If you use an object, you need to follow the same naming convention\n      in the iframe so you can parse it accordingly.\n  */\n  postMessage: PropTypes.any.isRequired,\n\n  /*\n      Enable use of the browser's built-in structured clone algorithm for serialization\n      by settings this to `false`. \n      Default is `true`, using our built in logic for serializing everything to a string.\n  */\n  serializeMessage: PropTypes.bool,\n\n  /*\n      Always provide a specific targetOrigin, not *, if you know where the other window's document should be located. Failing to provide a specific target discloses the data you send to any interested malicious site.\n  */\n  targetOrigin: PropTypes.string\n} : {};\nexport default IframeUrl;"]},"metadata":{},"sourceType":"module"}