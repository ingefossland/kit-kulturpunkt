{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.APEv2Parser = void 0;\n\nconst initDebug = require(\"debug\");\n\nconst strtok3 = require(\"strtok3/lib/core\");\n\nconst assert = require(\"assert\");\n\nconst Util_1 = require(\"../common/Util\");\n\nconst BasicParser_1 = require(\"../common/BasicParser\");\n\nconst APEv2Token_1 = require(\"./APEv2Token\");\n\nconst token_types_1 = require(\"token-types\");\n\nconst debug = initDebug('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\n\nclass APEv2Parser extends BasicParser_1.BasicParser {\n  constructor() {\n    super(...arguments);\n    this.ape = {};\n  }\n\n  static tryParseApeHeader(metadata, tokenizer, options) {\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, tokenizer, options);\n    return apeParser.tryParseApeHeader();\n  }\n  /**\n   * Calculate the media file duration\n   * @param ah ApeHeader\n   * @return {number} duration in seconds\n   */\n\n\n  static calculateDuration(ah) {\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n    duration += ah.finalFrameBlocks;\n    return duration / ah.sampleRate;\n  }\n  /**\n   * Calculates the APEv1 / APEv2 first field offset\n   * @param reader\n   * @param offset\n   */\n\n\n  static async findApeFooterOffset(reader, offset) {\n    // Search for APE footer header at the end of the file\n    const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n    await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n    const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n\n    if (tagFooter.ID === 'APETAGEX') {\n      debug(`APE footer header at offset=${offset}`);\n      return {\n        footer: tagFooter,\n        offset: offset - tagFooter.size\n      };\n    }\n  }\n\n  static parseTagFooter(metadata, buffer, options) {\n    const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n    assert.strictEqual(footer.ID, preamble, 'APEv2 Footer preamble');\n    strtok3.fromBuffer(buffer);\n    const apeParser = new APEv2Parser();\n    apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n    return apeParser.parseTags(footer);\n  }\n  /**\n   * Parse APEv1 / APEv2 header if header signature found\n   */\n\n\n  async tryParseApeHeader() {\n    if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n      debug(`No APEv2 header found, end-of-file reached`);\n      return;\n    }\n\n    const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n\n    if (footer.ID === preamble) {\n      await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n      return this.parseTags(footer);\n    } else {\n      debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n\n      if (this.tokenizer.fileInfo.size) {\n        // Try to read the APEv2 header using just the footer-header\n        const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n\n        const buffer = Buffer.alloc(remaining);\n        await this.tokenizer.readBuffer(buffer);\n        return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n      }\n    }\n  }\n\n  async parse() {\n    const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n    assert.strictEqual(descriptor.ID, 'MAC ', 'descriptor.ID');\n    this.ape.descriptor = descriptor;\n    const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n    const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n    await this.tokenizer.ignore(header.forwardBytes);\n    return this.tryParseApeHeader();\n  }\n\n  async parseTags(footer) {\n    const keyBuffer = Buffer.alloc(256); // maximum tag key length\n\n    let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n    debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n\n    for (let i = 0; i < footer.fields; i++) {\n      if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n        this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n        break;\n      } // Only APEv2 tag has tag item headers\n\n\n      const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n      bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n      await this.tokenizer.peekBuffer(keyBuffer, {\n        length: Math.min(keyBuffer.length, bytesRemaining)\n      });\n      let zero = Util_1.default.findZero(keyBuffer, 0, keyBuffer.length);\n      const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n      await this.tokenizer.ignore(1);\n      bytesRemaining -= key.length + 1;\n\n      switch (tagItemHeader.flags.dataType) {\n        case APEv2Token_1.DataType.text_utf8:\n          {\n            // utf-8 textstring\n            const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n            const values = value.split(/\\x00/g);\n            /*jshint loopfunc:true */\n\n            for (const val of values) {\n              this.metadata.addTag(tagFormat, key, val);\n            }\n\n            break;\n          }\n\n        case APEv2Token_1.DataType.binary:\n          // binary (probably artwork)\n          if (this.options.skipCovers) {\n            await this.tokenizer.ignore(tagItemHeader.size);\n          } else {\n            const picData = Buffer.alloc(tagItemHeader.size);\n            await this.tokenizer.readBuffer(picData);\n            zero = Util_1.default.findZero(picData, 0, picData.length);\n            const description = picData.toString('utf8', 0, zero);\n            const data = Buffer.from(picData.slice(zero + 1));\n            this.metadata.addTag(tagFormat, key, {\n              description,\n              data\n            });\n          }\n\n          break;\n\n        case APEv2Token_1.DataType.external_info:\n          debug(`Ignore external info ${key}`);\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n\n        default:\n          throw new Error(`Unexpected data-type: ${tagItemHeader.flags.dataType}`);\n      }\n    }\n  }\n\n  async parseDescriptorExpansion(lenExp) {\n    await this.tokenizer.ignore(lenExp);\n    return this.parseHeader();\n  }\n\n  async parseHeader() {\n    const header = await this.tokenizer.readToken(APEv2Token_1.Header); // ToDo before\n\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('container', 'Monkey\\'s Audio');\n    this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n    this.metadata.setFormat('sampleRate', header.sampleRate);\n    this.metadata.setFormat('numberOfChannels', header.channel);\n    this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n    return {\n      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n    };\n  }\n\n}\n\nexports.APEv2Parser = APEv2Parser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/apev2/APEv2Parser.js"],"names":["Object","defineProperty","exports","value","APEv2Parser","initDebug","require","strtok3","assert","Util_1","BasicParser_1","APEv2Token_1","token_types_1","debug","tagFormat","preamble","BasicParser","constructor","arguments","ape","tryParseApeHeader","metadata","tokenizer","options","apeParser","init","calculateDuration","ah","duration","totalFrames","blocksPerFrame","finalFrameBlocks","sampleRate","findApeFooterOffset","reader","offset","apeBuf","Buffer","alloc","TagFooter","len","randomRead","tagFooter","get","ID","footer","size","parseTagFooter","buffer","length","strictEqual","fromBuffer","parseTags","fileInfo","position","peekToken","ignore","remaining","readBuffer","parse","descriptor","readToken","DescriptorParser","lenExp","descriptorBytes","header","parseDescriptorExpansion","parseHeader","forwardBytes","keyBuffer","bytesRemaining","i","fields","TagItemHeader","addWarning","tagItemHeader","peekBuffer","Math","min","zero","default","findZero","key","StringType","flags","dataType","DataType","text_utf8","values","split","val","addTag","binary","skipCovers","picData","description","toString","data","from","slice","external_info","Error","Header","setFormat","bitsPerSample","channel","seekTableBytes","headerDataBytes","apeFrameDataBytes","terminatingDataBytes"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APEv2Parser = void 0;\nconst initDebug = require(\"debug\");\nconst strtok3 = require(\"strtok3/lib/core\");\nconst assert = require(\"assert\");\nconst Util_1 = require(\"../common/Util\");\nconst BasicParser_1 = require(\"../common/BasicParser\");\nconst APEv2Token_1 = require(\"./APEv2Token\");\nconst token_types_1 = require(\"token-types\");\nconst debug = initDebug('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nclass APEv2Parser extends BasicParser_1.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.ape = {};\n    }\n    static tryParseApeHeader(metadata, tokenizer, options) {\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, tokenizer, options);\n        return apeParser.tryParseApeHeader();\n    }\n    /**\n     * Calculate the media file duration\n     * @param ah ApeHeader\n     * @return {number} duration in seconds\n     */\n    static calculateDuration(ah) {\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n        duration += ah.finalFrameBlocks;\n        return duration / ah.sampleRate;\n    }\n    /**\n     * Calculates the APEv1 / APEv2 first field offset\n     * @param reader\n     * @param offset\n     */\n    static async findApeFooterOffset(reader, offset) {\n        // Search for APE footer header at the end of the file\n        const apeBuf = Buffer.alloc(APEv2Token_1.TagFooter.len);\n        await reader.randomRead(apeBuf, 0, APEv2Token_1.TagFooter.len, offset - APEv2Token_1.TagFooter.len);\n        const tagFooter = APEv2Token_1.TagFooter.get(apeBuf, 0);\n        if (tagFooter.ID === 'APETAGEX') {\n            debug(`APE footer header at offset=${offset}`);\n            return { footer: tagFooter, offset: offset - tagFooter.size };\n        }\n    }\n    static parseTagFooter(metadata, buffer, options) {\n        const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);\n        assert.strictEqual(footer.ID, preamble, 'APEv2 Footer preamble');\n        strtok3.fromBuffer(buffer);\n        const apeParser = new APEv2Parser();\n        apeParser.init(metadata, strtok3.fromBuffer(buffer), options);\n        return apeParser.parseTags(footer);\n    }\n    /**\n     * Parse APEv1 / APEv2 header if header signature found\n     */\n    async tryParseApeHeader() {\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < APEv2Token_1.TagFooter.len) {\n            debug(`No APEv2 header found, end-of-file reached`);\n            return;\n        }\n        const footer = await this.tokenizer.peekToken(APEv2Token_1.TagFooter);\n        if (footer.ID === preamble) {\n            await this.tokenizer.ignore(APEv2Token_1.TagFooter.len);\n            return this.parseTags(footer);\n        }\n        else {\n            debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n            if (this.tokenizer.fileInfo.size) {\n                // Try to read the APEv2 header using just the footer-header\n                const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n                const buffer = Buffer.alloc(remaining);\n                await this.tokenizer.readBuffer(buffer);\n                return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n            }\n        }\n    }\n    async parse() {\n        const descriptor = await this.tokenizer.readToken(APEv2Token_1.DescriptorParser);\n        assert.strictEqual(descriptor.ID, 'MAC ', 'descriptor.ID');\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n        await this.tokenizer.ignore(header.forwardBytes);\n        return this.tryParseApeHeader();\n    }\n    async parseTags(footer) {\n        const keyBuffer = Buffer.alloc(256); // maximum tag key length\n        let bytesRemaining = footer.size - APEv2Token_1.TagFooter.len;\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n        for (let i = 0; i < footer.fields; i++) {\n            if (bytesRemaining < APEv2Token_1.TagItemHeader.len) {\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n                break;\n            }\n            // Only APEv2 tag has tag item headers\n            const tagItemHeader = await this.tokenizer.readToken(APEv2Token_1.TagItemHeader);\n            bytesRemaining -= APEv2Token_1.TagItemHeader.len + tagItemHeader.size;\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\n            let zero = Util_1.default.findZero(keyBuffer, 0, keyBuffer.length);\n            const key = await this.tokenizer.readToken(new token_types_1.StringType(zero, 'ascii'));\n            await this.tokenizer.ignore(1);\n            bytesRemaining -= key.length + 1;\n            switch (tagItemHeader.flags.dataType) {\n                case APEv2Token_1.DataType.text_utf8: { // utf-8 textstring\n                    const value = await this.tokenizer.readToken(new token_types_1.StringType(tagItemHeader.size, 'utf8'));\n                    const values = value.split(/\\x00/g);\n                    /*jshint loopfunc:true */\n                    for (const val of values) {\n                        this.metadata.addTag(tagFormat, key, val);\n                    }\n                    break;\n                }\n                case APEv2Token_1.DataType.binary: // binary (probably artwork)\n                    if (this.options.skipCovers) {\n                        await this.tokenizer.ignore(tagItemHeader.size);\n                    }\n                    else {\n                        const picData = Buffer.alloc(tagItemHeader.size);\n                        await this.tokenizer.readBuffer(picData);\n                        zero = Util_1.default.findZero(picData, 0, picData.length);\n                        const description = picData.toString('utf8', 0, zero);\n                        const data = Buffer.from(picData.slice(zero + 1));\n                        this.metadata.addTag(tagFormat, key, {\n                            description,\n                            data\n                        });\n                    }\n                    break;\n                case APEv2Token_1.DataType.external_info:\n                    debug(`Ignore external info ${key}`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n                default:\n                    throw new Error(`Unexpected data-type: ${tagItemHeader.flags.dataType}`);\n            }\n        }\n    }\n    async parseDescriptorExpansion(lenExp) {\n        await this.tokenizer.ignore(lenExp);\n        return this.parseHeader();\n    }\n    async parseHeader() {\n        const header = await this.tokenizer.readToken(APEv2Token_1.Header);\n        // ToDo before\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n        this.metadata.setFormat('sampleRate', header.sampleRate);\n        this.metadata.setFormat('numberOfChannels', header.channel);\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n        return {\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n        };\n    }\n}\nexports.APEv2Parser = APEv2Parser;\n//# sourceMappingURL=APEv2Parser.js.map"]},"metadata":{},"sourceType":"script"}