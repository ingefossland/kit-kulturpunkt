{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FlacParser = void 0;\n\nconst Util_1 = require(\"../common/Util\");\n\nconst Token = require(\"token-types\");\n\nconst Vorbis_1 = require(\"../ogg/vorbis/Vorbis\");\n\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\n\nconst FourCC_1 = require(\"../common/FourCC\");\n\nconst _debug = require(\"debug\");\n\nconst VorbisParser_1 = require(\"../ogg/vorbis/VorbisParser\");\n\nconst VorbisDecoder_1 = require(\"../ogg/vorbis/VorbisDecoder\");\n\nconst debug = _debug('music-metadata:parser:FLAC');\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\n\n\nvar BlockType;\n\n(function (BlockType) {\n  BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n  BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n  BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n  BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n  BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n  BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n  BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\n\nclass FlacParser extends AbstractID3Parser_1.AbstractID3Parser {\n  constructor() {\n    super(...arguments);\n    this.padding = 0;\n  }\n  /**\n   * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n   * @param {INativeMetadataCollector} metadata Output\n   * @param {ITokenizer} tokenizer Input\n   * @param {IOptions} options Parsing options\n   */\n\n\n  init(metadata, tokenizer, options) {\n    super.init(metadata, tokenizer, options);\n    this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\n    return this;\n  }\n\n  async _parse() {\n    const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n\n    if (fourCC.toString() !== 'fLaC') {\n      throw new Error('Invalid FLAC preamble');\n    }\n\n    let blockHeader;\n\n    do {\n      // Read block header\n      blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader); // Parse block data\n\n      await this.parseDataBlock(blockHeader);\n    } while (!blockHeader.lastBlock);\n\n    if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n      const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n      this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n    }\n  }\n\n  parseDataBlock(blockHeader) {\n    debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n\n    switch (blockHeader.type) {\n      case BlockType.STREAMINFO:\n        return this.parseBlockStreamInfo(blockHeader.length);\n\n      case BlockType.PADDING:\n        this.padding += blockHeader.length;\n        break;\n\n      case BlockType.APPLICATION:\n        break;\n\n      case BlockType.SEEKTABLE:\n        break;\n\n      case BlockType.VORBIS_COMMENT:\n        return this.parseComment(blockHeader.length);\n\n      case BlockType.CUESHEET:\n        break;\n\n      case BlockType.PICTURE:\n        return this.parsePicture(blockHeader.length).then();\n\n      default:\n        this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\n    } // Ignore data block\n\n\n    return this.tokenizer.ignore(blockHeader.length).then();\n  }\n  /**\n   * Parse STREAMINFO\n   */\n\n\n  async parseBlockStreamInfo(dataLen) {\n    if (dataLen !== Metadata.BlockStreamInfo.len) throw new Error('Unexpected block-stream-info length');\n    const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);\n    this.metadata.setFormat('container', 'FLAC');\n    this.metadata.setFormat('codec', 'FLAC');\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n    this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n    this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n\n    if (streamInfo.totalSamples > 0) {\n      this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n    }\n  }\n  /**\n   * Parse VORBIS_COMMENT\n   * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n   */\n\n\n  async parseComment(dataLen) {\n    const data = await this.tokenizer.readToken(new Token.BufferType(dataLen));\n    const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\n    decoder.readStringUtf8(); // vendor (skip)\n\n    const commentListLength = decoder.readInt32();\n\n    for (let i = 0; i < commentListLength; i++) {\n      const tag = decoder.parseUserComment();\n      this.vorbisParser.addTag(tag.key, tag.value);\n    }\n  }\n\n  async parsePicture(dataLen) {\n    if (this.options.skipCovers) {\n      return this.tokenizer.ignore(dataLen);\n    } else {\n      const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\n      this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n  }\n\n}\n\nexports.FlacParser = FlacParser;\n\nclass Metadata {}\n\nMetadata.BlockHeader = {\n  len: 4,\n  get: (buf, off) => {\n    return {\n      lastBlock: Util_1.default.strtokBITSET.get(buf, off, 7),\n      type: Util_1.default.getBitAllignedNumber(buf, off, 1, 7),\n      length: Token.UINT24_BE.get(buf, off + 1)\n    };\n  }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\n\nMetadata.BlockStreamInfo = {\n  len: 34,\n  get: (buf, off) => {\n    return {\n      // The minimum block size (in samples) used in the stream.\n      minimumBlockSize: Token.UINT16_BE.get(buf, off),\n      // The maximum block size (in samples) used in the stream.\n      // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n      maximumBlockSize: Token.UINT16_BE.get(buf, off + 2) / 1000,\n      // The minimum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      minimumFrameSize: Token.UINT24_BE.get(buf, off + 4),\n      // The maximum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      maximumFrameSize: Token.UINT24_BE.get(buf, off + 7),\n      // Sample rate in Hz. Though 20 bits are available,\n      // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n      // Also, a value of 0 is invalid.\n      sampleRate: Token.UINT24_BE.get(buf, off + 10) >> 4,\n      // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n      // (number of channels)-1. FLAC supports from 1 to 8 channels\n      channels: Util_1.default.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n      // bits per sample)-1.\n      // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n      bitsPerSample: Util_1.default.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n      // Total samples in stream.\n      // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n      // A value of zero here means the number of total samples is unknown.\n      totalSamples: Util_1.default.getBitAllignedNumber(buf, off + 13, 4, 36),\n      // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n      fileMD5: new Token.BufferType(16).get(buf, off + 18)\n    };\n  }\n};","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/flac/FlacParser.js"],"names":["Object","defineProperty","exports","value","FlacParser","Util_1","require","Token","Vorbis_1","AbstractID3Parser_1","FourCC_1","_debug","VorbisParser_1","VorbisDecoder_1","debug","BlockType","AbstractID3Parser","constructor","arguments","padding","init","metadata","tokenizer","options","vorbisParser","VorbisParser","_parse","fourCC","readToken","FourCcToken","toString","Error","blockHeader","Metadata","BlockHeader","parseDataBlock","lastBlock","fileInfo","size","format","duration","dataSize","position","setFormat","type","length","STREAMINFO","parseBlockStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","parseComment","CUESHEET","PICTURE","parsePicture","then","addWarning","ignore","dataLen","BlockStreamInfo","len","streamInfo","channels","bitsPerSample","sampleRate","totalSamples","data","BufferType","decoder","VorbisDecoder","readStringUtf8","commentListLength","readInt32","i","tag","parseUserComment","addTag","key","skipCovers","picture","VorbisPictureToken","get","buf","off","default","strtokBITSET","getBitAllignedNumber","UINT24_BE","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlacParser = void 0;\nconst Util_1 = require(\"../common/Util\");\nconst Token = require(\"token-types\");\nconst Vorbis_1 = require(\"../ogg/vorbis/Vorbis\");\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst FourCC_1 = require(\"../common/FourCC\");\nconst _debug = require(\"debug\");\nconst VorbisParser_1 = require(\"../ogg/vorbis/VorbisParser\");\nconst VorbisDecoder_1 = require(\"../ogg/vorbis/VorbisDecoder\");\nconst debug = _debug('music-metadata:parser:FLAC');\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n    BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n    BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n    BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n    BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\nclass FlacParser extends AbstractID3Parser_1.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.padding = 0;\n    }\n    /**\n     * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).\n     * @param {INativeMetadataCollector} metadata Output\n     * @param {ITokenizer} tokenizer Input\n     * @param {IOptions} options Parsing options\n     */\n    init(metadata, tokenizer, options) {\n        super.init(metadata, tokenizer, options);\n        this.vorbisParser = new VorbisParser_1.VorbisParser(metadata, options);\n        return this;\n    }\n    async _parse() {\n        const fourCC = await this.tokenizer.readToken(FourCC_1.FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new Error('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Metadata.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case BlockType.STREAMINFO:\n                return this.parseBlockStreamInfo(blockHeader.length);\n            case BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case BlockType.APPLICATION:\n                break;\n            case BlockType.SEEKTABLE:\n                break;\n            case BlockType.VORBIS_COMMENT:\n                return this.parseComment(blockHeader.length);\n            case BlockType.CUESHEET:\n                break;\n            case BlockType.PICTURE:\n                return this.parsePicture(blockHeader.length).then();\n            default:\n                this.metadata.addWarning('Unknown block type: ' + blockHeader.type);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async parseBlockStreamInfo(dataLen) {\n        if (dataLen !== Metadata.BlockStreamInfo.len)\n            throw new Error('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Metadata.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Token.BufferType(dataLen));\n        const decoder = new VorbisDecoder_1.VorbisDecoder(data, 0);\n        decoder.readStringUtf8(); // vendor (skip)\n        const commentListLength = decoder.readInt32();\n        for (let i = 0; i < commentListLength; i++) {\n            const tag = decoder.parseUserComment();\n            this.vorbisParser.addTag(tag.key, tag.value);\n        }\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        else {\n            const picture = await this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));\n            this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n        }\n    }\n}\nexports.FlacParser = FlacParser;\nclass Metadata {\n}\nMetadata.BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: Util_1.default.strtokBITSET.get(buf, off, 7),\n            type: Util_1.default.getBitAllignedNumber(buf, off, 1, 7),\n            length: Token.UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nMetadata.BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: Token.UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: Token.UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: Token.UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: Token.UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: Token.UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: Util_1.default.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: Util_1.default.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: Util_1.default.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new Token.BufferType(16).get(buf, off + 18)\n        };\n    }\n};\n//# sourceMappingURL=FlacParser.js.map"]},"metadata":{},"sourceType":"script"}