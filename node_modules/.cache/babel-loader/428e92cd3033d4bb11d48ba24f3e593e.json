{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\n\nconst strtok3 = require(\"strtok3/lib/core\");\n\nconst ParserFactory_1 = require(\"./ParserFactory\");\n\nconst RandomBufferReader_1 = require(\"./common/RandomBufferReader\");\n\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\n\nconst ID3v1Parser_1 = require(\"./id3v1/ID3v1Parser\");\n\nconst Lyrics3_1 = require(\"./lyrics3/Lyrics3\");\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param options - Parsing options\n * @param fileInfo - File information object or MIME-type string\n * @returns Metadata\n */\n\n\nfunction parseStream(stream, fileInfo, options = {}) {\n  return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo), options);\n}\n\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node Buffer\n * @param buf - Buffer holding audio data\n * @param fileInfo - File information object or MIME-type string\n * @param options - Parsing options\n * @returns Metadata\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\n */\n\nasync function parseBuffer(buf, fileInfo, options = {}) {\n  const bufferReader = new RandomBufferReader_1.RandomBufferReader(buf);\n  await scanAppendingHeaders(bufferReader, options);\n  const tokenizer = strtok3.fromBuffer(buf, typeof fileInfo === 'string' ? {\n    mimeType: fileInfo\n  } : fileInfo);\n  return parseFromTokenizer(tokenizer, options);\n}\n\nexports.parseBuffer = parseBuffer;\n/**\n * Parse audio from ITokenizer source\n * @param tokenizer - Audio source implementing the tokenizer interface\n * @param options - Parsing options\n * @returns Metadata\n */\n\nfunction parseFromTokenizer(tokenizer, options) {\n  return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\n}\n\nexports.parseFromTokenizer = parseFromTokenizer;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags list of tags\n * @returns tags indexed by id\n */\n\nfunction orderTags(nativeTags) {\n  const tags = {};\n\n  for (const tag of nativeTags) {\n    (tags[tag.id] = tags[tag.id] || []).push(tag.value);\n  }\n\n  return tags;\n}\n\nexports.orderTags = orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\n\nfunction ratingToStars(rating) {\n  return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\n\nexports.ratingToStars = ratingToStars;\n/**\n * Select most likely cover image.\n * @param pictures Usually metadata.common.picture\n * @return Cover image, if any, otherwise null\n */\n\nfunction selectCover(pictures) {\n  return pictures ? pictures.reduce((acc, cur) => {\n    if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)']) return cur;\n    return acc;\n  }) : null;\n}\n\nexports.selectCover = selectCover;\n\nasync function scanAppendingHeaders(randomReader, options = {}) {\n  let apeOffset = randomReader.fileSize;\n\n  if (await ID3v1Parser_1.hasID3v1Header(randomReader)) {\n    apeOffset -= 128;\n    const lyricsLen = await Lyrics3_1.getLyricsHeaderLength(randomReader);\n    apeOffset -= lyricsLen;\n  }\n\n  options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\n}\n\nexports.scanAppendingHeaders = scanAppendingHeaders;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/core.js"],"names":["Object","defineProperty","exports","value","scanAppendingHeaders","selectCover","ratingToStars","orderTags","parseFromTokenizer","parseBuffer","parseStream","strtok3","require","ParserFactory_1","RandomBufferReader_1","APEv2Parser_1","ID3v1Parser_1","Lyrics3_1","stream","fileInfo","options","fromStream","mimeType","buf","bufferReader","RandomBufferReader","tokenizer","fromBuffer","ParserFactory","parseOnContentType","nativeTags","tags","tag","id","push","rating","undefined","Math","round","pictures","reduce","acc","cur","name","toLowerCase","randomReader","apeOffset","fileSize","hasID3v1Header","lyricsLen","getLyricsHeaderLength","apeHeader","APEv2Parser","findApeFooterOffset"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scanAppendingHeaders = exports.selectCover = exports.ratingToStars = exports.orderTags = exports.parseFromTokenizer = exports.parseBuffer = exports.parseStream = void 0;\nconst strtok3 = require(\"strtok3/lib/core\");\nconst ParserFactory_1 = require(\"./ParserFactory\");\nconst RandomBufferReader_1 = require(\"./common/RandomBufferReader\");\nconst APEv2Parser_1 = require(\"./apev2/APEv2Parser\");\nconst ID3v1Parser_1 = require(\"./id3v1/ID3v1Parser\");\nconst Lyrics3_1 = require(\"./lyrics3/Lyrics3\");\n/**\n * Parse audio from Node Stream.Readable\n * @param stream - Stream to read the audio track from\n * @param options - Parsing options\n * @param fileInfo - File information object or MIME-type string\n * @returns Metadata\n */\nfunction parseStream(stream, fileInfo, options = {}) {\n    return parseFromTokenizer(strtok3.fromStream(stream, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo), options);\n}\nexports.parseStream = parseStream;\n/**\n * Parse audio from Node Buffer\n * @param buf - Buffer holding audio data\n * @param fileInfo - File information object or MIME-type string\n * @param options - Parsing options\n * @returns Metadata\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\n */\nasync function parseBuffer(buf, fileInfo, options = {}) {\n    const bufferReader = new RandomBufferReader_1.RandomBufferReader(buf);\n    await scanAppendingHeaders(bufferReader, options);\n    const tokenizer = strtok3.fromBuffer(buf, typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo);\n    return parseFromTokenizer(tokenizer, options);\n}\nexports.parseBuffer = parseBuffer;\n/**\n * Parse audio from ITokenizer source\n * @param tokenizer - Audio source implementing the tokenizer interface\n * @param options - Parsing options\n * @returns Metadata\n */\nfunction parseFromTokenizer(tokenizer, options) {\n    return ParserFactory_1.ParserFactory.parseOnContentType(tokenizer, options);\n}\nexports.parseFromTokenizer = parseFromTokenizer;\n/**\n * Create a dictionary ordered by their tag id (key)\n * @param nativeTags list of tags\n * @returns tags indexed by id\n */\nfunction orderTags(nativeTags) {\n    const tags = {};\n    for (const tag of nativeTags) {\n        (tags[tag.id] = (tags[tag.id] || [])).push(tag.value);\n    }\n    return tags;\n}\nexports.orderTags = orderTags;\n/**\n * Convert rating to 1-5 star rating\n * @param rating: Normalized rating [0..1] (common.rating[n].rating)\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\n */\nfunction ratingToStars(rating) {\n    return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\nexports.ratingToStars = ratingToStars;\n/**\n * Select most likely cover image.\n * @param pictures Usually metadata.common.picture\n * @return Cover image, if any, otherwise null\n */\nfunction selectCover(pictures) {\n    return pictures ? pictures.reduce((acc, cur) => {\n        if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)'])\n            return cur;\n        return acc;\n    }) : null;\n}\nexports.selectCover = selectCover;\nasync function scanAppendingHeaders(randomReader, options = {}) {\n    let apeOffset = randomReader.fileSize;\n    if (await ID3v1Parser_1.hasID3v1Header(randomReader)) {\n        apeOffset -= 128;\n        const lyricsLen = await Lyrics3_1.getLyricsHeaderLength(randomReader);\n        apeOffset -= lyricsLen;\n    }\n    options.apeHeader = await APEv2Parser_1.APEv2Parser.findApeFooterOffset(randomReader, apeOffset);\n}\nexports.scanAppendingHeaders = scanAppendingHeaders;\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"script"}