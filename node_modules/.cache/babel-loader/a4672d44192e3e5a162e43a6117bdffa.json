{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DsfParser = void 0;\n\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\n\nconst assert = require(\"assert\");\n\nconst _debug = require(\"debug\");\n\nconst DsfChunk_1 = require(\"./DsfChunk\");\n\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\n\nconst debug = _debug('music-metadata:parser:DSF');\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\n\n\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\n  async _parse() {\n    const p0 = this.tokenizer.position; // mark start position, normally 0\n\n    const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n    assert.strictEqual(chunkHeader.id, 'DSD ', 'Invalid chunk signature');\n    this.metadata.setFormat('container', 'DSF');\n    this.metadata.setFormat('lossless', true);\n    const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n\n    if (dsdChunk.metadataPointer === 0) {\n      debug(`No ID3v2 tag present`);\n    } else {\n      debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n      await this.parseChunks(dsdChunk.fileSize - chunkHeader.size); // Jump to ID3 header\n\n      await this.tokenizer.ignore(dsdChunk.metadataPointer - this.tokenizer.position - p0);\n      return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n    }\n  }\n\n  async parseChunks(bytesRemaining) {\n    while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\n      const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n      debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n\n      switch (chunkHeader.id) {\n        case 'fmt ':\n          const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n          this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n          this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n          this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n          this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n          this.metadata.setFormat('duration', formatChunk.sampleCount / formatChunk.samplingFrequency);\n          const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n          this.metadata.setFormat('bitrate', bitrate);\n          return;\n        // We got what we want, stop further processing of chunks\n\n        default:\n          this.tokenizer.ignore(chunkHeader.size - DsfChunk_1.ChunkHeader.len);\n          break;\n      }\n\n      bytesRemaining -= chunkHeader.size;\n    }\n  }\n\n}\n\nexports.DsfParser = DsfParser;","map":{"version":3,"sources":["/Users/inge/Sites/kit-kulturpunkt/node_modules/music-metadata/lib/dsf/DsfParser.js"],"names":["Object","defineProperty","exports","value","DsfParser","AbstractID3Parser_1","require","assert","_debug","DsfChunk_1","ID3v2Parser_1","debug","AbstractID3Parser","_parse","p0","tokenizer","position","chunkHeader","readToken","ChunkHeader","strictEqual","id","metadata","setFormat","dsdChunk","DsdChunk","metadataPointer","parseChunks","fileSize","size","ignore","ID3v2Parser","parse","options","bytesRemaining","len","formatChunk","FormatChunk","channelNum","samplingFrequency","bitsPerSample","sampleCount","bitrate"],"mappings":"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","sourcesContent":["'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DsfParser = void 0;\nconst AbstractID3Parser_1 = require(\"../id3v2/AbstractID3Parser\");\nconst assert = require(\"assert\");\nconst _debug = require(\"debug\");\nconst DsfChunk_1 = require(\"./DsfChunk\");\nconst ID3v2Parser_1 = require(\"../id3v2/ID3v2Parser\");\nconst debug = _debug('music-metadata:parser:DSF');\n/**\n * DSF (dsd stream file) File Parser\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\n */\nclass DsfParser extends AbstractID3Parser_1.AbstractID3Parser {\n    async _parse() {\n        const p0 = this.tokenizer.position; // mark start position, normally 0\n        const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n        assert.strictEqual(chunkHeader.id, 'DSD ', 'Invalid chunk signature');\n        this.metadata.setFormat('container', 'DSF');\n        this.metadata.setFormat('lossless', true);\n        const dsdChunk = await this.tokenizer.readToken(DsfChunk_1.DsdChunk);\n        if (dsdChunk.metadataPointer === 0) {\n            debug(`No ID3v2 tag present`);\n        }\n        else {\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n            // Jump to ID3 header\n            await this.tokenizer.ignore(dsdChunk.metadataPointer - this.tokenizer.position - p0);\n            return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n        }\n    }\n    async parseChunks(bytesRemaining) {\n        while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {\n            const chunkHeader = await this.tokenizer.readToken(DsfChunk_1.ChunkHeader);\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n            switch (chunkHeader.id) {\n                case 'fmt ':\n                    const formatChunk = await this.tokenizer.readToken(DsfChunk_1.FormatChunk);\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n                    this.metadata.setFormat('duration', formatChunk.sampleCount / formatChunk.samplingFrequency);\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n                    this.metadata.setFormat('bitrate', bitrate);\n                    return; // We got what we want, stop further processing of chunks\n                default:\n                    this.tokenizer.ignore(chunkHeader.size - DsfChunk_1.ChunkHeader.len);\n                    break;\n            }\n            bytesRemaining -= chunkHeader.size;\n        }\n    }\n}\nexports.DsfParser = DsfParser;\n//# sourceMappingURL=DsfParser.js.map"]},"metadata":{},"sourceType":"script"}